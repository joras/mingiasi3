/**
 * This file was auto-generated by openapi-zod.
 * Do not make direct changes to the file.
 */


import { z } from 'zod';



export const operations = {

  getActivities: {
    /**
     * Get all activities assigned to a particular user 
     * @description Returns all activities assigned to a particular user.
     */
    parameters: {
        /** @description The ID of the user whose activities will be fetched. If omitted, the user associated with the API token will be used. If 0, activities for all company users will be fetched based on the permission sets. */
        /** @description The ID of the filter to use (will narrow down results if used together with `user_id` parameter) */
        /** @description The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the `key_string` parameter of ActivityTypes. */
        /** @description For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. */
        /** @description For pagination, the position that represents the first result for the page */
        /** @description Use the activity due date where you wish to begin fetching activities from. Insert due date in YYYY-MM-DD format. */
        /** @description Use the activity due date where you wish to stop fetching activities from. Insert due date in YYYY-MM-DD format. */
        /** @description Whether the activity is done or not. 0 = Not done, 1 = Done. If omitted returns both done and not done activities. */
      query: z.object({
        user_id: z.number().int().optional(),
        filter_id: z.number().int().optional(),
        type: z.string().optional(),
        limit: z.number().int().optional(),
        start: z.number().int().optional(),
        start_date: z.string().optional(),
        end_date: z.string().optional(),
        done: z.number().optional(),
      }).optional(),
    },
    responses: {
      /** @description A list of activities */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                due_date: z.string().optional(),
                due_time: z.string().optional(),
                duration: z.string().optional(),
                deal_id: z.number().int().optional(),
                lead_id: z.string().nullable().optional(),
                person_id: z.number().int().optional(),
                project_id: z.number().int().nullable().optional(),
                org_id: z.number().int().optional(),
                location: z.string().optional(),
                public_description: z.string().optional(),
              }), z.object({
                id: z.number().int().optional(),
                note: z.string().optional(),
                done: z.boolean().optional(),
                subject: z.string().optional(),
                type: z.string().optional(),
                user_id: z.number().int().optional(),
                participants: z.array(z.record(z.any())).nullable().optional(),
                busy_flag: z.boolean().optional(),
                attendees: z.array(z.record(z.any())).nullable().optional(),
                company_id: z.number().int().optional(),
                reference_type: z.string().optional(),
                reference_id: z.number().int().optional(),
                conference_meeting_client: z.string().optional(),
                conference_meeting_url: z.string().optional(),
                conference_meeting_id: z.string().optional(),
                add_time: z.string().optional(),
                marked_as_done_time: z.string().optional(),
                last_notification_time: z.string().optional(),
                last_notification_user_id: z.number().int().optional(),
                notification_language_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                update_time: z.string().optional(),
                update_user_id: z.number().int().optional(),
                gcal_event_id: z.string().optional(),
                google_calendar_id: z.string().optional(),
                google_calendar_etag: z.string().optional(),
                calendar_sync_include_context: z.string().optional(),
                source_timezone: z.string().optional(),
                rec_rule: z.string().optional(),
                rec_rule_extension: z.string().optional(),
                rec_master_activity_id: z.number().int().optional(),
                series: z.array(z.record(z.any())).optional(),
                created_by_user_id: z.number().int().optional(),
                location_subpremise: z.string().optional(),
                location_street_number: z.string().optional(),
                location_route: z.string().optional(),
                location_sublocality: z.string().optional(),
                location_locality: z.string().optional(),
                location_admin_area_level_1: z.string().optional(),
                location_admin_area_level_2: z.string().optional(),
                location_country: z.string().optional(),
                location_postal_code: z.string().optional(),
                location_formatted_address: z.string().optional(),
                org_name: z.string().optional(),
                person_name: z.string().optional(),
                deal_title: z.string().optional(),
                owner_name: z.string().optional(),
                person_dropbox_bcc: z.string().optional(),
                deal_dropbox_bcc: z.string().optional(),
                assigned_to_user_id: z.number().int().optional(),
                file: z.record(z.any()).optional(),
              }))).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
                next_start: z.number().int().optional(),
              }).optional(),
            }).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              deal: z.object({
                DEAL_ID: z.object({
                  id: z.number().int().optional(),
                  title: z.string().optional(),
                  status: z.string().optional(),
                  value: z.number().optional(),
                  currency: z.string().optional(),
                  stage_id: z.number().int().optional(),
                  pipeline_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  addActivity: {
    /**
     * Add an activity 
     * @description Adds a new activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data). For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-an-activity" target="_blank" rel="noopener noreferrer">adding an activity</a>.
     */
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          due_date: z.string().nullish(),
          due_time: z.string().nullish(),
          duration: z.string().nullish(),
          deal_id: z.number().int().nullish(),
          lead_id: z.string().nullable().nullish(),
          person_id: z.number().int().nullish(),
          project_id: z.number().int().nullable().nullish(),
          org_id: z.number().int().nullish(),
          location: z.string().nullish(),
          public_description: z.string().nullish(),
        }), z.object({
          note: z.string().nullish(),
          subject: z.string().nullish(),
          type: z.string().nullish(),
          user_id: z.number().int().nullish(),
          participants: z.array(z.record(z.any())).nullish(),
          busy_flag: z.boolean().nullish(),
          attendees: z.array(z.record(z.any())).nullish(),
          done: z.number().nullish(),
        })),
      },
    },
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              due_date: z.string().optional(),
              due_time: z.string().optional(),
              duration: z.string().optional(),
              deal_id: z.number().int().optional(),
              lead_id: z.string().nullable().optional(),
              person_id: z.number().int().optional(),
              project_id: z.number().int().nullable().optional(),
              org_id: z.number().int().optional(),
              location: z.string().optional(),
              public_description: z.string().optional(),
            }), z.object({
              id: z.number().int().optional(),
              note: z.string().optional(),
              done: z.boolean().optional(),
              subject: z.string().optional(),
              type: z.string().optional(),
              user_id: z.number().int().optional(),
              participants: z.array(z.record(z.any())).nullable().optional(),
              busy_flag: z.boolean().optional(),
              attendees: z.array(z.record(z.any())).nullable().optional(),
              company_id: z.number().int().optional(),
              reference_type: z.string().optional(),
              reference_id: z.number().int().optional(),
              conference_meeting_client: z.string().optional(),
              conference_meeting_url: z.string().optional(),
              conference_meeting_id: z.string().optional(),
              add_time: z.string().optional(),
              marked_as_done_time: z.string().optional(),
              last_notification_time: z.string().optional(),
              last_notification_user_id: z.number().int().optional(),
              notification_language_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              update_time: z.string().optional(),
              update_user_id: z.number().int().optional(),
              gcal_event_id: z.string().optional(),
              google_calendar_id: z.string().optional(),
              google_calendar_etag: z.string().optional(),
              calendar_sync_include_context: z.string().optional(),
              source_timezone: z.string().optional(),
              rec_rule: z.string().optional(),
              rec_rule_extension: z.string().optional(),
              rec_master_activity_id: z.number().int().optional(),
              series: z.array(z.record(z.any())).optional(),
              created_by_user_id: z.number().int().optional(),
              location_subpremise: z.string().optional(),
              location_street_number: z.string().optional(),
              location_route: z.string().optional(),
              location_sublocality: z.string().optional(),
              location_locality: z.string().optional(),
              location_admin_area_level_1: z.string().optional(),
              location_admin_area_level_2: z.string().optional(),
              location_country: z.string().optional(),
              location_postal_code: z.string().optional(),
              location_formatted_address: z.string().optional(),
              org_name: z.string().optional(),
              person_name: z.string().optional(),
              deal_title: z.string().optional(),
              owner_name: z.string().optional(),
              person_dropbox_bcc: z.string().optional(),
              deal_dropbox_bcc: z.string().optional(),
              assigned_to_user_id: z.number().int().optional(),
              file: z.record(z.any()).optional(),
            })).optional(),
            additional_data: z.object({
              updates_story_id: z.number().int().optional(),
            }).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              deal: z.object({
                DEAL_ID: z.object({
                  id: z.number().int().optional(),
                  title: z.string().optional(),
                  status: z.string().optional(),
                  value: z.number().optional(),
                  currency: z.string().optional(),
                  stage_id: z.number().int().optional(),
                  pipeline_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }))).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteActivities: {
    /**
     * Delete multiple activities in bulk 
     * @description Marks multiple activities as deleted. After 30 days, the activities will be permanently deleted.
     */
    parameters: {
        /** @description The comma-separated IDs of activities that will be deleted */
      query: z.object({
        ids: z.string(),
      }),
    },
    responses: {
      /** @description The activities were successfully deleted */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.array(z.number().int()).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getActivitiesCollection: {
    /**
     * Get all activities (BETA) 
     * @description Returns all activities. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href="https://support.pipedrive.com/en/article/global-user-management" target="_blank" rel="noopener noreferrer">here</a>.
     */
    parameters: {
        /** @description For pagination, the marker (an opaque string value) representing the first item on the next page */
        /** @description For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed. */
        /** @description The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field. */
        /** @description The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field. */
        /** @description The ID of the user whose activities will be fetched. If omitted, all activities are returned. */
        /** @description Whether the activity is done or not. `false` = Not done, `true` = Done. If omitted, returns both done and not done activities. */
        /** @description The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the `key_string` parameter of ActivityTypes. */
      query: z.object({
        cursor: z.string().optional(),
        limit: z.number().int().optional(),
        since: z.string().optional(),
        until: z.string().optional(),
        user_id: z.number().int().optional(),
        done: z.boolean().optional(),
        type: z.string().optional(),
      }).optional(),
    },
    responses: {
      /** @description A list of activities */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                due_date: z.string().optional(),
                due_time: z.string().optional(),
                duration: z.string().optional(),
                deal_id: z.number().int().optional(),
                lead_id: z.string().nullable().optional(),
                person_id: z.number().int().optional(),
                project_id: z.number().int().nullable().optional(),
                org_id: z.number().int().optional(),
                location: z.string().optional(),
                public_description: z.string().optional(),
              }), z.object({
                id: z.number().int().optional(),
                done: z.boolean().optional(),
                subject: z.string().optional(),
                type: z.string().optional(),
                user_id: z.number().int().optional(),
                busy_flag: z.boolean().optional(),
                company_id: z.number().int().optional(),
                conference_meeting_client: z.string().optional(),
                conference_meeting_url: z.string().optional(),
                conference_meeting_id: z.string().optional(),
                add_time: z.string().optional(),
                marked_as_done_time: z.string().optional(),
                active_flag: z.boolean().optional(),
                update_time: z.string().optional(),
                update_user_id: z.number().int().optional(),
                source_timezone: z.string().optional(),
                location_subpremise: z.string().optional(),
                location_street_number: z.string().optional(),
                location_route: z.string().optional(),
                location_sublocality: z.string().optional(),
                location_locality: z.string().optional(),
                location_admin_area_level_1: z.string().optional(),
                location_admin_area_level_2: z.string().optional(),
                location_country: z.string().optional(),
                location_postal_code: z.string().optional(),
                location_formatted_address: z.string().optional(),
              }))).optional(),
            additional_data: z.object({
              next_cursor: z.string().optional(),
            }).optional(),
          }),
        },
      },
      /** @description Forbidden response */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  getActivity: {
    /**
     * Get details of an activity 
     * @description Returns the details of a specific activity.
     */
    parameters: {
        /** @description The ID of the activity */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description The request was successful */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              due_date: z.string().optional(),
              due_time: z.string().optional(),
              duration: z.string().optional(),
              deal_id: z.number().int().optional(),
              lead_id: z.string().nullable().optional(),
              person_id: z.number().int().optional(),
              project_id: z.number().int().nullable().optional(),
              org_id: z.number().int().optional(),
              location: z.string().optional(),
              public_description: z.string().optional(),
            }), z.object({
              id: z.number().int().optional(),
              note: z.string().optional(),
              done: z.boolean().optional(),
              subject: z.string().optional(),
              type: z.string().optional(),
              user_id: z.number().int().optional(),
              participants: z.array(z.record(z.any())).nullable().optional(),
              busy_flag: z.boolean().optional(),
              attendees: z.array(z.record(z.any())).nullable().optional(),
              company_id: z.number().int().optional(),
              reference_type: z.string().optional(),
              reference_id: z.number().int().optional(),
              conference_meeting_client: z.string().optional(),
              conference_meeting_url: z.string().optional(),
              conference_meeting_id: z.string().optional(),
              add_time: z.string().optional(),
              marked_as_done_time: z.string().optional(),
              last_notification_time: z.string().optional(),
              last_notification_user_id: z.number().int().optional(),
              notification_language_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              update_time: z.string().optional(),
              update_user_id: z.number().int().optional(),
              gcal_event_id: z.string().optional(),
              google_calendar_id: z.string().optional(),
              google_calendar_etag: z.string().optional(),
              calendar_sync_include_context: z.string().optional(),
              source_timezone: z.string().optional(),
              rec_rule: z.string().optional(),
              rec_rule_extension: z.string().optional(),
              rec_master_activity_id: z.number().int().optional(),
              series: z.array(z.record(z.any())).optional(),
              created_by_user_id: z.number().int().optional(),
              location_subpremise: z.string().optional(),
              location_street_number: z.string().optional(),
              location_route: z.string().optional(),
              location_sublocality: z.string().optional(),
              location_locality: z.string().optional(),
              location_admin_area_level_1: z.string().optional(),
              location_admin_area_level_2: z.string().optional(),
              location_country: z.string().optional(),
              location_postal_code: z.string().optional(),
              location_formatted_address: z.string().optional(),
              org_name: z.string().optional(),
              person_name: z.string().optional(),
              deal_title: z.string().optional(),
              owner_name: z.string().optional(),
              person_dropbox_bcc: z.string().optional(),
              deal_dropbox_bcc: z.string().optional(),
              assigned_to_user_id: z.number().int().optional(),
              file: z.record(z.any()).optional(),
            })).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              deal: z.object({
                DEAL_ID: z.object({
                  id: z.number().int().optional(),
                  title: z.string().optional(),
                  status: z.string().optional(),
                  value: z.number().optional(),
                  currency: z.string().optional(),
                  stage_id: z.number().int().optional(),
                  pipeline_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  updateActivity: {
    /**
     * Update an activity 
     * @description Updates an activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data).
     */
    parameters: {
        /** @description The ID of the activity */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          due_date: z.string().nullish(),
          due_time: z.string().nullish(),
          duration: z.string().nullish(),
          deal_id: z.number().int().nullish(),
          lead_id: z.string().nullable().nullish(),
          person_id: z.number().int().nullish(),
          project_id: z.number().int().nullable().nullish(),
          org_id: z.number().int().nullish(),
          location: z.string().nullish(),
          public_description: z.string().nullish(),
        }), z.object({
          note: z.string().nullish(),
          subject: z.string().nullish(),
          type: z.string().nullish(),
          user_id: z.number().int().nullish(),
          participants: z.array(z.record(z.any())).nullish(),
          busy_flag: z.boolean().nullish(),
          attendees: z.array(z.record(z.any())).nullish(),
          done: z.number().nullish(),
        })),
      },
    },
    responses: {
      /** @description The request was successful */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              due_date: z.string().optional(),
              due_time: z.string().optional(),
              duration: z.string().optional(),
              deal_id: z.number().int().optional(),
              lead_id: z.string().nullable().optional(),
              person_id: z.number().int().optional(),
              project_id: z.number().int().nullable().optional(),
              org_id: z.number().int().optional(),
              location: z.string().optional(),
              public_description: z.string().optional(),
            }), z.object({
              id: z.number().int().optional(),
              note: z.string().optional(),
              done: z.boolean().optional(),
              subject: z.string().optional(),
              type: z.string().optional(),
              user_id: z.number().int().optional(),
              participants: z.array(z.record(z.any())).nullable().optional(),
              busy_flag: z.boolean().optional(),
              attendees: z.array(z.record(z.any())).nullable().optional(),
              company_id: z.number().int().optional(),
              reference_type: z.string().optional(),
              reference_id: z.number().int().optional(),
              conference_meeting_client: z.string().optional(),
              conference_meeting_url: z.string().optional(),
              conference_meeting_id: z.string().optional(),
              add_time: z.string().optional(),
              marked_as_done_time: z.string().optional(),
              last_notification_time: z.string().optional(),
              last_notification_user_id: z.number().int().optional(),
              notification_language_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              update_time: z.string().optional(),
              update_user_id: z.number().int().optional(),
              gcal_event_id: z.string().optional(),
              google_calendar_id: z.string().optional(),
              google_calendar_etag: z.string().optional(),
              calendar_sync_include_context: z.string().optional(),
              source_timezone: z.string().optional(),
              rec_rule: z.string().optional(),
              rec_rule_extension: z.string().optional(),
              rec_master_activity_id: z.number().int().optional(),
              series: z.array(z.record(z.any())).optional(),
              created_by_user_id: z.number().int().optional(),
              location_subpremise: z.string().optional(),
              location_street_number: z.string().optional(),
              location_route: z.string().optional(),
              location_sublocality: z.string().optional(),
              location_locality: z.string().optional(),
              location_admin_area_level_1: z.string().optional(),
              location_admin_area_level_2: z.string().optional(),
              location_country: z.string().optional(),
              location_postal_code: z.string().optional(),
              location_formatted_address: z.string().optional(),
              org_name: z.string().optional(),
              person_name: z.string().optional(),
              deal_title: z.string().optional(),
              owner_name: z.string().optional(),
              person_dropbox_bcc: z.string().optional(),
              deal_dropbox_bcc: z.string().optional(),
              assigned_to_user_id: z.number().int().optional(),
              file: z.record(z.any()).optional(),
            })).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              deal: z.object({
                DEAL_ID: z.object({
                  id: z.number().int().optional(),
                  title: z.string().optional(),
                  status: z.string().optional(),
                  value: z.number().optional(),
                  currency: z.string().optional(),
                  stage_id: z.number().int().optional(),
                  pipeline_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }))).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteActivity: {
    /**
     * Delete an activity 
     * @description Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
     */
    parameters: {
        /** @description The ID of the activity */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description The activity was successfully deleted */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getActivityFields: {
    /**
     * Get all activity fields 
     * @description Returns all activity fields.
     */
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                key: z.string().optional(),
                name: z.string().optional(),
                order_nr: z.number().int().optional(),
                field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                last_updated_by_user_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                edit_flag: z.boolean().optional(),
                index_visible_flag: z.boolean().optional(),
                details_visible_flag: z.boolean().optional(),
                add_visible_flag: z.boolean().optional(),
                important_flag: z.boolean().optional(),
                bulk_edit_allowed: z.boolean().optional(),
                searchable_flag: z.boolean().optional(),
                filtering_allowed: z.boolean().optional(),
                sortable_flag: z.boolean().optional(),
                mandatory_flag: z.boolean().optional(),
                options: z.array(z.record(z.any())).nullable().optional(),
                options_deleted: z.array(z.record(z.any())).optional(),
                is_subfield: z.boolean().optional(),
                subfields: z.array(z.record(z.any())).optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getActivityTypes: {
    /**
     * Get all activity types 
     * @description Returns all activity types.
     */
    responses: {
      /** @description A list of activity types */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                icon_key: z.enum(["task", "email", "meeting", "deadline", "call", "lunch", "calendar", "downarrow", "document", "smartphone", "camera", "scissors", "cogs", "bubble", "uparrow", "checkbox", "signpost", "shuffle", "addressbook", "linegraph", "picture", "car", "world", "search", "clip", "sound", "brush", "key", "padlock", "pricetag", "suitcase", "finish", "plane", "loop", "wifi", "truck", "cart", "bulb", "bell", "presentation"]).optional(),
                color: z.string().optional(),
                order_nr: z.number().int().optional(),
                key_string: z.string().optional(),
                active_flag: z.boolean().optional(),
                is_custom_flag: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              })).optional(),
          })),
        },
      },
    },
  },
  addActivityType: {
    /**
     * Add new activity type 
     * @description Adds a new activity type.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string(),
          icon_key: z.enum(["task", "email", "meeting", "deadline", "call", "lunch", "calendar", "downarrow", "document", "smartphone", "camera", "scissors", "cogs", "bubble", "uparrow", "checkbox", "signpost", "shuffle", "addressbook", "linegraph", "picture", "car", "world", "search", "clip", "sound", "brush", "key", "padlock", "pricetag", "suitcase", "finish", "plane", "loop", "wifi", "truck", "cart", "bulb", "bell", "presentation"]),
          color: z.string().nullish(),
        }),
      },
    },
    responses: {
      /** @description The activity type was successfully created */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              icon_key: z.enum(["task", "email", "meeting", "deadline", "call", "lunch", "calendar", "downarrow", "document", "smartphone", "camera", "scissors", "cogs", "bubble", "uparrow", "checkbox", "signpost", "shuffle", "addressbook", "linegraph", "picture", "car", "world", "search", "clip", "sound", "brush", "key", "padlock", "pricetag", "suitcase", "finish", "plane", "loop", "wifi", "truck", "cart", "bulb", "bell", "presentation"]).optional(),
              color: z.string().optional(),
              order_nr: z.number().int().optional(),
              key_string: z.string().optional(),
              active_flag: z.boolean().optional(),
              is_custom_flag: z.boolean().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteActivityTypes: {
    /**
     * Delete multiple activity types in bulk 
     * @description Marks multiple activity types as deleted.
     */
    parameters: {
        /** @description The comma-separated activity type IDs */
      query: z.object({
        ids: z.string(),
      }),
    },
    responses: {
      /** @description The activity types were successfully deleted */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.array(z.number().int()).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  updateActivityType: {
    /**
     * Update an activity type 
     * @description Updates an activity type.
     */
    parameters: {
        /** @description The ID of the activity type */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string().nullish(),
          icon_key: z.enum(["task", "email", "meeting", "deadline", "call", "lunch", "calendar", "downarrow", "document", "smartphone", "camera", "scissors", "cogs", "bubble", "uparrow", "checkbox", "signpost", "shuffle", "addressbook", "linegraph", "picture", "car", "world", "search", "clip", "sound", "brush", "key", "padlock", "pricetag", "suitcase", "finish", "plane", "loop", "wifi", "truck", "cart", "bulb", "bell", "presentation"]).nullish(),
          color: z.string().nullish(),
          order_nr: z.number().int().nullish(),
        }),
      },
    },
    responses: {
      /** @description The activity type was successfully updated */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              icon_key: z.enum(["task", "email", "meeting", "deadline", "call", "lunch", "calendar", "downarrow", "document", "smartphone", "camera", "scissors", "cogs", "bubble", "uparrow", "checkbox", "signpost", "shuffle", "addressbook", "linegraph", "picture", "car", "world", "search", "clip", "sound", "brush", "key", "padlock", "pricetag", "suitcase", "finish", "plane", "loop", "wifi", "truck", "cart", "bulb", "bell", "presentation"]).optional(),
              color: z.string().optional(),
              order_nr: z.number().int().optional(),
              key_string: z.string().optional(),
              active_flag: z.boolean().optional(),
              is_custom_flag: z.boolean().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteActivityType: {
    /**
     * Delete an activity type 
     * @description Marks an activity type as deleted.
     */
    parameters: {
        /** @description The ID of the activity type */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description The activity type was successfully deleted */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              icon_key: z.enum(["task", "email", "meeting", "deadline", "call", "lunch", "calendar", "downarrow", "document", "smartphone", "camera", "scissors", "cogs", "bubble", "uparrow", "checkbox", "signpost", "shuffle", "addressbook", "linegraph", "picture", "car", "world", "search", "clip", "sound", "brush", "key", "padlock", "pricetag", "suitcase", "finish", "plane", "loop", "wifi", "truck", "cart", "bulb", "bell", "presentation"]).optional(),
              color: z.string().optional(),
              order_nr: z.number().int().optional(),
              key_string: z.string().optional(),
              active_flag: z.boolean().optional(),
              is_custom_flag: z.boolean().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getCompanyAddons: {
    /**
     * Get all add-ons for a single company 
     * @description Returns the add-ons for a single company.
     */
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.record(z.any())).optional(),
          })),
        },
      },
    },
  },
  getUserCallLogs: {
    /**
     * Get all call logs assigned to a particular user 
     * @description Returns all call logs assigned to a particular user.
     */
    parameters: {
        /** @description Pagination start */
        /** @description For pagination, the limit of entries to be returned. The upper limit is 50. */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
    },
    responses: {
      /** @description A list of call logs. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                user_id: z.number().int().optional(),
                activity_id: z.number().int().optional(),
                subject: z.string().optional(),
                duration: z.string().optional(),
                outcome: z.enum(["connected", "no_answer", "left_message", "left_voicemail", "wrong_number", "busy"]),
                from_phone_number: z.string().optional(),
                to_phone_number: z.string(),
                start_time: z.string(),
                end_time: z.string(),
                person_id: z.number().int().optional(),
                org_id: z.number().int().optional(),
                deal_id: z.number().int().optional(),
                lead_id: z.string().optional(),
                note: z.string().optional(),
              }), z.object({
                id: z.string().optional(),
                has_recording: z.boolean().optional(),
                company_id: z.number().int().optional(),
              }))).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  addCallLog: {
    /**
     * Add a call log 
     * @description Adds a new call log.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          user_id: z.number().int().nullish(),
          activity_id: z.number().int().nullish(),
          subject: z.string().nullish(),
          duration: z.string().nullish(),
          outcome: z.enum(["connected", "no_answer", "left_message", "left_voicemail", "wrong_number", "busy"]),
          from_phone_number: z.string().nullish(),
          to_phone_number: z.string(),
          start_time: z.string(),
          end_time: z.string(),
          person_id: z.number().int().nullish(),
          org_id: z.number().int().nullish(),
          deal_id: z.number().int().nullish(),
          lead_id: z.string().nullish(),
          note: z.string().nullish(),
        }),
      },
    },
    responses: {
      /** @description The call log was successfully created. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              user_id: z.number().int().optional(),
              activity_id: z.number().int().optional(),
              subject: z.string().optional(),
              duration: z.string().optional(),
              outcome: z.enum(["connected", "no_answer", "left_message", "left_voicemail", "wrong_number", "busy"]),
              from_phone_number: z.string().optional(),
              to_phone_number: z.string(),
              start_time: z.string(),
              end_time: z.string(),
              person_id: z.number().int().optional(),
              org_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              lead_id: z.string().optional(),
              note: z.string().optional(),
            }), z.object({
              id: z.string().optional(),
              has_recording: z.boolean().optional(),
              company_id: z.number().int().optional(),
            })).optional(),
          }),
        },
      },
      /** @description The request contains wrong or incorrectly formatted arguments. */
      400: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
      /** @description You don't have permission to access the resource. */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
      /** @description A resource required to process the request was not found. */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
      /** @description There was an error processing the request. */
      500: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getCallLog: {
    /**
     * Get details of a call log 
     * @description Returns details of a specific call log.
     */
    parameters: {
        /** @description The ID received when you create the call log */
      path: z.object({
        id: z.string(),
      }),
    },
    responses: {
      /** @description The requested call log object. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              user_id: z.number().int().optional(),
              activity_id: z.number().int().optional(),
              subject: z.string().optional(),
              duration: z.string().optional(),
              outcome: z.enum(["connected", "no_answer", "left_message", "left_voicemail", "wrong_number", "busy"]),
              from_phone_number: z.string().optional(),
              to_phone_number: z.string(),
              start_time: z.string(),
              end_time: z.string(),
              person_id: z.number().int().optional(),
              org_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              lead_id: z.string().optional(),
              note: z.string().optional(),
            }), z.object({
              id: z.string().optional(),
              has_recording: z.boolean().optional(),
              company_id: z.number().int().optional(),
            })).optional(),
          }),
        },
      },
      /** @description A resource required to process the request was not found. */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  deleteCallLog: {
    /**
     * Delete a call log 
     * @description Deletes a call log. If there is an audio recording attached to it, it will also be deleted. The related activity will not be removed by this request. If you want to remove the related activities, please use the endpoint which is specific for activities.
     */
    parameters: {
        /** @description The ID received when you create the call log */
      path: z.object({
        id: z.string(),
      }),
    },
    responses: {
      /** @description The call log was successfully deleted. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
          }),
        },
      },
      /** @description You don't have permission to access the resource. */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
      /** @description A resource required to process the request was not found. */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
      /** @description The callLog you are trying to access is no longer available. */
      410: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
      /** @description There was an error processing the request. */
      500: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  addCallLogAudioFile: {
    /**
     * Attach an audio file to the call log 
     * @description Adds an audio recording to the call log. That audio can be played by those who have access to the call log object.
     */
    parameters: {
        /** @description The ID received when you create the call log */
      path: z.object({
        id: z.string(),
      }),
    },
    requestBody: {
      content: {
        "multipart/form-data": z.object({
          file: z.string(),
        }),
      },
    },
    responses: {
      /** @description The audio recording was successfully added to the log. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
          }),
        },
      },
      /** @description A resource required to process the request was not found. */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
      /** @description Recording for this call already exists. */
      409: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
      /** @description There was an error processing the request. */
      500: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  addChannel: {
    /**
     * Add a channel 
     * @description Adds a new messaging channel, only admins are able to register new channels. It will use the getConversations endpoint to fetch conversations, participants and messages afterward. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     */
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string(),
          provider_channel_id: z.string(),
          avatar_url: z.string().nullish(),
          template_support: z.boolean().nullish(),
          provider_type: z.enum(["facebook", "whatsapp", "other"]).nullish(),
        }),
      },
    },
    responses: {
      /** @description The channel registered */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.string().optional(),
              name: z.string().optional(),
              avatar_url: z.string().optional(),
              provider_channel_id: z.string().optional(),
              marketplace_client_id: z.string().optional(),
              pd_company_id: z.number().int().optional(),
              pd_user_id: z.number().int().optional(),
              created_at: z.string().optional(),
              provider_type: z.enum(["facebook", "whatsapp", "other"]).optional(),
              template_support: z.boolean().optional(),
            }).optional(),
          }),
        },
      },
      /** @description Bad Request */
      400: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            additional_data: z.object({
              code: z.string().optional(),
            }).optional(),
          }),
        },
      },
      /** @description Forbidden */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            additional_data: z.object({
              code: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteChannel: {
    /**
     * Delete a channel 
     * @description Deletes an existing messengers channel and all related entities (conversations and messages). To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     */
    parameters: {
        /** @description The ID of the channel provided by the integration */
      path: z.object({
        id: z.string(),
      }),
    },
    responses: {
      /** @description The channel was deleted */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
          }),
        },
      },
      /** @description Bad Request */
      400: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            additional_data: z.object({
              code: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  receiveMessage: {
    /**
     * Receives an incoming message 
     * @description Adds a message to a conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     */
    requestBody: {
      content: {
        "application/json": z.object({
          id: z.string(),
          channel_id: z.string(),
          sender_id: z.string(),
          conversation_id: z.string(),
          message: z.string(),
          status: z.enum(["sent", "delivered", "read", "failed"]),
          created_at: z.string(),
          reply_by: z.string().nullish(),
          conversation_link: z.string().nullish(),
          attachments: z.array(z.object({
              id: z.string(),
              type: z.string(),
              name: z.string().nullish(),
              size: z.number().nullish(),
              url: z.string(),
              preview_url: z.string().nullish(),
              link_expires: z.boolean().nullish(),
            })).nullish(),
        }),
      },
    },
    responses: {
      /** @description The message was registered in the conversation */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.string(),
              channel_id: z.string(),
              sender_id: z.string(),
              conversation_id: z.string(),
              message: z.string(),
              status: z.enum(["sent", "delivered", "read", "failed"]),
              created_at: z.string(),
              reply_by: z.string().optional(),
              conversation_link: z.string().optional(),
              attachments: z.array(z.object({
                  id: z.string(),
                  type: z.string(),
                  name: z.string().optional(),
                  size: z.number().optional(),
                  url: z.string(),
                  preview_url: z.string().optional(),
                  link_expires: z.boolean().optional(),
                })).optional(),
            }).optional(),
          }),
        },
      },
      /** @description Bad Request */
      400: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            additional_data: z.object({
              code: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteConversation: {
    /**
     * Delete a conversation 
     * @description Deletes an existing conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     */
    parameters: {
        /** @description The ID of the channel provided by the integration */
        /** @description The ID of the conversation provided by the integration */
      path: z.object({
        "channel-id": z.string(),
        "conversation-id": z.string(),
      }),
    },
    responses: {
      /** @description The conversation was deleted */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
          }),
        },
      },
      /** @description Forbidden */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            additional_data: z.object({
              code: z.string().optional(),
            }).optional(),
          }),
        },
      },
      /** @description Not Found */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            additional_data: z.object({
              code: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getCurrencies: {
    /**
     * Get all supported currencies 
     * @description Returns all supported currencies in given account which should be used when saving monetary values with other objects. The `code` parameter of the returning objects is the currency code according to ISO 4217 for all non-custom currencies.
     */
    parameters: {
        /** @description Optional search term that is searched for from currency's name and/or code */
      query: z.object({
        term: z.string().optional(),
      }).optional(),
    },
    responses: {
      /** @description The list of supported currencies */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                id: z.number().int().optional(),
                code: z.string().optional(),
                name: z.string().optional(),
                decimal_points: z.number().int().optional(),
                symbol: z.string().optional(),
                active_flag: z.boolean().optional(),
                is_custom_flag: z.boolean().optional(),
              })).optional(),
          }),
        },
      },
    },
  },
  getDeals: {
    /**
     * Get all deals 
     * @description Returns all deals. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/getting-all-deals" target="_blank" rel="noopener noreferrer">getting all deals</a>.
     */
    parameters: {
        /** @description If supplied, only deals matching the given user will be returned. However, `filter_id` and `owned_by_you` takes precedence over `user_id` when supplied. */
        /** @description The ID of the filter to use */
        /** @description If supplied, only deals within the given stage will be returned */
        /** @description Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. */
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys). */
        /** @description When supplied, only deals owned by you are returned. However, `filter_id` takes precedence over `owned_by_you` when both are supplied. */
      query: z.object({
        user_id: z.number().int().optional(),
        filter_id: z.number().int().optional(),
        stage_id: z.number().int().optional(),
        status: z.enum(["open", "won", "lost", "deleted", "all_not_deleted"]).optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        sort: z.string().optional(),
        owned_by_you: z.number().optional(),
      }).optional(),
    },
    responses: {
      /** @description Get all deals */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                creator_user_id: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.boolean().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                  value: z.number().int().optional(),
                }).optional(),
                user_id: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.boolean().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                person_id: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                org_id: z.intersection(z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  active_flag: z.boolean().optional(),
                  cc_email: z.string().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
              }), z.object({
                stage_id: z.number().int().optional(),
                title: z.string().optional(),
                value: z.number().optional(),
                currency: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                stage_change_time: z.string().optional(),
                active: z.boolean().optional(),
                deleted: z.boolean().optional(),
                status: z.string().optional(),
                probability: z.number().nullable().optional(),
                next_activity_date: z.string().optional(),
                next_activity_time: z.string().optional(),
                next_activity_id: z.number().int().nullable().optional(),
                last_activity_id: z.number().int().nullable().optional(),
                last_activity_date: z.string().nullable().optional(),
                lost_reason: z.string().nullable().optional(),
                visible_to: z.string().optional(),
                close_time: z.string().nullable().optional(),
                pipeline_id: z.number().int().optional(),
                won_time: z.string().optional(),
                first_won_time: z.string().optional(),
                lost_time: z.string().optional(),
                products_count: z.number().int().optional(),
                files_count: z.number().int().optional(),
                notes_count: z.number().int().optional(),
                followers_count: z.number().int().optional(),
                email_messages_count: z.number().int().optional(),
                activities_count: z.number().int().optional(),
                done_activities_count: z.number().int().optional(),
                undone_activities_count: z.number().int().optional(),
                participants_count: z.number().int().optional(),
                expected_close_date: z.string().optional(),
                last_incoming_mail_time: z.string().optional(),
                last_outgoing_mail_time: z.string().optional(),
                label: z.string().optional(),
                stage_order_nr: z.number().int().optional(),
                person_name: z.string().optional(),
                org_name: z.string().optional(),
                next_activity_subject: z.string().optional(),
                next_activity_type: z.string().optional(),
                next_activity_duration: z.string().optional(),
                next_activity_note: z.string().optional(),
                formatted_value: z.string().optional(),
                weighted_value: z.number().optional(),
                formatted_weighted_value: z.string().optional(),
                weighted_value_currency: z.string().optional(),
                rotten_time: z.string().nullable().optional(),
                owner_name: z.string().optional(),
                cc_email: z.string().optional(),
                org_hidden: z.boolean().optional(),
                person_hidden: z.boolean().optional(),
              }))).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }))).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  addDeal: {
    /**
     * Add a deal 
     * @description Adds a new deal. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the dealFields and look for `key` values. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/creating-a-deal" target="_blank" rel="noopener noreferrer">adding a deal</a>.
     */
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          title: z.string(),
        }), z.object({
          value: z.string().nullish(),
          label: z.array(z.number().int()).nullish(),
          currency: z.string().nullish(),
          user_id: z.number().int().nullish(),
          person_id: z.number().int().nullish(),
          org_id: z.number().int().nullish(),
          pipeline_id: z.number().int().nullish(),
          stage_id: z.number().int().nullish(),
          status: z.enum(["open", "won", "lost", "deleted"]).nullish(),
          add_time: z.string().nullish(),
        }), z.object({
          expected_close_date: z.string().nullish(),
          probability: z.number().nullish(),
          lost_reason: z.string().nullish(),
          visible_to: z.string().nullish(),
        })),
      },
    },
    responses: {
      /** @description Add a deal */
      201: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              creator_user_id: z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.string().optional(),
                has_pic: z.boolean().optional(),
                pic_hash: z.string().nullable().optional(),
                active_flag: z.boolean().optional(),
                value: z.number().int().optional(),
              }).optional(),
              user_id: z.intersection(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.string().optional(),
                has_pic: z.boolean().optional(),
                pic_hash: z.string().nullable().optional(),
                active_flag: z.boolean().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              person_id: z.intersection(z.object({
                active_flag: z.boolean().optional(),
                name: z.string().optional(),
                email: z.array(z.object({
                    label: z.string().optional(),
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                  })).optional(),
                phone: z.array(z.object({
                    label: z.string().optional(),
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                  })).optional(),
                owner_id: z.number().int().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              org_id: z.intersection(z.object({
                name: z.string().optional(),
                people_count: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                address: z.string().optional(),
                active_flag: z.boolean().optional(),
                cc_email: z.string().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
            }), z.object({
              stage_id: z.number().int().optional(),
              title: z.string().optional(),
              value: z.number().optional(),
              currency: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              stage_change_time: z.string().optional(),
              active: z.boolean().optional(),
              deleted: z.boolean().optional(),
              status: z.string().optional(),
              probability: z.number().nullable().optional(),
              next_activity_date: z.string().optional(),
              next_activity_time: z.string().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              last_activity_id: z.number().int().nullable().optional(),
              last_activity_date: z.string().nullable().optional(),
              lost_reason: z.string().nullable().optional(),
              visible_to: z.string().optional(),
              close_time: z.string().nullable().optional(),
              pipeline_id: z.number().int().optional(),
              won_time: z.string().optional(),
              first_won_time: z.string().optional(),
              lost_time: z.string().optional(),
              products_count: z.number().int().optional(),
              files_count: z.number().int().optional(),
              notes_count: z.number().int().optional(),
              followers_count: z.number().int().optional(),
              email_messages_count: z.number().int().optional(),
              activities_count: z.number().int().optional(),
              done_activities_count: z.number().int().optional(),
              undone_activities_count: z.number().int().optional(),
              participants_count: z.number().int().optional(),
              expected_close_date: z.string().optional(),
              last_incoming_mail_time: z.string().optional(),
              last_outgoing_mail_time: z.string().optional(),
              label: z.string().optional(),
              stage_order_nr: z.number().int().optional(),
              person_name: z.string().optional(),
              org_name: z.string().optional(),
              next_activity_subject: z.string().optional(),
              next_activity_type: z.string().optional(),
              next_activity_duration: z.string().optional(),
              next_activity_note: z.string().optional(),
              formatted_value: z.string().optional(),
              weighted_value: z.number().optional(),
              formatted_weighted_value: z.string().optional(),
              weighted_value_currency: z.string().optional(),
              rotten_time: z.string().nullable().optional(),
              owner_name: z.string().optional(),
              cc_email: z.string().optional(),
              org_hidden: z.boolean().optional(),
              person_hidden: z.boolean().optional(),
            })).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }))).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteDeals: {
    /**
     * Delete multiple deals in bulk 
     * @description Marks multiple deals as deleted. After 30 days, the deals will be permanently deleted.
     */
    parameters: {
        /** @description The comma-separated IDs that will be deleted */
      query: z.object({
        ids: z.string(),
      }),
    },
    responses: {
      /** @description Delete multiple deals in bulk */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.array(z.number().int()).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getDealsCollection: {
    /**
     * Get all deals (BETA) 
     * @description Returns all deals. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href="https://support.pipedrive.com/en/article/global-user-management" target="_blank" rel="noopener noreferrer">here</a>.
     */
    parameters: {
        /** @description For pagination, the marker (an opaque string value) representing the first item on the next page */
        /** @description For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed. */
        /** @description The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field. */
        /** @description The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field. */
        /** @description If supplied, only deals matching the given user will be returned */
        /** @description If supplied, only deals within the given stage will be returned */
        /** @description Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. */
      query: z.object({
        cursor: z.string().optional(),
        limit: z.number().int().optional(),
        since: z.string().optional(),
        until: z.string().optional(),
        user_id: z.number().int().optional(),
        stage_id: z.number().int().optional(),
        status: z.enum(["open", "won", "lost", "deleted"]).optional(),
      }).optional(),
    },
    responses: {
      /** @description Get all deals */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                id: z.number().int().optional(),
                creator_user_id: z.number().int().optional(),
                user_id: z.number().int().optional(),
                person_id: z.number().int().optional(),
                org_id: z.number().int().optional(),
                stage_id: z.number().int().optional(),
                title: z.string().optional(),
                value: z.number().optional(),
                currency: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                status: z.string().optional(),
                probability: z.number().nullable().optional(),
                lost_reason: z.string().nullable().optional(),
                visible_to: z.string().optional(),
                close_time: z.string().nullable().optional(),
                pipeline_id: z.number().int().optional(),
                won_time: z.string().optional(),
                lost_time: z.string().optional(),
                expected_close_date: z.string().optional(),
                label: z.string().optional(),
              })).optional(),
            additional_data: z.object({
              next_cursor: z.string().optional(),
            }).optional(),
          }),
        },
      },
      /** @description Forbidden response */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  searchDeals: {
    /**
     * Search deals 
     * @description Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href="https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
     */
    parameters: {
        /** @description The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded. */
        /** @description A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: `address`, `varchar`, `text`, `varchar_auto`, `double`, `monetary` and `phone`. Read more about searching by custom fields <a href="https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields" target="_blank" rel="noopener noreferrer">here</a>. */
        /** @description When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive. */
        /** @description Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000. */
        /** @description Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000. */
        /** @description Will filter deals by the provided specific status. open = Open, won = Won, lost = Lost. The upper limit of found deals associated with the status is 2000. */
        /** @description Supports including optional fields in the results which are not provided by default */
        /** @description Pagination start. Note that the pagination is based on main results and does not include related items when using `search_for_related_items` parameter. */
        /** @description Items shown per page */
      query: z.object({
        term: z.string(),
        fields: z.enum(["custom_fields", "notes", "title"]).optional(),
        exact_match: z.boolean().optional(),
        person_id: z.number().int().optional(),
        organization_id: z.number().int().optional(),
        status: z.enum(["open", "won", "lost"]).optional(),
        include_fields: z.literal("deal.cc_email").optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              items: z.array(z.object({
                  result_score: z.number().optional(),
                  item: z.object({
                    id: z.number().int().optional(),
                    type: z.string().optional(),
                    title: z.string().optional(),
                    value: z.number().int().optional(),
                    currency: z.string().optional(),
                    status: z.string().optional(),
                    visible_to: z.number().int().optional(),
                    owner: z.object({
                      id: z.number().int().optional(),
                    }).optional(),
                    stage: z.object({
                      id: z.number().int().optional(),
                      name: z.string().optional(),
                    }).optional(),
                    person: z.object({
                      id: z.number().int().optional(),
                      name: z.string().optional(),
                    }).nullable().optional(),
                    organization: z.object({
                      id: z.number().int().optional(),
                      name: z.string().optional(),
                    }).nullable().optional(),
                    custom_fields: z.array(z.string()).optional(),
                    notes: z.array(z.string()).optional(),
                  }).optional(),
                })).optional(),
            }).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
                next_start: z.number().int().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getDealsSummary: {
    /**
     * Get deals summary 
     * @description Returns a summary of all the deals.
     */
    parameters: {
        /** @description Only fetch deals with a specific status. open = Open, won = Won, lost = Lost. */
        /** @description <code>user_id</code> will not be considered. Only deals matching the given filter will be returned. */
        /** @description Only deals matching the given user will be returned. `user_id` will not be considered if you use `filter_id`. */
        /** @description Only deals within the given stage will be returned */
      query: z.object({
        status: z.enum(["open", "won", "lost"]).optional(),
        filter_id: z.number().int().optional(),
        user_id: z.number().int().optional(),
        stage_id: z.number().int().optional(),
      }).optional(),
    },
    responses: {
      /** @description Get the summary of the deals */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              values_total: z.object({
                value: z.number().optional(),
                count: z.number().int().optional(),
                value_converted: z.number().optional(),
                value_formatted: z.string().optional(),
                value_converted_formatted: z.string().optional(),
              }).optional(),
              weighted_values_total: z.object({
                value: z.number().optional(),
                count: z.number().int().optional(),
                value_formatted: z.string().optional(),
              }).optional(),
              total_count: z.number().int().optional(),
              total_currency_converted_value: z.number().optional(),
              total_weighted_currency_converted_value: z.number().optional(),
              total_currency_converted_value_formatted: z.string().optional(),
              total_weighted_currency_converted_value_formatted: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getDealsTimeline: {
    /**
     * Get deals timeline 
     * @description Returns open and won deals, grouped by a defined interval of time set in a date-type dealField (`field_key`)  e.g. when month is the chosen interval, and 3 months are asked starting from January 1st, 2012, deals are returned grouped into 3 groups  January, February and March  based on the value of the given `field_key`.
     */
    parameters: {
        /** @description The date when the first interval starts. Format: YYYY-MM-DD. */
        /** @description The type of the interval<table><tr><th>Value</th><th>Description</th></tr><tr><td>`day`</td><td>Day</td></tr><tr><td>`week`</td><td>A full week (7 days) starting from `start_date`</td></tr><tr><td>`month`</td><td>A full month (depending on the number of days in given month) starting from `start_date`</td></tr><tr><td>`quarter`</td><td>A full quarter (3 months) starting from `start_date`</td></tr></table> */
        /** @description The number of given intervals, starting from `start_date`, to fetch. E.g. 3 (months). */
        /** @description The date field key which deals will be retrieved from */
        /** @description If supplied, only deals matching the given user will be returned */
        /** @description If supplied, only deals matching the given pipeline will be returned */
        /** @description If supplied, only deals matching the given filter will be returned */
        /** @description Whether to exclude deals list (1) or not (0). Note that when deals are excluded, the timeline summary (counts and values) is still returned. */
        /** @description The 3-letter currency code of any of the supported currencies. When supplied, `totals_converted` is returned per each interval which contains the currency-converted total amounts in the given currency. You may also set this parameter to `default_currency` in which case the user's default currency is used. */
      query: z.object({
        start_date: z.string(),
        interval: z.enum(["day", "week", "month", "quarter"]),
        amount: z.number().int(),
        field_key: z.string(),
        user_id: z.number().int().optional(),
        pipeline_id: z.number().int().optional(),
        filter_id: z.number().int().optional(),
        exclude_deals: z.number().optional(),
        totals_convert_currency: z.string().optional(),
      }),
    },
    responses: {
      /** @description Get open and won deals, grouped by the defined interval of time */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              period_start: z.string().optional(),
              period_end: z.string().optional(),
              deals: z.array(z.intersection(z.object({
                  id: z.number().int().optional(),
                  creator_user_id: z.number().int().optional(),
                  user_id: z.number().int().optional(),
                  person_id: z.number().int().optional(),
                  org_id: z.number().int().optional(),
                }), z.object({
                  stage_id: z.number().int().optional(),
                  title: z.string().optional(),
                  value: z.number().optional(),
                  currency: z.string().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  stage_change_time: z.string().optional(),
                  active: z.boolean().optional(),
                  deleted: z.boolean().optional(),
                  status: z.string().optional(),
                  probability: z.number().nullable().optional(),
                  next_activity_date: z.string().optional(),
                  next_activity_time: z.string().optional(),
                  next_activity_id: z.number().int().nullable().optional(),
                  last_activity_id: z.number().int().nullable().optional(),
                  last_activity_date: z.string().nullable().optional(),
                  lost_reason: z.string().nullable().optional(),
                  visible_to: z.string().optional(),
                  close_time: z.string().nullable().optional(),
                  pipeline_id: z.number().int().optional(),
                  won_time: z.string().optional(),
                  first_won_time: z.string().optional(),
                  lost_time: z.string().optional(),
                  products_count: z.number().int().optional(),
                  files_count: z.number().int().optional(),
                  notes_count: z.number().int().optional(),
                  followers_count: z.number().int().optional(),
                  email_messages_count: z.number().int().optional(),
                  activities_count: z.number().int().optional(),
                  done_activities_count: z.number().int().optional(),
                  undone_activities_count: z.number().int().optional(),
                  participants_count: z.number().int().optional(),
                  expected_close_date: z.string().optional(),
                  last_incoming_mail_time: z.string().optional(),
                  last_outgoing_mail_time: z.string().optional(),
                  label: z.string().optional(),
                  stage_order_nr: z.number().int().optional(),
                  person_name: z.string().optional(),
                  org_name: z.string().optional(),
                  next_activity_subject: z.string().optional(),
                  next_activity_type: z.string().optional(),
                  next_activity_duration: z.string().optional(),
                  next_activity_note: z.string().optional(),
                  formatted_value: z.string().optional(),
                  weighted_value: z.number().optional(),
                  formatted_weighted_value: z.string().optional(),
                  weighted_value_currency: z.string().optional(),
                  rotten_time: z.string().nullable().optional(),
                  owner_name: z.string().optional(),
                  cc_email: z.string().optional(),
                  org_hidden: z.boolean().optional(),
                  person_hidden: z.boolean().optional(),
                }))).optional(),
              totals: z.object({
                count: z.number().int().optional(),
                values: z.record(z.any()).optional(),
                weighted_values: z.record(z.any()).optional(),
                open_count: z.number().int().optional(),
                open_values: z.record(z.any()).optional(),
                weighted_open_values: z.record(z.any()).optional(),
                won_count: z.number().int().optional(),
                won_values: z.record(z.any()).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getDeal: {
    /**
     * Get details of a deal 
     * @description Returns the details of a specific deal. Note that this also returns some additional fields which are not present when asking for all deals  such as deal age and stay in pipeline stages. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of dealFields. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/getting-details-of-a-deal" target="_blank" rel="noopener noreferrer">getting details of a deal</a>.
     */
    parameters: {
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get a deal by its ID */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.intersection(z.object({
              id: z.number().int().optional(),
              creator_user_id: z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.string().optional(),
                has_pic: z.boolean().optional(),
                pic_hash: z.string().nullable().optional(),
                active_flag: z.boolean().optional(),
                value: z.number().int().optional(),
              }).optional(),
              user_id: z.intersection(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.string().optional(),
                has_pic: z.boolean().optional(),
                pic_hash: z.string().nullable().optional(),
                active_flag: z.boolean().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              person_id: z.intersection(z.object({
                active_flag: z.boolean().optional(),
                name: z.string().optional(),
                email: z.array(z.object({
                    label: z.string().optional(),
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                  })).optional(),
                phone: z.array(z.object({
                    label: z.string().optional(),
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                  })).optional(),
                owner_id: z.number().int().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              org_id: z.intersection(z.object({
                name: z.string().optional(),
                people_count: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                address: z.string().optional(),
                active_flag: z.boolean().optional(),
                cc_email: z.string().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
            }), z.object({
              stage_id: z.number().int().optional(),
              title: z.string().optional(),
              value: z.number().optional(),
              currency: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              stage_change_time: z.string().optional(),
              active: z.boolean().optional(),
              deleted: z.boolean().optional(),
              status: z.string().optional(),
              probability: z.number().nullable().optional(),
              next_activity_date: z.string().optional(),
              next_activity_time: z.string().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              last_activity_id: z.number().int().nullable().optional(),
              last_activity_date: z.string().nullable().optional(),
              lost_reason: z.string().nullable().optional(),
              visible_to: z.string().optional(),
              close_time: z.string().nullable().optional(),
              pipeline_id: z.number().int().optional(),
              won_time: z.string().optional(),
              first_won_time: z.string().optional(),
              lost_time: z.string().optional(),
              products_count: z.number().int().optional(),
              files_count: z.number().int().optional(),
              notes_count: z.number().int().optional(),
              followers_count: z.number().int().optional(),
              email_messages_count: z.number().int().optional(),
              activities_count: z.number().int().optional(),
              done_activities_count: z.number().int().optional(),
              undone_activities_count: z.number().int().optional(),
              participants_count: z.number().int().optional(),
              expected_close_date: z.string().optional(),
              last_incoming_mail_time: z.string().optional(),
              last_outgoing_mail_time: z.string().optional(),
              label: z.string().optional(),
              stage_order_nr: z.number().int().optional(),
              person_name: z.string().optional(),
              org_name: z.string().optional(),
              next_activity_subject: z.string().optional(),
              next_activity_type: z.string().optional(),
              next_activity_duration: z.string().optional(),
              next_activity_note: z.string().optional(),
              formatted_value: z.string().optional(),
              weighted_value: z.number().optional(),
              formatted_weighted_value: z.string().optional(),
              weighted_value_currency: z.string().optional(),
              rotten_time: z.string().nullable().optional(),
              owner_name: z.string().optional(),
              cc_email: z.string().optional(),
              org_hidden: z.boolean().optional(),
              person_hidden: z.boolean().optional(),
            })), z.object({
              average_time_to_won: z.object({
                y: z.number().int().optional(),
                m: z.number().int().optional(),
                d: z.number().int().optional(),
                h: z.number().int().optional(),
                i: z.number().int().optional(),
                s: z.number().int().optional(),
                total_seconds: z.number().int().optional(),
              }).optional(),
              average_stage_progress: z.number().optional(),
              age: z.object({
                y: z.number().int().optional(),
                m: z.number().int().optional(),
                d: z.number().int().optional(),
                h: z.number().int().optional(),
                i: z.number().int().optional(),
                s: z.number().int().optional(),
                total_seconds: z.number().int().optional(),
              }).optional(),
              stay_in_pipeline_stages: z.object({
                times_in_stages: z.record(z.any()).optional(),
                order_of_stages: z.array(z.number().int()).optional(),
              }).optional(),
              last_activity: z.record(z.unknown()).nullable().optional(),
              next_activity: z.record(z.unknown()).nullable().optional(),
            })).optional(),
            additional_data: z.object({
              dropbox_email: z.string().optional(),
            }).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }))).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  updateDeal: {
    /**
     * Update a deal 
     * @description Updates the properties of a deal. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/updating-a-deal" target="_blank" rel="noopener noreferrer">updating a deal</a>.
     */
    parameters: {
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          title: z.string().nullish(),
        }), z.object({
          value: z.string().nullish(),
          label: z.array(z.number().int()).nullish(),
          currency: z.string().nullish(),
          user_id: z.number().int().nullish(),
          person_id: z.number().int().nullish(),
          org_id: z.number().int().nullish(),
          pipeline_id: z.number().int().nullish(),
          stage_id: z.number().int().nullish(),
          status: z.enum(["open", "won", "lost", "deleted"]).nullish(),
        }), z.object({
          expected_close_date: z.string().nullish(),
          probability: z.number().nullish(),
          lost_reason: z.string().nullish(),
          visible_to: z.string().nullish(),
        })),
      },
    },
    responses: {
      /** @description Add a deal */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              creator_user_id: z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.string().optional(),
                has_pic: z.boolean().optional(),
                pic_hash: z.string().nullable().optional(),
                active_flag: z.boolean().optional(),
                value: z.number().int().optional(),
              }).optional(),
              user_id: z.intersection(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.string().optional(),
                has_pic: z.boolean().optional(),
                pic_hash: z.string().nullable().optional(),
                active_flag: z.boolean().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              person_id: z.intersection(z.object({
                active_flag: z.boolean().optional(),
                name: z.string().optional(),
                email: z.array(z.object({
                    label: z.string().optional(),
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                  })).optional(),
                phone: z.array(z.object({
                    label: z.string().optional(),
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                  })).optional(),
                owner_id: z.number().int().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              org_id: z.intersection(z.object({
                name: z.string().optional(),
                people_count: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                address: z.string().optional(),
                active_flag: z.boolean().optional(),
                cc_email: z.string().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
            }), z.object({
              stage_id: z.number().int().optional(),
              title: z.string().optional(),
              value: z.number().optional(),
              currency: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              stage_change_time: z.string().optional(),
              active: z.boolean().optional(),
              deleted: z.boolean().optional(),
              status: z.string().optional(),
              probability: z.number().nullable().optional(),
              next_activity_date: z.string().optional(),
              next_activity_time: z.string().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              last_activity_id: z.number().int().nullable().optional(),
              last_activity_date: z.string().nullable().optional(),
              lost_reason: z.string().nullable().optional(),
              visible_to: z.string().optional(),
              close_time: z.string().nullable().optional(),
              pipeline_id: z.number().int().optional(),
              won_time: z.string().optional(),
              first_won_time: z.string().optional(),
              lost_time: z.string().optional(),
              products_count: z.number().int().optional(),
              files_count: z.number().int().optional(),
              notes_count: z.number().int().optional(),
              followers_count: z.number().int().optional(),
              email_messages_count: z.number().int().optional(),
              activities_count: z.number().int().optional(),
              done_activities_count: z.number().int().optional(),
              undone_activities_count: z.number().int().optional(),
              participants_count: z.number().int().optional(),
              expected_close_date: z.string().optional(),
              last_incoming_mail_time: z.string().optional(),
              last_outgoing_mail_time: z.string().optional(),
              label: z.string().optional(),
              stage_order_nr: z.number().int().optional(),
              person_name: z.string().optional(),
              org_name: z.string().optional(),
              next_activity_subject: z.string().optional(),
              next_activity_type: z.string().optional(),
              next_activity_duration: z.string().optional(),
              next_activity_note: z.string().optional(),
              formatted_value: z.string().optional(),
              weighted_value: z.number().optional(),
              formatted_weighted_value: z.string().optional(),
              weighted_value_currency: z.string().optional(),
              rotten_time: z.string().nullable().optional(),
              owner_name: z.string().optional(),
              cc_email: z.string().optional(),
              org_hidden: z.boolean().optional(),
              person_hidden: z.boolean().optional(),
            })).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }))).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteDeal: {
    /**
     * Delete a deal 
     * @description Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
     */
    parameters: {
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Delete a deal */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getDealActivities: {
    /**
     * List activities associated with a deal 
     * @description Lists activities associated with a deal.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description Whether the activity is done or not. 0 = Not done, 1 = Done. If omitted, returns both Done and Not done activities. */
        /** @description A comma-separated string of activity IDs to exclude from result */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        done: z.number().optional(),
        exclude: z.string().optional(),
      }).optional(),
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                due_date: z.string().optional(),
                due_time: z.string().optional(),
                duration: z.string().optional(),
                deal_id: z.number().int().optional(),
                lead_id: z.string().nullable().optional(),
                person_id: z.number().int().optional(),
                project_id: z.number().int().nullable().optional(),
                org_id: z.number().int().optional(),
                location: z.string().optional(),
                public_description: z.string().optional(),
              }), z.object({
                id: z.number().int().optional(),
                note: z.string().optional(),
                done: z.boolean().optional(),
                subject: z.string().optional(),
                type: z.string().optional(),
                user_id: z.number().int().optional(),
                participants: z.array(z.record(z.any())).nullable().optional(),
                busy_flag: z.boolean().optional(),
                attendees: z.array(z.record(z.any())).nullable().optional(),
                company_id: z.number().int().optional(),
                reference_type: z.string().optional(),
                reference_id: z.number().int().optional(),
                conference_meeting_client: z.string().optional(),
                conference_meeting_url: z.string().optional(),
                conference_meeting_id: z.string().optional(),
                add_time: z.string().optional(),
                marked_as_done_time: z.string().optional(),
                last_notification_time: z.string().optional(),
                last_notification_user_id: z.number().int().optional(),
                notification_language_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                update_time: z.string().optional(),
                update_user_id: z.number().int().optional(),
                gcal_event_id: z.string().optional(),
                google_calendar_id: z.string().optional(),
                google_calendar_etag: z.string().optional(),
                calendar_sync_include_context: z.string().optional(),
                source_timezone: z.string().optional(),
                rec_rule: z.string().optional(),
                rec_rule_extension: z.string().optional(),
                rec_master_activity_id: z.number().int().optional(),
                series: z.array(z.record(z.any())).optional(),
                created_by_user_id: z.number().int().optional(),
                location_subpremise: z.string().optional(),
                location_street_number: z.string().optional(),
                location_route: z.string().optional(),
                location_sublocality: z.string().optional(),
                location_locality: z.string().optional(),
                location_admin_area_level_1: z.string().optional(),
                location_admin_area_level_2: z.string().optional(),
                location_country: z.string().optional(),
                location_postal_code: z.string().optional(),
                location_formatted_address: z.string().optional(),
                org_name: z.string().optional(),
                person_name: z.string().optional(),
                deal_title: z.string().optional(),
                owner_name: z.string().optional(),
                person_dropbox_bcc: z.string().optional(),
                deal_dropbox_bcc: z.string().optional(),
                assigned_to_user_id: z.number().int().optional(),
                file: z.record(z.any()).optional(),
              }))).optional(),
            additional_data: z.intersection(z.object({
              activity_distribution: z.object({
                ASSIGNED_TO_USER_ID: z.object({
                  activities: z.object({
                    ACTIVITY_TYPE_NAME: z.number().int().optional(),
                  }).optional(),
                  name: z.string().optional(),
                  activity_count: z.number().int().optional(),
                  share: z.number().int().optional(),
                }).optional(),
              }).optional(),
            }), z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            })).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }))).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
              deal: z.object({
                DEAL_ID: z.object({
                  id: z.number().int().optional(),
                  title: z.string().optional(),
                  status: z.string().optional(),
                  value: z.number().optional(),
                  currency: z.string().optional(),
                  stage_id: z.number().int().optional(),
                  pipeline_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  duplicateDeal: {
    /**
     * Duplicate deal 
     * @description Duplicates a deal.
     */
    parameters: {
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Duplicate a deal */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              creator_user_id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              person_id: z.number().int().optional(),
              org_id: z.number().int().optional(),
            }), z.object({
              stage_id: z.number().int().optional(),
              title: z.string().optional(),
              value: z.number().optional(),
              currency: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              stage_change_time: z.string().optional(),
              active: z.boolean().optional(),
              deleted: z.boolean().optional(),
              status: z.string().optional(),
              probability: z.number().nullable().optional(),
              next_activity_date: z.string().optional(),
              next_activity_time: z.string().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              last_activity_id: z.number().int().nullable().optional(),
              last_activity_date: z.string().nullable().optional(),
              lost_reason: z.string().nullable().optional(),
              visible_to: z.string().optional(),
              close_time: z.string().nullable().optional(),
              pipeline_id: z.number().int().optional(),
              won_time: z.string().optional(),
              first_won_time: z.string().optional(),
              lost_time: z.string().optional(),
              products_count: z.number().int().optional(),
              files_count: z.number().int().optional(),
              notes_count: z.number().int().optional(),
              followers_count: z.number().int().optional(),
              email_messages_count: z.number().int().optional(),
              activities_count: z.number().int().optional(),
              done_activities_count: z.number().int().optional(),
              undone_activities_count: z.number().int().optional(),
              participants_count: z.number().int().optional(),
              expected_close_date: z.string().optional(),
              last_incoming_mail_time: z.string().optional(),
              last_outgoing_mail_time: z.string().optional(),
              label: z.string().optional(),
              stage_order_nr: z.number().int().optional(),
              person_name: z.string().optional(),
              org_name: z.string().optional(),
              next_activity_subject: z.string().optional(),
              next_activity_type: z.string().optional(),
              next_activity_duration: z.string().optional(),
              next_activity_note: z.string().optional(),
              formatted_value: z.string().optional(),
              weighted_value: z.number().optional(),
              formatted_weighted_value: z.string().optional(),
              weighted_value_currency: z.string().optional(),
              rotten_time: z.string().nullable().optional(),
              owner_name: z.string().optional(),
              cc_email: z.string().optional(),
              org_hidden: z.boolean().optional(),
              person_hidden: z.boolean().optional(),
            })).optional(),
          }),
        },
      },
    },
  },
  getDealFiles: {
    /**
     * List files attached to a deal 
     * @description Lists files associated with a deal.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys). Supported fields: `id`, `user_id`, `deal_id`, `person_id`, `org_id`, `product_id`, `add_time`, `update_time`, `file_name`, `file_type`, `file_size`, `comment`. */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        sort: z.string().optional(),
      }).optional(),
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                user_id: z.number().int().optional(),
                deal_id: z.number().int().optional(),
                person_id: z.number().int().optional(),
                org_id: z.number().int().optional(),
                product_id: z.number().int().optional(),
                activity_id: z.number().int().optional(),
                lead_id: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                file_name: z.string().optional(),
                file_size: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                inline_flag: z.boolean().optional(),
                remote_location: z.string().optional(),
                remote_id: z.string().optional(),
                cid: z.string().optional(),
                s3_bucket: z.string().optional(),
                mail_message_id: z.string().optional(),
                mail_template_id: z.string().optional(),
                deal_name: z.string().optional(),
                person_name: z.string().optional(),
                org_name: z.string().optional(),
                product_name: z.string().optional(),
                lead_name: z.string().optional(),
                url: z.string().optional(),
                name: z.string().optional(),
                description: z.string().optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getDealUpdates: {
    /**
     * List updates about a deal 
     * @description Lists updates about a deal.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description Whether to show custom field updates or not. 1 = Include custom field changes. If omitted returns changes without custom field updates. */
        /** @description A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change). */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        all_changes: z.string().optional(),
        items: z.string().optional(),
      }).optional(),
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get the deal updates */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                object: z.string().optional(),
                timestamp: z.string().optional(),
                data: z.record(z.any()).optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
            related_objects: z.object({
              deal: z.object({
                DEAL_ID: z.object({
                  id: z.number().int().optional(),
                  title: z.string().optional(),
                  status: z.string().optional(),
                  value: z.number().optional(),
                  currency: z.string().optional(),
                  stage_id: z.number().int().optional(),
                  pipeline_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getDealFollowers: {
    /**
     * List followers of a deal 
     * @description Lists the followers of a deal.
     */
    parameters: {
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                user_id: z.number().int().optional(),
                id: z.number().int().optional(),
                deal_id: z.number().int().optional(),
                add_time: z.string().optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addDealFollower: {
    /**
     * Add a follower to a deal 
     * @description Adds a follower to a deal.
     */
    parameters: {
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          user_id: z.number().int(),
        }),
      },
    },
    responses: {
      /** @description Add a follower to a deal */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              user_id: z.number().int().optional(),
              id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              add_time: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteDealFollower: {
    /**
     * Delete a follower from a deal 
     * @description Deletes a follower from a deal.
     */
    parameters: {
        /** @description The ID of the deal */
        /** @description The ID of the follower */
      path: z.object({
        id: z.number().int(),
        follower_id: z.number().int(),
      }),
    },
    responses: {
      /** @description Delete a follower from a deal */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getDealMailMessages: {
    /**
     * List mail messages associated with a deal 
     * @description Lists mail messages associated with a deal.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                object: z.string().optional(),
                timestamp: z.string().optional(),
                data: z.intersection(z.object({
                  id: z.number().int().optional(),
                  from: z.array(z.object({
                      id: z.number().int().optional(),
                      email_address: z.string().optional(),
                      name: z.string().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                    })).optional(),
                  to: z.array(z.object({
                      id: z.number().int().optional(),
                      email_address: z.string().optional(),
                      name: z.string().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                    })).optional(),
                  cc: z.array(z.object({
                      id: z.number().int().optional(),
                      email_address: z.string().optional(),
                      name: z.string().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                    })).optional(),
                  bcc: z.array(z.object({
                      id: z.number().int().optional(),
                      email_address: z.string().optional(),
                      name: z.string().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                    })).optional(),
                  body_url: z.string().optional(),
                  account_id: z.string().optional(),
                  user_id: z.number().int().optional(),
                  mail_thread_id: z.number().int().optional(),
                  subject: z.string().optional(),
                  snippet: z.string().optional(),
                  mail_tracking_status: z.enum(["opened", "not opened"]).nullable().optional(),
                  mail_link_tracking_enabled_flag: z.number().optional(),
                  read_flag: z.number().optional(),
                  draft: z.string().optional(),
                  draft_flag: z.number().optional(),
                  synced_flag: z.number().optional(),
                  deleted_flag: z.number().optional(),
                  has_body_flag: z.number().optional(),
                  sent_flag: z.number().optional(),
                  sent_from_pipedrive_flag: z.number().optional(),
                  smart_bcc_flag: z.number().optional(),
                  message_time: z.string().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  has_attachments_flag: z.number().optional(),
                  has_inline_attachments_flag: z.number().optional(),
                  has_real_attachments_flag: z.number().optional(),
                }), z.object({
                  nylas_id: z.string().optional(),
                  s3_bucket: z.string().optional(),
                  s3_bucket_path: z.string().optional(),
                  external_deleted_flag: z.boolean().optional(),
                  mua_message_id: z.string().optional(),
                  template_id: z.number().int().optional(),
                  timestamp: z.string().optional(),
                  item_type: z.string().optional(),
                  company_id: z.number().int().optional(),
                })).optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  mergeDeals: {
    /**
     * Merge two deals 
     * @description Merges a deal with another deal. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/merging-two-deals" target="_blank" rel="noopener noreferrer">merging two deals</a>.
     */
    parameters: {
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          merge_with_id: z.number().int(),
        }),
      },
    },
    responses: {
      /** @description Merges a deal with another deal */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.intersection(z.object({
              id: z.number().int().optional(),
              creator_user_id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              person_id: z.number().int().optional(),
              org_id: z.number().int().optional(),
            }), z.object({
              stage_id: z.number().int().optional(),
              title: z.string().optional(),
              value: z.number().optional(),
              currency: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              stage_change_time: z.string().optional(),
              active: z.boolean().optional(),
              deleted: z.boolean().optional(),
              status: z.string().optional(),
              probability: z.number().nullable().optional(),
              next_activity_date: z.string().optional(),
              next_activity_time: z.string().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              last_activity_id: z.number().int().nullable().optional(),
              last_activity_date: z.string().nullable().optional(),
              lost_reason: z.string().nullable().optional(),
              visible_to: z.string().optional(),
              close_time: z.string().nullable().optional(),
              pipeline_id: z.number().int().optional(),
              won_time: z.string().optional(),
              first_won_time: z.string().optional(),
              lost_time: z.string().optional(),
              products_count: z.number().int().optional(),
              files_count: z.number().int().optional(),
              notes_count: z.number().int().optional(),
              followers_count: z.number().int().optional(),
              email_messages_count: z.number().int().optional(),
              activities_count: z.number().int().optional(),
              done_activities_count: z.number().int().optional(),
              undone_activities_count: z.number().int().optional(),
              participants_count: z.number().int().optional(),
              expected_close_date: z.string().optional(),
              last_incoming_mail_time: z.string().optional(),
              last_outgoing_mail_time: z.string().optional(),
              label: z.string().optional(),
              stage_order_nr: z.number().int().optional(),
              person_name: z.string().optional(),
              org_name: z.string().optional(),
              next_activity_subject: z.string().optional(),
              next_activity_type: z.string().optional(),
              next_activity_duration: z.string().optional(),
              next_activity_note: z.string().optional(),
              formatted_value: z.string().optional(),
              weighted_value: z.number().optional(),
              formatted_weighted_value: z.string().optional(),
              weighted_value_currency: z.string().optional(),
              rotten_time: z.string().nullable().optional(),
              owner_name: z.string().optional(),
              cc_email: z.string().optional(),
              org_hidden: z.boolean().optional(),
              person_hidden: z.boolean().optional(),
            })), z.object({
              merge_what_id: z.number().int().optional(),
            })).optional(),
          }),
        },
      },
    },
  },
  getDealParticipants: {
    /**
     * List participants of a deal 
     * @description Lists the participants associated with a deal.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get all deal participants by the DealID */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                company_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                phone: z.array(z.object({
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                    label: z.string().optional(),
                  })).optional(),
                email: z.array(z.object({
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                    label: z.string().optional(),
                  })).optional(),
                first_char: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                visible_to: z.string().optional(),
                picture_id: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  item_type: z.string().optional(),
                  item_id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  added_by_user_id: z.number().int().optional(),
                  pictures: z.object({
                    128: z.string().optional(),
                    512: z.string().optional(),
                  }).optional(),
                })).optional(),
                label: z.number().int().optional(),
                org_name: z.string().optional(),
                owner_name: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.intersection(z.intersection(z.object({
                owner_id: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                org_id: z.intersection(z.intersection(z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })), z.object({
                  active_flag: z.boolean().optional(),
                })).optional(),
              }), z.object({
                name: z.string().optional(),
                first_name: z.string().optional(),
                last_name: z.string().optional(),
              })), z.intersection(z.intersection(z.object({
                email_messages_count: z.number().int().optional(),
                activities_count: z.number().int().optional(),
                done_activities_count: z.number().int().optional(),
                undone_activities_count: z.number().int().optional(),
                files_count: z.number().int().optional(),
                notes_count: z.number().int().optional(),
                followers_count: z.number().int().optional(),
              }), z.object({
                last_incoming_mail_time: z.string().optional(),
                last_outgoing_mail_time: z.string().optional(),
              })), z.intersection(z.object({
                open_deals_count: z.number().int().optional(),
                related_open_deals_count: z.number().int().optional(),
                closed_deals_count: z.number().int().optional(),
                related_closed_deals_count: z.number().int().optional(),
                won_deals_count: z.number().int().optional(),
                related_won_deals_count: z.number().int().optional(),
                lost_deals_count: z.number().int().optional(),
                related_lost_deals_count: z.number().int().optional(),
              }), z.object({
                next_activity_date: z.string().nullable().optional(),
                next_activity_time: z.string().nullable().optional(),
                next_activity_id: z.number().int().nullable().optional(),
                last_activity_id: z.number().int().nullable().optional(),
                last_activity_date: z.string().nullable().optional(),
              })))))).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }))).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  addDealParticipant: {
    /**
     * Add a participant to a deal 
     * @description Adds a participant to a deal.
     */
    parameters: {
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          person_id: z.number().int(),
        }),
      },
    },
    responses: {
      /** @description Add new participant to the deal */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              company_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              phone: z.array(z.object({
                  value: z.string().optional(),
                  primary: z.boolean().optional(),
                  label: z.string().optional(),
                })).optional(),
              email: z.array(z.object({
                  value: z.string().optional(),
                  primary: z.boolean().optional(),
                  label: z.string().optional(),
                })).optional(),
              first_char: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.string().optional(),
              picture_id: z.intersection(z.object({
                id: z.number().int().optional(),
              }), z.object({
                item_type: z.string().optional(),
                item_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                added_by_user_id: z.number().int().optional(),
                pictures: z.object({
                  128: z.string().optional(),
                  512: z.string().optional(),
                }).optional(),
              })).optional(),
              label: z.number().int().optional(),
              org_name: z.string().optional(),
              owner_name: z.string().optional(),
              cc_email: z.string().optional(),
            }), z.intersection(z.intersection(z.object({
              owner_id: z.intersection(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.string().optional(),
                has_pic: z.number().int().optional(),
                pic_hash: z.string().nullable().optional(),
                active_flag: z.boolean().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              org_id: z.intersection(z.intersection(z.object({
                name: z.string().optional(),
                people_count: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                address: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })), z.object({
                active_flag: z.boolean().optional(),
              })).optional(),
            }), z.object({
              name: z.string().optional(),
              first_name: z.string().optional(),
              last_name: z.string().optional(),
            })), z.intersection(z.intersection(z.object({
              email_messages_count: z.number().int().optional(),
              activities_count: z.number().int().optional(),
              done_activities_count: z.number().int().optional(),
              undone_activities_count: z.number().int().optional(),
              files_count: z.number().int().optional(),
              notes_count: z.number().int().optional(),
              followers_count: z.number().int().optional(),
            }), z.object({
              last_incoming_mail_time: z.string().optional(),
              last_outgoing_mail_time: z.string().optional(),
            })), z.intersection(z.object({
              open_deals_count: z.number().int().optional(),
              related_open_deals_count: z.number().int().optional(),
              closed_deals_count: z.number().int().optional(),
              related_closed_deals_count: z.number().int().optional(),
              won_deals_count: z.number().int().optional(),
              related_won_deals_count: z.number().int().optional(),
              lost_deals_count: z.number().int().optional(),
              related_lost_deals_count: z.number().int().optional(),
            }), z.object({
              next_activity_date: z.string().nullable().optional(),
              next_activity_time: z.string().nullable().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              last_activity_id: z.number().int().nullable().optional(),
              last_activity_date: z.string().nullable().optional(),
            }))))).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteDealParticipant: {
    /**
     * Delete a participant from a deal 
     * @description Deletes a participant from a deal.
     */
    parameters: {
        /** @description The ID of the deal */
        /** @description The ID of the participant of the deal */
      path: z.object({
        id: z.number().int(),
        deal_participant_id: z.number().int(),
      }),
    },
    responses: {
      /** @description Delete a participant from a deal */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getDealUsers: {
    /**
     * List permitted users 
     * @description Lists the users permitted to access a deal.
     */
    parameters: {
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.array(z.number().int()).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getDealPersons: {
    /**
     * List all persons associated with a deal 
     * @description Lists all persons associated with a deal, regardless of whether the person is the primary contact of the deal, or added as a participant.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                company_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                phone: z.array(z.object({
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                    label: z.string().optional(),
                  })).optional(),
                email: z.array(z.object({
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                    label: z.string().optional(),
                  })).optional(),
                first_char: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                visible_to: z.string().optional(),
                picture_id: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  item_type: z.string().optional(),
                  item_id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  added_by_user_id: z.number().int().optional(),
                  pictures: z.object({
                    128: z.string().optional(),
                    512: z.string().optional(),
                  }).optional(),
                })).optional(),
                label: z.number().int().optional(),
                org_name: z.string().optional(),
                owner_name: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.intersection(z.intersection(z.object({
                owner_id: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                org_id: z.intersection(z.intersection(z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })), z.object({
                  active_flag: z.boolean().optional(),
                })).optional(),
              }), z.object({
                name: z.string().optional(),
                first_name: z.string().optional(),
                last_name: z.string().optional(),
              })), z.intersection(z.intersection(z.object({
                email_messages_count: z.number().int().optional(),
                activities_count: z.number().int().optional(),
                done_activities_count: z.number().int().optional(),
                undone_activities_count: z.number().int().optional(),
                files_count: z.number().int().optional(),
                notes_count: z.number().int().optional(),
                followers_count: z.number().int().optional(),
              }), z.object({
                last_incoming_mail_time: z.string().optional(),
                last_outgoing_mail_time: z.string().optional(),
              })), z.intersection(z.object({
                open_deals_count: z.number().int().optional(),
                related_open_deals_count: z.number().int().optional(),
                closed_deals_count: z.number().int().optional(),
                related_closed_deals_count: z.number().int().optional(),
                won_deals_count: z.number().int().optional(),
                related_won_deals_count: z.number().int().optional(),
                lost_deals_count: z.number().int().optional(),
                related_lost_deals_count: z.number().int().optional(),
              }), z.object({
                next_activity_date: z.string().nullable().optional(),
                next_activity_time: z.string().nullable().optional(),
                next_activity_id: z.number().int().nullable().optional(),
                last_activity_id: z.number().int().nullable().optional(),
                last_activity_date: z.string().nullable().optional(),
              })))))).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }))).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getDealProducts: {
    /**
     * List products attached to a deal 
     * @description Lists products attached to a deal.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description Whether to fetch product data along with each attached product (1) or not (0, default) */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        include_product_data: z.number().optional(),
      }).optional(),
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                deal_id: z.number().int().optional(),
                order_nr: z.number().int().optional(),
                product_id: z.number().int().optional(),
                product_variation_id: z.number().int().nullable().optional(),
                item_price: z.number().int().optional(),
                discount: z.number().optional(),
                discount_type: z.enum(["percentage", "amount"]).optional(),
                duration: z.number().int().optional(),
                duration_unit: z.string().optional(),
                sum: z.number().optional(),
                currency: z.string().optional(),
                enabled_flag: z.boolean().optional(),
                add_time: z.string().optional(),
                last_edit: z.string().optional(),
                comments: z.string().optional(),
                active_flag: z.boolean().optional(),
                tax: z.number().optional(),
                tax_method: z.enum(["exclusive", "inclusive", "none"]).optional(),
                name: z.string().optional(),
                sum_formatted: z.string().optional(),
                quantity_formatted: z.string().optional(),
                quantity: z.number().int().optional(),
                product: z.intersection(z.object({
                  id: z.number().optional(),
                  name: z.string().optional(),
                  code: z.string().optional(),
                  unit: z.string().optional(),
                  tax: z.number().optional(),
                  active_flag: z.boolean().optional(),
                  selectable: z.boolean().optional(),
                  visible_to: z.enum(["1", "3", "5", "7"]).optional(),
                  owner_id: z.record(z.any()).optional(),
                }), z.object({
                  prices: z.record(z.any()).optional(),
                })).optional(),
              })).optional(),
            additional_data: z.intersection(z.object({
              products_quantity_total: z.number().int().optional(),
              products_sum_total: z.number().int().optional(),
              products_quantity_total_formatted: z.string().optional(),
              products_sum_total_formatted: z.string().optional(),
            }), z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
                next_start: z.number().int().optional(),
              }).optional(),
            })).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addDealProduct: {
    /**
     * Add a product to a deal 
     * @description Adds a product to a deal, creating a new item called a deal-product.
     */
    parameters: {
        /** @description The ID of the deal */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          product_id: z.number().int(),
          item_price: z.number(),
          quantity: z.number().int(),
          discount: z.number().nullish(),
          discount_type: z.enum(["percentage", "amount"]).nullish(),
          duration: z.number().nullish(),
          duration_unit: z.string().nullish(),
          product_variation_id: z.number().int().nullable().nullish(),
          comments: z.string().nullish(),
          tax: z.number().nullish(),
          tax_method: z.enum(["exclusive", "inclusive", "none"]).nullish(),
          enabled_flag: z.boolean().nullish(),
        }),
      },
    },
    responses: {
      /** @description Add a product to the deal */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.intersection(z.object({
              product_id: z.number().int(),
              item_price: z.number(),
              quantity: z.number().int(),
              discount: z.number().optional(),
              discount_type: z.enum(["percentage", "amount"]).optional(),
              duration: z.number().optional(),
              duration_unit: z.string().optional(),
              product_variation_id: z.number().int().nullable().optional(),
              comments: z.string().optional(),
              tax: z.number().optional(),
              tax_method: z.enum(["exclusive", "inclusive", "none"]).optional(),
              enabled_flag: z.boolean().optional(),
            }), z.object({
              id: z.number().int().optional(),
              company_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              product_id: z.number().int().optional(),
              duration_unit: z.string().optional(),
              sum: z.number().optional(),
              currency: z.string().optional(),
              add_time: z.string().optional(),
              last_edit: z.string().optional(),
              active_flag: z.boolean().optional(),
              tax: z.number().optional(),
              name: z.string().optional(),
            })), z.object({
              product_attachment_id: z.number().int().optional(),
            })).optional(),
          }),
        },
      },
    },
  },
  updateDealProduct: {
    /**
     * Update the product attached to a deal 
     * @description Updates the details of the product that has been attached to a deal.
     */
    parameters: {
        /** @description The ID of the deal */
        /** @description The ID of the deal-product (the ID of the product attached to the deal) */
      path: z.object({
        id: z.number().int(),
        product_attachment_id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          product_id: z.number().int().nullish(),
          item_price: z.number().nullish(),
          quantity: z.number().int().nullish(),
          discount: z.number().nullish(),
          discount_type: z.enum(["percentage", "amount"]).nullish(),
          duration: z.number().nullish(),
          duration_unit: z.string().nullish(),
          product_variation_id: z.number().int().nullish(),
          comments: z.string().nullish(),
          tax: z.number().nullish(),
          tax_method: z.enum(["exclusive", "inclusive", "none"]).nullish(),
          enabled_flag: z.boolean().nullish(),
        }),
      },
    },
    responses: {
      /** @description Update product attachment details */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              product_id: z.number().int(),
              item_price: z.number(),
              quantity: z.number().int(),
              discount: z.number().optional(),
              discount_type: z.enum(["percentage", "amount"]).optional(),
              duration: z.number().optional(),
              duration_unit: z.string().optional(),
              product_variation_id: z.number().int().nullable().optional(),
              comments: z.string().optional(),
              tax: z.number().optional(),
              tax_method: z.enum(["exclusive", "inclusive", "none"]).optional(),
              enabled_flag: z.boolean().optional(),
            }), z.object({
              id: z.number().int().optional(),
              company_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              product_id: z.number().int().optional(),
              duration_unit: z.string().optional(),
              sum: z.number().optional(),
              currency: z.string().optional(),
              add_time: z.string().optional(),
              last_edit: z.string().optional(),
              active_flag: z.boolean().optional(),
              tax: z.number().optional(),
              name: z.string().optional(),
            })).optional(),
          }),
        },
      },
    },
  },
  deleteDealProduct: {
    /**
     * Delete an attached product from a deal 
     * @description Deletes a product attachment from a deal, using the `product_attachment_id`.
     */
    parameters: {
        /** @description The ID of the deal */
        /** @description The product attachment ID */
      path: z.object({
        id: z.number().int(),
        product_attachment_id: z.number().int(),
      }),
    },
    responses: {
      /** @description Delete an attached product from a deal */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getDealFields: {
    /**
     * Get all deal fields 
     * @description Returns data about all deal fields.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                key: z.string().optional(),
                name: z.string().optional(),
                order_nr: z.number().int().optional(),
                field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                last_updated_by_user_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                edit_flag: z.boolean().optional(),
                index_visible_flag: z.boolean().optional(),
                details_visible_flag: z.boolean().optional(),
                add_visible_flag: z.boolean().optional(),
                important_flag: z.boolean().optional(),
                bulk_edit_allowed: z.boolean().optional(),
                searchable_flag: z.boolean().optional(),
                filtering_allowed: z.boolean().optional(),
                sortable_flag: z.boolean().optional(),
                mandatory_flag: z.boolean().optional(),
                options: z.array(z.record(z.any())).nullable().optional(),
                options_deleted: z.array(z.record(z.any())).optional(),
                is_subfield: z.boolean().optional(),
                subfields: z.array(z.record(z.any())).optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addDealField: {
    /**
     * Add a new deal field 
     * @description Adds a new deal field. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-new-custom-field" target="_blank" rel="noopener noreferrer">adding a new custom field</a>.
     */
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          name: z.string(),
          options: z.array(z.record(z.any())).nullish(),
          add_visible_flag: z.boolean().nullish(),
        }), z.object({
          field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]),
        })),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              key: z.string().optional(),
              name: z.string().optional(),
              order_nr: z.number().int().optional(),
              field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              last_updated_by_user_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              edit_flag: z.boolean().optional(),
              index_visible_flag: z.boolean().optional(),
              details_visible_flag: z.boolean().optional(),
              add_visible_flag: z.boolean().optional(),
              important_flag: z.boolean().optional(),
              bulk_edit_allowed: z.boolean().optional(),
              searchable_flag: z.boolean().optional(),
              filtering_allowed: z.boolean().optional(),
              sortable_flag: z.boolean().optional(),
              mandatory_flag: z.boolean().optional(),
              options: z.array(z.record(z.any())).nullable().optional(),
              options_deleted: z.array(z.record(z.any())).optional(),
              is_subfield: z.boolean().optional(),
              subfields: z.array(z.record(z.any())).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteDealFields: {
    /**
     * Delete multiple deal fields in bulk 
     * @description Marks multiple deal fields as deleted.
     */
    parameters: {
        /** @description The comma-separated field IDs to delete */
      query: z.object({
        ids: z.string(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.array(z.number().int()).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getDealField: {
    /**
     * Get one deal field 
     * @description Returns data about a specific deal field.
     */
    parameters: {
        /** @description The ID of the field */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              key: z.string().optional(),
              name: z.string().optional(),
              order_nr: z.number().int().optional(),
              field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              last_updated_by_user_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              edit_flag: z.boolean().optional(),
              index_visible_flag: z.boolean().optional(),
              details_visible_flag: z.boolean().optional(),
              add_visible_flag: z.boolean().optional(),
              important_flag: z.boolean().optional(),
              bulk_edit_allowed: z.boolean().optional(),
              searchable_flag: z.boolean().optional(),
              filtering_allowed: z.boolean().optional(),
              sortable_flag: z.boolean().optional(),
              mandatory_flag: z.boolean().optional(),
              options: z.array(z.record(z.any())).nullable().optional(),
              options_deleted: z.array(z.record(z.any())).optional(),
              is_subfield: z.boolean().optional(),
              subfields: z.array(z.record(z.any())).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  updateDealField: {
    /**
     * Update a deal field 
     * @description Updates a deal field. For more information, see the tutorial for <a href=" https://pipedrive.readme.io/docs/updating-custom-field-value " target="_blank" rel="noopener noreferrer">updating custom fields' values</a>.
     */
    parameters: {
        /** @description The ID of the field */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string().nullish(),
          options: z.array(z.record(z.any())).nullish(),
          add_visible_flag: z.boolean().nullish(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              key: z.string().optional(),
              name: z.string().optional(),
              order_nr: z.number().int().optional(),
              field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              last_updated_by_user_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              edit_flag: z.boolean().optional(),
              index_visible_flag: z.boolean().optional(),
              details_visible_flag: z.boolean().optional(),
              add_visible_flag: z.boolean().optional(),
              important_flag: z.boolean().optional(),
              bulk_edit_allowed: z.boolean().optional(),
              searchable_flag: z.boolean().optional(),
              filtering_allowed: z.boolean().optional(),
              sortable_flag: z.boolean().optional(),
              mandatory_flag: z.boolean().optional(),
              options: z.array(z.record(z.any())).nullable().optional(),
              options_deleted: z.array(z.record(z.any())).optional(),
              is_subfield: z.boolean().optional(),
              subfields: z.array(z.record(z.any())).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteDealField: {
    /**
     * Delete a deal field 
     * @description Marks a field as deleted. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/deleting-a-custom-field" target="_blank" rel="noopener noreferrer">deleting a custom field</a>.
     */
    parameters: {
        /** @description The ID of the field */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getFiles: {
    /**
     * Get all files 
     * @description Returns data about all files.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys). Supported fields: `id`, `user_id`, `deal_id`, `person_id`, `org_id`, `product_id`, `add_time`, `update_time`, `file_name`, `file_type`, `file_size`, `comment`. */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        sort: z.string().optional(),
      }).optional(),
    },
    responses: {
      /** @description Get data about all files uploaded to Pipedrive */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                id: z.number().int().optional(),
                user_id: z.number().int().optional(),
                deal_id: z.number().int().optional(),
                person_id: z.number().int().optional(),
                org_id: z.number().int().optional(),
                product_id: z.number().int().optional(),
                activity_id: z.number().int().optional(),
                lead_id: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                file_name: z.string().optional(),
                file_size: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                inline_flag: z.boolean().optional(),
                remote_location: z.string().optional(),
                remote_id: z.string().optional(),
                cid: z.string().optional(),
                s3_bucket: z.string().optional(),
                mail_message_id: z.string().optional(),
                mail_template_id: z.string().optional(),
                deal_name: z.string().optional(),
                person_name: z.string().optional(),
                org_name: z.string().optional(),
                product_name: z.string().optional(),
                lead_name: z.string().optional(),
                url: z.string().optional(),
                name: z.string().optional(),
                description: z.string().optional(),
              })).optional(),
            additional_data: z.object({
              pagination: z.intersection(z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
              }), z.object({
                next_start: z.number().int().optional(),
              })).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  addFile: {
    /**
     * Add file 
     * @description Lets you upload a file and associate it with a deal, person, organization, activity, product or lead. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-file" target="_blank" rel="noopener noreferrer">adding a file</a>.
     */
    requestBody: {
      content: {
        "multipart/form-data": z.object({
          file: z.string(),
          deal_id: z.number().int().nullish(),
          person_id: z.number().int().nullish(),
          org_id: z.number().int().nullish(),
          product_id: z.number().int().nullish(),
          activity_id: z.number().int().nullish(),
          lead_id: z.string().nullish(),
        }),
      },
    },
    responses: {
      /** @description Add a file from computer or Google Drive and associate it with deal, person, organization, activity or product */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              person_id: z.number().int().optional(),
              org_id: z.number().int().optional(),
              product_id: z.number().int().optional(),
              activity_id: z.number().int().optional(),
              lead_id: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              file_name: z.string().optional(),
              file_size: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              inline_flag: z.boolean().optional(),
              remote_location: z.string().optional(),
              remote_id: z.string().optional(),
              cid: z.string().optional(),
              s3_bucket: z.string().optional(),
              mail_message_id: z.string().optional(),
              mail_template_id: z.string().optional(),
              deal_name: z.string().optional(),
              person_name: z.string().optional(),
              org_name: z.string().optional(),
              product_name: z.string().optional(),
              lead_name: z.string().optional(),
              url: z.string().optional(),
              name: z.string().optional(),
              description: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  addFileAndLinkIt: {
    /**
     * Create a remote file and link it to an item 
     * @description Creates a new empty file in the remote location (`googledrive`) that will be linked to the item you supply. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-remote-file" target="_blank" rel="noopener noreferrer">adding a remote file</a>.
     */
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": z.object({
          file_type: z.enum(["gdoc", "gslides", "gsheet", "gform", "gdraw"]),
          title: z.string(),
          item_type: z.enum(["deal", "organization", "person"]),
          item_id: z.number().int(),
          remote_location: z.literal("googledrive"),
        }),
      },
    },
    responses: {
      /** @description Creates a new empty file in the remote location (googledrive) that will be linked to the item you supply - deal, person or organization */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              person_id: z.number().int().optional(),
              org_id: z.number().int().optional(),
              product_id: z.number().int().optional(),
              activity_id: z.number().int().optional(),
              lead_id: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              file_name: z.string().optional(),
              file_size: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              inline_flag: z.boolean().optional(),
              remote_location: z.string().optional(),
              remote_id: z.string().optional(),
              cid: z.string().optional(),
              s3_bucket: z.string().optional(),
              mail_message_id: z.string().optional(),
              mail_template_id: z.string().optional(),
              deal_name: z.string().optional(),
              person_name: z.string().optional(),
              org_name: z.string().optional(),
              product_name: z.string().optional(),
              lead_name: z.string().optional(),
              url: z.string().optional(),
              name: z.string().optional(),
              description: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  linkFileToItem: {
    /**
     * Link a remote file to an item 
     * @description Links an existing remote file (`googledrive`) to the item you supply. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-remote-file" target="_blank" rel="noopener noreferrer">adding a remote file</a>.
     */
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": z.object({
          item_type: z.enum(["deal", "organization", "person"]),
          item_id: z.number().int(),
          remote_id: z.string(),
          remote_location: z.literal("googledrive"),
        }),
      },
    },
    responses: {
      /** @description Links an existing remote file (googledrive) to the item you supply - deal, person, organization */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              person_id: z.number().int().optional(),
              org_id: z.number().int().optional(),
              product_id: z.number().int().optional(),
              activity_id: z.number().int().optional(),
              lead_id: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              file_name: z.string().optional(),
              file_size: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              inline_flag: z.boolean().optional(),
              remote_location: z.string().optional(),
              remote_id: z.string().optional(),
              cid: z.string().optional(),
              s3_bucket: z.string().optional(),
              mail_message_id: z.string().optional(),
              mail_template_id: z.string().optional(),
              deal_name: z.string().optional(),
              person_name: z.string().optional(),
              org_name: z.string().optional(),
              product_name: z.string().optional(),
              lead_name: z.string().optional(),
              url: z.string().optional(),
              name: z.string().optional(),
              description: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getFile: {
    /**
     * Get one file 
     * @description Returns data about a specific file.
     */
    parameters: {
        /** @description The ID of the file */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get data about one specific file uploaded to Pipedrive */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              person_id: z.number().int().optional(),
              org_id: z.number().int().optional(),
              product_id: z.number().int().optional(),
              activity_id: z.number().int().optional(),
              lead_id: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              file_name: z.string().optional(),
              file_size: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              inline_flag: z.boolean().optional(),
              remote_location: z.string().optional(),
              remote_id: z.string().optional(),
              cid: z.string().optional(),
              s3_bucket: z.string().optional(),
              mail_message_id: z.string().optional(),
              mail_template_id: z.string().optional(),
              deal_name: z.string().optional(),
              person_name: z.string().optional(),
              org_name: z.string().optional(),
              product_name: z.string().optional(),
              lead_name: z.string().optional(),
              url: z.string().optional(),
              name: z.string().optional(),
              description: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  updateFile: {
    /**
     * Update file details 
     * @description Updates the properties of a file.
     */
    parameters: {
        /** @description The ID of the file */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": z.object({
          name: z.string().nullish(),
          description: z.string().nullish(),
        }),
      },
    },
    responses: {
      /** @description Update file name and description */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              person_id: z.number().int().optional(),
              org_id: z.number().int().optional(),
              product_id: z.number().int().optional(),
              activity_id: z.number().int().optional(),
              lead_id: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              file_name: z.string().optional(),
              file_size: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              inline_flag: z.boolean().optional(),
              remote_location: z.string().optional(),
              remote_id: z.string().optional(),
              cid: z.string().optional(),
              s3_bucket: z.string().optional(),
              mail_message_id: z.string().optional(),
              mail_template_id: z.string().optional(),
              deal_name: z.string().optional(),
              person_name: z.string().optional(),
              org_name: z.string().optional(),
              product_name: z.string().optional(),
              lead_name: z.string().optional(),
              url: z.string().optional(),
              name: z.string().optional(),
              description: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteFile: {
    /**
     * Delete a file 
     * @description Marks a file as deleted. After 30 days, the file will be permanently deleted.
     */
    parameters: {
        /** @description The ID of the file */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Delete a file from Pipedrive */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  downloadFile: {
    /**
     * Download one file 
     * @description Initializes a file download.
     */
    parameters: {
        /** @description The ID of the file */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description success */
      200: {
        content: {
          "application/octet-stream": z.string(),
        },
      },
    },
  },
  getFilters: {
    /**
     * Get all filters 
     * @description Returns data about all filters.
     */
    parameters: {
        /** @description The types of filters to fetch */
      query: z.object({
        type: z.enum(["deals", "leads", "org", "people", "products", "activity", "projects"]).optional(),
      }).optional(),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                active_flag: z.boolean().optional(),
                type: z.string().optional(),
                user_id: z.number().int().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                visible_to: z.number().int().optional(),
                custom_view_id: z.number().int().optional(),
              })).optional(),
          })),
        },
      },
    },
  },
  addFilter: {
    /**
     * Add a new filter 
     * @description Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with 'AND', and only two second level condition groups are supported of which one must be glued with 'AND' and the second with 'OR'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-filter" target="_blank" rel="noopener noreferrer">adding a filter</a>.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string(),
          conditions: z.record(z.any()),
          type: z.string(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              active_flag: z.boolean().optional(),
              type: z.enum(["deals", "leads", "org", "people", "products", "activity", "projects"]).optional(),
              temporary_flag: z.boolean().optional(),
              user_id: z.number().int().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.number().int().optional(),
              custom_view_id: z.number().int().optional(),
              conditions: z.record(z.any()).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteFilters: {
    /**
     * Delete multiple filters in bulk 
     * @description Marks multiple filters as deleted.
     */
    parameters: {
        /** @description The comma-separated filter IDs to delete */
      query: z.object({
        ids: z.string(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.array(z.number().int()).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getFilterHelpers: {
    /**
     * Get all filter helpers 
     * @description Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href="/docs/api/v1/Filters#addFilter">add</a> or <a href="/docs/api/v1/Filters#updateFilter">update</a> filters. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-filter" target="_blank" rel="noopener noreferrer">adding a filter</a>.
     */
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.record(z.any()),
        },
      },
    },
  },
  getFilter: {
    /**
     * Get one filter 
     * @description Returns data about a specific filter. Note that this also returns the condition lines of the filter.
     */
    parameters: {
        /** @description The ID of the filter */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              active_flag: z.boolean().optional(),
              type: z.string().optional(),
              user_id: z.number().int().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.number().int().optional(),
              custom_view_id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  updateFilter: {
    /**
     * Update filter 
     * @description Updates an existing filter.
     */
    parameters: {
        /** @description The ID of the filter */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string().nullish(),
          conditions: z.record(z.any()),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              active_flag: z.boolean().optional(),
              type: z.enum(["deals", "leads", "org", "people", "products", "activity", "projects"]).optional(),
              temporary_flag: z.boolean().optional(),
              user_id: z.number().int().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.number().int().optional(),
              custom_view_id: z.number().int().optional(),
              conditions: z.record(z.any()).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteFilter: {
    /**
     * Delete a filter 
     * @description Marks a filter as deleted.
     */
    parameters: {
        /** @description The ID of the filter */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addGoal: {
    /**
     * Add a new goal 
     * @description Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          title: z.string().nullish(),
          assignee: z.record(z.any()),
          type: z.record(z.any()),
          expected_outcome: z.record(z.any()),
          duration: z.record(z.any()),
          interval: z.enum(["weekly", "monthly", "quarterly", "yearly"]),
        }),
      },
    },
    responses: {
      /** @description Successful response containing payload in the `data.goal` object */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              goal: z.object({
                id: z.string().optional(),
                owner_id: z.number().int().optional(),
                title: z.string().optional(),
                type: z.object({
                  name: z.string().optional(),
                  params: z.object({
                    pipeline_id: z.array(z.number().int()).optional(),
                    activity_type_id: z.array(z.number().int()).optional(),
                  }).optional(),
                }).optional(),
                assignee: z.object({
                  id: z.number().int().optional(),
                  type: z.string().optional(),
                }).optional(),
                interval: z.string().optional(),
                duration: z.object({
                  start: z.string().optional(),
                  end: z.string().optional(),
                }).optional(),
                expected_outcome: z.object({
                  target: z.number().int().optional(),
                  tracking_metric: z.string().optional(),
                }).optional(),
                is_active: z.boolean().optional(),
                report_ids: z.array(z.string()).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getGoals: {
    /**
     * Find goals 
     * @description Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
     */
    parameters: {
        /** @description The type of the goal. If provided, everyone's goals will be returned. */
        /** @description The title of the goal */
        /** @description Whether the goal is active or not */
        /** @description The ID of the user who's goal to fetch. When omitted, only your goals will be returned. */
        /** @description The type of the goal's assignee. If provided, everyone's goals will be returned. */
        /** @description The numeric value of the outcome. If provided, everyone's goals will be returned. */
        /** @description The tracking metric of the expected outcome of the goal. If provided, everyone's goals will be returned. */
        /** @description The numeric ID of the goal's currency. Only applicable to goals with `expected_outcome.tracking_metric` with value `sum`. If provided, everyone's goals will be returned. */
        /** @description An array of pipeline IDs or `null` for all pipelines. If provided, everyone's goals will be returned. */
        /** @description The ID of the stage. Applicable to only `deals_progressed` type of goals. If provided, everyone's goals will be returned. */
        /** @description An array of IDs or `null` for all activity types. Only applicable for `activities_completed` and/or `activities_added` types of goals. If provided, everyone's goals will be returned. */
        /** @description The start date of the period for which to find goals. Date in format of YYYY-MM-DD. When `period.start` is provided, `period.end` must be provided too. */
        /** @description The end date of the period for which to find goals. Date in format of YYYY-MM-DD. */
      query: z.object({
        "type.name": z.enum(["deals_won", "deals_progressed", "activities_completed", "activities_added", "deals_started"]).optional(),
        title: z.string().optional(),
        is_active: z.boolean().optional(),
        "assignee.id": z.number().int().optional(),
        "assignee.type": z.enum(["person", "company", "team"]).optional(),
        "expected_outcome.target": z.number().optional(),
        "expected_outcome.tracking_metric": z.enum(["quantity", "sum"]).optional(),
        "expected_outcome.currency_id": z.number().int().optional(),
        "type.params.pipeline_id": z.array(z.number().int()).optional(),
        "type.params.stage_id": z.number().int().optional(),
        "type.params.activity_type_id": z.array(z.number().int()).optional(),
        "period.start": z.string().optional(),
        "period.end": z.string().optional(),
      }).optional(),
    },
    responses: {
      /** @description Successful response containing payload in the `data.goal` object */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              goals: z.array(z.object({
                  id: z.string().optional(),
                  owner_id: z.number().int().optional(),
                  title: z.string().optional(),
                  type: z.object({
                    name: z.string().optional(),
                    params: z.object({
                      pipeline_id: z.array(z.number().int()).optional(),
                      activity_type_id: z.array(z.number().int()).optional(),
                    }).optional(),
                  }).optional(),
                  assignee: z.object({
                    id: z.number().int().optional(),
                    type: z.string().optional(),
                  }).optional(),
                  interval: z.string().optional(),
                  duration: z.object({
                    start: z.string().optional(),
                    end: z.string().optional(),
                  }).optional(),
                  expected_outcome: z.object({
                    target: z.number().int().optional(),
                    tracking_metric: z.string().optional(),
                  }).optional(),
                  is_active: z.boolean().optional(),
                  report_ids: z.array(z.string()).optional(),
                })).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  updateGoal: {
    /**
     * Update existing goal 
     * @description Updates an existing goal.
     */
    parameters: {
        /** @description The ID of the goal */
      path: z.object({
        id: z.string(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          title: z.string().nullish(),
          assignee: z.record(z.any()).nullish(),
          type: z.record(z.any()).nullish(),
          expected_outcome: z.record(z.any()).nullish(),
          duration: z.record(z.any()).nullish(),
          interval: z.enum(["weekly", "monthly", "quarterly", "yearly"]).nullish(),
        }),
      },
    },
    responses: {
      /** @description Successful response containing payload in the `data.goal` object */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              goal: z.object({
                id: z.string().optional(),
                owner_id: z.number().int().optional(),
                title: z.string().optional(),
                type: z.object({
                  name: z.string().optional(),
                  params: z.object({
                    pipeline_id: z.array(z.number().int()).optional(),
                    activity_type_id: z.array(z.number().int()).optional(),
                  }).optional(),
                }).optional(),
                assignee: z.object({
                  id: z.number().int().optional(),
                  type: z.string().optional(),
                }).optional(),
                interval: z.string().optional(),
                duration: z.object({
                  start: z.string().optional(),
                  end: z.string().optional(),
                }).optional(),
                expected_outcome: z.object({
                  target: z.number().int().optional(),
                  tracking_metric: z.string().optional(),
                }).optional(),
                is_active: z.boolean().optional(),
                report_ids: z.array(z.string()).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteGoal: {
    /**
     * Delete existing goal 
     * @description Marks a goal as deleted.
     */
    parameters: {
        /** @description The ID of the goal */
      path: z.object({
        id: z.string(),
      }),
    },
    responses: {
      /** @description Successful response with id 'success' field only */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
          }),
        },
      },
    },
  },
  getGoalResult: {
    /**
     * Get result of a goal 
     * @description Gets the progress of a goal for the specified period.
     */
    parameters: {
        /** @description The start date of the period for which to find the goal's progress. Format: YYYY-MM-DD. This date must be the same or after the goal duration start date. */
        /** @description The end date of the period for which to find the goal's progress. Format: YYYY-MM-DD. This date must be the same or before the goal duration end date. */
      query: z.object({
        "period.start": z.string(),
        "period.end": z.string(),
      }),
        /** @description The ID of the goal that the results are looked for */
      path: z.object({
        id: z.string(),
      }),
    },
    responses: {
      /** @description Successful response containing payload in the `data.goal` object */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              progress: z.number().int().optional(),
              goal: z.object({
                id: z.string().optional(),
                owner_id: z.number().int().optional(),
                title: z.string().optional(),
                type: z.object({
                  name: z.string().optional(),
                  params: z.object({
                    pipeline_id: z.array(z.number().int()).optional(),
                    activity_type_id: z.array(z.number().int()).optional(),
                  }).optional(),
                }).optional(),
                assignee: z.object({
                  id: z.number().int().optional(),
                  type: z.string().optional(),
                }).optional(),
                interval: z.string().optional(),
                duration: z.object({
                  start: z.string().optional(),
                  end: z.string().optional(),
                }).optional(),
                expected_outcome: z.object({
                  target: z.number().int().optional(),
                  tracking_metric: z.string().optional(),
                }).optional(),
                is_active: z.boolean().optional(),
                report_ids: z.array(z.string()).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  searchItem: {
    /**
     * Perform a search from multiple item types 
     * @description Performs a search from your choice of item types and fields.
     */
    parameters: {
        /** @description The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded. */
        /** @description A comma-separated string array. The type of items to perform the search from. Defaults to all. */
        /** @description A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:<br> <table> <tr><th><b>Item type</b></th><th><b>Field</b></th></tr> <tr><td>Deal</td><td>`custom_fields`, `notes`, `title`</td></tr> <tr><td>Person</td><td>`custom_fields`, `email`, `name`, `notes`, `phone`</td></tr> <tr><td>Organization</td><td>`address`, `custom_fields`, `name`, `notes`</td></tr> <tr><td>Product</td><td>`code`, `custom_fields`, `name`</td></tr> <tr><td>Lead</td><td>`custom_fields`, `notes`, `email`, `organization_name`, `person_name`, `phone`, `title`</td></tr> <tr><td>File</td><td>`name`</td></tr> <tr><td>Mail attachment</td><td>`name`</td></tr> <tr><td>Project</td><td> `custom_fields`, `notes`, `title`, `description` </td></tr> </table> <br> Only the following custom field types are searchable: `address`, `varchar`, `text`, `varchar_auto`, `double`, `monetary` and `phone`. Read more about searching by custom fields <a href="https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields" target="_blank" rel="noopener noreferrer">here</a>.<br/> When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use `search_for_related_items`. */
        /** @description When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization */
        /** @description When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive. */
        /** @description A comma-separated string array. Supports including optional fields in the results which are not provided by default. */
        /** @description Pagination start. Note that the pagination is based on main results and does not include related items when using `search_for_related_items` parameter. */
        /** @description Items shown per page */
      query: z.object({
        term: z.string(),
        item_types: z.enum(["deal", "person", "organization", "product", "lead", "file", "mail_attachment", "project"]).optional(),
        fields: z.enum(["address", "code", "custom_fields", "email", "name", "notes", "organization_name", "person_name", "phone", "title", "description"]).optional(),
        search_for_related_items: z.boolean().optional(),
        exact_match: z.boolean().optional(),
        include_fields: z.enum(["deal.cc_email", "person.picture", "product.price"]).optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              items: z.array(z.object({
                  result_score: z.number().optional(),
                  item: z.record(z.any()).optional(),
                })).optional(),
              related_items: z.array(z.object({
                  result_score: z.number().optional(),
                  item: z.record(z.any()).optional(),
                })).optional(),
            }).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
                next_start: z.number().int().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  searchItemByField: {
    /**
     * Perform a search using a specific field from an item type 
     * @description Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
     */
    parameters: {
        /** @description The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded. */
        /** @description The type of the field to perform the search from */
        /** @description When enabled, only full exact matches against the given term are returned. The search <b>is</b> case sensitive. */
        /** @description The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields' API GET methods (dealFields, personFields, etc.). Only the following custom field types are searchable: `address`, `varchar`, `text`, `varchar_auto`, `double`, `monetary` and `phone`. Read more about searching by custom fields <a href="https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields" target="_blank" rel="noopener noreferrer">here</a>. */
        /** @description Whether to return the IDs of the matching items or not. When not set or set to `0` or `false`, only distinct values of the searched field are returned. When set to `1` or `true`, the ID of each found item is returned. */
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        term: z.string(),
        field_type: z.enum(["dealField", "leadField", "personField", "organizationField", "productField", "projectField"]),
        exact_match: z.boolean().optional(),
        field_key: z.string(),
        return_item_ids: z.boolean().optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                $field_key: z.record(z.any()).optional(),
              })).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
                next_start: z.number().int().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getLeads: {
    /**
     * Get all leads 
     * @description Returns multiple leads. Leads are sorted by the time they were created, from oldest to newest. Pagination can be controlled using `limit` and `start` query parameters. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals.
     */
    parameters: {
        /** @description For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. */
        /** @description For pagination, the position that represents the first result for the page */
        /** @description Filtering based on the archived status of a lead. If not provided, `All` is used. */
        /** @description If supplied, only leads matching the given user will be returned. However, `filter_id` takes precedence over `owner_id` when supplied. */
        /** @description If supplied, only leads matching the given person will be returned. However, `filter_id` takes precedence over `person_id` when supplied. */
        /** @description If supplied, only leads matching the given organization will be returned. However, `filter_id` takes precedence over `organization_id` when supplied. */
        /** @description The ID of the filter to use */
        /** @description The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys). */
      query: z.object({
        limit: z.number().int().optional(),
        start: z.number().int().optional(),
        archived_status: z.enum(["archived", "not_archived", "all"]).optional(),
        owner_id: z.number().int().optional(),
        person_id: z.number().int().optional(),
        organization_id: z.number().int().optional(),
        filter_id: z.number().int().optional(),
        sort: z.enum(["id", "title", "owner_id", "creator_id", "was_seen", "expected_close_date", "next_activity_id", "add_time", "update_time"]).optional(),
      }).optional(),
    },
    responses: {
      /** @description Successful response containing payload in the `data` field */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                id: z.string().optional(),
                title: z.string().optional(),
                owner_id: z.number().int().optional(),
                creator_id: z.number().int().optional(),
                label_ids: z.array(z.string()).optional(),
                person_id: z.number().int().nullable().optional(),
                organization_id: z.number().int().nullable().optional(),
                source_name: z.string().optional(),
                is_archived: z.boolean().optional(),
                was_seen: z.boolean().optional(),
                value: z.object({
                  amount: z.number(),
                  currency: z.string(),
                }).optional(),
                expected_close_date: z.string().nullable().optional(),
                next_activity_id: z.number().int().nullable().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                visible_to: z.string().optional(),
                cc_email: z.string().optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  addLead: {
    /**
     * Add a lead 
     * @description Creates a lead. A lead always has to be linked to a person or an organization or both. All leads created through the Pipedrive API will have a lead source `API` assigned. Here's the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-lead" target="_blank" rel="noopener noreferrer">adding a lead</a>. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals. See an example given in the <a href="https://pipedrive.readme.io/docs/updating-custom-field-value" target="_blank" rel="noopener noreferrer">updating custom fields' values tutorial</a>.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          title: z.string(),
          owner_id: z.number().int().nullish(),
          label_ids: z.array(z.string()).nullish(),
          person_id: z.number().int().nullish(),
          organization_id: z.number().int().nullish(),
          value: z.object({
            amount: z.number(),
            currency: z.string(),
          }).nullish(),
          expected_close_date: z.string().nullish(),
          visible_to: z.string().nullish(),
          was_seen: z.boolean().nullish(),
        }),
      },
    },
    responses: {
      /** @description Successful response containing payload in the `data` field */
      201: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.string().optional(),
              title: z.string().optional(),
              owner_id: z.number().int().optional(),
              creator_id: z.number().int().optional(),
              label_ids: z.array(z.string()).optional(),
              person_id: z.number().int().nullable().optional(),
              organization_id: z.number().int().nullable().optional(),
              source_name: z.string().optional(),
              is_archived: z.boolean().optional(),
              was_seen: z.boolean().optional(),
              value: z.object({
                amount: z.number(),
                currency: z.string(),
              }).optional(),
              expected_close_date: z.string().nullable().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.string().optional(),
              cc_email: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getLead: {
    /**
     * Get one lead 
     * @description Returns details of a specific lead. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals.
     */
    parameters: {
        /** @description The ID of the lead */
      path: z.object({
        id: z.string(),
      }),
    },
    responses: {
      /** @description Successful response containing payload in the `data` field */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.string().optional(),
              title: z.string().optional(),
              owner_id: z.number().int().optional(),
              creator_id: z.number().int().optional(),
              label_ids: z.array(z.string()).optional(),
              person_id: z.number().int().nullable().optional(),
              organization_id: z.number().int().nullable().optional(),
              source_name: z.string().optional(),
              is_archived: z.boolean().optional(),
              was_seen: z.boolean().optional(),
              value: z.object({
                amount: z.number(),
                currency: z.string(),
              }).optional(),
              expected_close_date: z.string().nullable().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.string().optional(),
              cc_email: z.string().optional(),
            }).optional(),
          }),
        },
      },
      /** @description A resource describing an error */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  deleteLead: {
    /**
     * Delete a lead 
     * @description Deletes a specific lead.
     */
    parameters: {
        /** @description The ID of the lead */
      path: z.object({
        id: z.string(),
      }),
    },
    responses: {
      /** @description Successful response with id value only. Used in DELETE calls. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.string().optional(),
            }).optional(),
          }),
        },
      },
      /** @description A resource describing an error */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  updateLead: {
    /**
     * Update a lead 
     * @description Updates one or more properties of a lead. Only properties included in the request will be updated. Send `null` to unset a property (applicable for example for `value`, `person_id` or `organization_id`). If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals. See an example given in the <a href="https://pipedrive.readme.io/docs/updating-custom-field-value" target="_blank" rel="noopener noreferrer">updating custom fields values tutorial</a>.
     */
    parameters: {
        /** @description The ID of the lead */
      path: z.object({
        id: z.string(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          title: z.string().nullable().nullish(),
          owner_id: z.number().int().nullish(),
          label_ids: z.array(z.string()).nullish(),
          person_id: z.number().int().nullable().nullish(),
          organization_id: z.number().int().nullable().nullish(),
          is_archived: z.boolean().nullish(),
          value: z.object({
            amount: z.number(),
            currency: z.string(),
          }).nullable().nullish(),
          expected_close_date: z.string().nullable().nullish(),
          visible_to: z.string().nullish(),
          was_seen: z.boolean().nullish(),
        }),
      },
    },
    responses: {
      /** @description Successful response containing payload in the `data` field */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.string().optional(),
              title: z.string().optional(),
              owner_id: z.number().int().optional(),
              creator_id: z.number().int().optional(),
              label_ids: z.array(z.string()).optional(),
              person_id: z.number().int().nullable().optional(),
              organization_id: z.number().int().nullable().optional(),
              source_name: z.string().optional(),
              is_archived: z.boolean().optional(),
              was_seen: z.boolean().optional(),
              value: z.object({
                amount: z.number(),
                currency: z.string(),
              }).optional(),
              expected_close_date: z.string().nullable().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.string().optional(),
              cc_email: z.string().optional(),
            }).optional(),
          }),
        },
      },
      /** @description A resource describing an error */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getLeadUsers: {
    /**
     * List permitted users 
     * @description Lists the users permitted to access a lead.
     */
    parameters: {
        /** @description The ID of the lead */
      path: z.object({
        id: z.string(),
      }),
    },
    responses: {
      /** @description Lists users permitted to access a lead */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.number().int()).optional(),
          })),
        },
      },
    },
  },
  searchLeads: {
    /**
     * Search leads 
     * @description Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href="https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
     */
    parameters: {
        /** @description The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded. */
        /** @description A comma-separated string array. The fields to perform the search from. Defaults to all of them. */
        /** @description When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive. */
        /** @description Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000. */
        /** @description Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000. */
        /** @description Supports including optional fields in the results which are not provided by default */
        /** @description Pagination start. Note that the pagination is based on main results and does not include related items when using `search_for_related_items` parameter. */
        /** @description Items shown per page */
      query: z.object({
        term: z.string(),
        fields: z.enum(["custom_fields", "notes", "title"]).optional(),
        exact_match: z.boolean().optional(),
        person_id: z.number().int().optional(),
        organization_id: z.number().int().optional(),
        include_fields: z.literal("lead.was_seen").optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              items: z.array(z.object({
                  result_score: z.number().optional(),
                  item: z.object({
                    id: z.string().optional(),
                    type: z.string().optional(),
                    title: z.string().optional(),
                    owner: z.object({
                      id: z.number().int().optional(),
                    }).optional(),
                    person: z.object({
                      id: z.number().int().optional(),
                      name: z.string().optional(),
                    }).optional(),
                    organization: z.object({
                      id: z.number().int().optional(),
                      name: z.string().optional(),
                    }).optional(),
                    phones: z.array(z.string()).optional(),
                    emails: z.array(z.string()).optional(),
                    custom_fields: z.array(z.string()).optional(),
                    notes: z.array(z.string()).optional(),
                    value: z.number().int().optional(),
                    currency: z.string().optional(),
                    visible_to: z.number().int().optional(),
                    is_archived: z.boolean().optional(),
                  }).optional(),
                })).optional(),
            }).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
                next_start: z.number().int().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getLeadLabels: {
    /**
     * Get all lead labels 
     * @description Returns details of all lead labels. This endpoint does not support pagination and all labels are always returned.
     */
    responses: {
      /** @description Successful response containing payload in the `data` field */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                id: z.string().optional(),
                name: z.string().optional(),
                color: z.enum(["green", "blue", "red", "yellow", "purple", "gray"]).optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              })).optional(),
          }),
        },
      },
    },
  },
  addLeadLabel: {
    /**
     * Add a lead label 
     * @description Creates a lead label.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string(),
          color: z.enum(["green", "blue", "red", "yellow", "purple", "gray"]),
        }),
      },
    },
    responses: {
      /** @description Successful response containing payload in the `data` field */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.string().optional(),
              name: z.string().optional(),
              color: z.enum(["green", "blue", "red", "yellow", "purple", "gray"]).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteLeadLabel: {
    /**
     * Delete a lead label 
     * @description Deletes a specific lead label.
     */
    parameters: {
        /** @description The ID of the lead label */
      path: z.object({
        id: z.string(),
      }),
    },
    responses: {
      /** @description Successful response with id value only. Used in DELETE calls. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.string().optional(),
            }).optional(),
          }),
        },
      },
      /** @description A resource describing an error */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  updateLeadLabel: {
    /**
     * Update a lead label 
     * @description Updates one or more properties of a lead label. Only properties included in the request will be updated.
     */
    parameters: {
        /** @description The ID of the lead label */
      path: z.object({
        id: z.string(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string().nullish(),
          color: z.enum(["green", "blue", "red", "yellow", "purple", "gray"]).nullish(),
        }),
      },
    },
    responses: {
      /** @description Successful response containing payload in the `data` field */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.string().optional(),
              name: z.string().optional(),
              color: z.enum(["green", "blue", "red", "yellow", "purple", "gray"]).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          }),
        },
      },
      /** @description A resource describing an error */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            error_info: z.string().optional(),
            data: z.record(z.unknown()).nullable().optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getLeadSources: {
    /**
     * Get all lead sources 
     * @description Returns all lead sources. Please note that the list of lead sources is fixed, it cannot be modified. All leads created through the Pipedrive API will have a lead source `API` assigned.
     */
    responses: {
      /** @description The successful response containing payload in the `data` field. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                name: z.string().optional(),
              })).optional(),
          }),
        },
      },
    },
  },
  getTeams: {
    /**
     * Get all teams 
     * @deprecated 
     * @description Returns data about teams within the company.
     */
    parameters: {
        /** @description The field name to sort returned teams by */
        /** @description When enabled, the teams will not include IDs of member users */
      query: z.object({
        order_by: z.enum(["id", "name", "manager_id", "active_flag"]).optional(),
        skip_users: z.number().optional(),
      }).optional(),
    },
    responses: {
      /** @description The list of team objects */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
              }), z.intersection(z.intersection(z.object({
                name: z.string().optional(),
                description: z.string().optional(),
                manager_id: z.number().int().optional(),
                users: z.array(z.number().int()).optional(),
              }), z.object({
                active_flag: z.number().optional(),
                deleted_flag: z.number().optional(),
              })), z.object({
                add_time: z.string().optional(),
                created_by_user_id: z.number().int().optional(),
              })))).optional(),
          })),
        },
      },
    },
  },
  addTeam: {
    /**
     * Add a new team 
     * @deprecated 
     * @description Adds a new team to the company and returns the created object.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string(),
          description: z.string().nullish(),
          manager_id: z.number().int(),
          users: z.array(z.number().int()).nullish(),
        }),
      },
    },
    responses: {
      /** @description The team data */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              id: z.number().int().optional(),
            }), z.intersection(z.intersection(z.object({
              name: z.string().optional(),
              description: z.string().optional(),
              manager_id: z.number().int().optional(),
              users: z.array(z.number().int()).optional(),
            }), z.object({
              active_flag: z.number().optional(),
              deleted_flag: z.number().optional(),
            })), z.object({
              add_time: z.string().optional(),
              created_by_user_id: z.number().int().optional(),
            }))).optional(),
          })),
        },
      },
      /** @description Forbidden response */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  getTeam: {
    /**
     * Get a single team 
     * @deprecated 
     * @description Returns data about a specific team.
     */
    parameters: {
        /** @description When enabled, the teams will not include IDs of member users */
      query: z.object({
        skip_users: z.number().optional(),
      }).optional(),
        /** @description The ID of the team */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description The team data */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              id: z.number().int().optional(),
            }), z.intersection(z.intersection(z.object({
              name: z.string().optional(),
              description: z.string().optional(),
              manager_id: z.number().int().optional(),
              users: z.array(z.number().int()).optional(),
            }), z.object({
              active_flag: z.number().optional(),
              deleted_flag: z.number().optional(),
            })), z.object({
              add_time: z.string().optional(),
              created_by_user_id: z.number().int().optional(),
            }))).optional(),
          })),
        },
      },
      /** @description Team with specified ID does not exist or is inaccessible */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  updateTeam: {
    /**
     * Update a team 
     * @deprecated 
     * @description Updates an existing team and returns the updated object.
     */
    parameters: {
        /** @description The ID of the team */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          name: z.string().nullish(),
          description: z.string().nullish(),
          manager_id: z.number().int().nullish(),
          users: z.array(z.number().int()).nullish(),
        }), z.object({
          active_flag: z.number().nullish(),
          deleted_flag: z.number().nullish(),
        })),
      },
    },
    responses: {
      /** @description The team data */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              id: z.number().int().optional(),
            }), z.intersection(z.intersection(z.object({
              name: z.string().optional(),
              description: z.string().optional(),
              manager_id: z.number().int().optional(),
              users: z.array(z.number().int()).optional(),
            }), z.object({
              active_flag: z.number().optional(),
              deleted_flag: z.number().optional(),
            })), z.object({
              add_time: z.string().optional(),
              created_by_user_id: z.number().int().optional(),
            }))).optional(),
          })),
        },
      },
      /** @description Forbidden response */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
      /** @description Team with specified ID does not exist or is inaccessible */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  getTeamUsers: {
    /**
     * Get all users in a team 
     * @deprecated 
     * @description Returns a list of all user IDs within a team.
     */
    parameters: {
        /** @description The ID of the team */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description A list of user IDs within a team */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.number().int()).optional(),
          })),
        },
      },
      /** @description Team with specified ID does not exist or is inaccessible */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  addTeamUser: {
    /**
     * Add users to a team 
     * @deprecated 
     * @description Adds users to an existing team.
     */
    parameters: {
        /** @description The ID of the team */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          users: z.array(z.number().int()),
        }),
      },
    },
    responses: {
      /** @description A list of user IDs within a team */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.number().int()).optional(),
          })),
        },
      },
      /** @description Forbidden response */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
      /** @description Team with specified ID does not exist or is inaccessible */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  deleteTeamUser: {
    /**
     * Delete users from a team 
     * @deprecated 
     * @description Deletes users from an existing team.
     */
    parameters: {
        /** @description The ID of the team */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          users: z.array(z.number().int()),
        }),
      },
    },
    responses: {
      /** @description A list of user IDs within a team */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.number().int()).optional(),
          })),
        },
      },
      /** @description Forbidden response */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
      /** @description Team with specified ID does not exist or is inaccessible */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  getUserTeams: {
    /**
     * Get all teams of a user 
     * @deprecated 
     * @description Returns data about all teams which have the specified user as a member.
     */
    parameters: {
        /** @description The field name to sort returned teams by */
        /** @description When enabled, the teams will not include IDs of member users */
      query: z.object({
        order_by: z.enum(["id", "name", "manager_id", "active_flag"]).optional(),
        skip_users: z.number().optional(),
      }).optional(),
        /** @description The ID of the user */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description The list of team objects */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
              }), z.intersection(z.intersection(z.object({
                name: z.string().optional(),
                description: z.string().optional(),
                manager_id: z.number().int().optional(),
                users: z.array(z.number().int()).optional(),
              }), z.object({
                active_flag: z.number().optional(),
                deleted_flag: z.number().optional(),
              })), z.object({
                add_time: z.string().optional(),
                created_by_user_id: z.number().int().optional(),
              })))).optional(),
          })),
        },
      },
    },
  },
  getMailMessage: {
    /**
     * Get one mail message 
     * @description Returns data about a specific mail message.
     */
    parameters: {
        /** @description Whether to include the full message body or not. `0` = Don't include, `1` = Include. */
      query: z.object({
        include_body: z.number().optional(),
      }).optional(),
        /** @description The ID of the mail message to fetch */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description The mail messages that are being synced with Pipedrive */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
            statusCode: z.number().int().optional(),
            statusText: z.string().optional(),
            service: z.string().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              from: z.array(z.object({
                  id: z.number().int().optional(),
                  email_address: z.string().optional(),
                  name: z.string().optional(),
                  linked_person_id: z.number().int().optional(),
                  linked_person_name: z.string().optional(),
                  mail_message_party_id: z.number().int().optional(),
                })).optional(),
              to: z.array(z.object({
                  id: z.number().int().optional(),
                  email_address: z.string().optional(),
                  name: z.string().optional(),
                  linked_person_id: z.number().int().optional(),
                  linked_person_name: z.string().optional(),
                  mail_message_party_id: z.number().int().optional(),
                })).optional(),
              cc: z.array(z.object({
                  id: z.number().int().optional(),
                  email_address: z.string().optional(),
                  name: z.string().optional(),
                  linked_person_id: z.number().int().optional(),
                  linked_person_name: z.string().optional(),
                  mail_message_party_id: z.number().int().optional(),
                })).optional(),
              bcc: z.array(z.object({
                  id: z.number().int().optional(),
                  email_address: z.string().optional(),
                  name: z.string().optional(),
                  linked_person_id: z.number().int().optional(),
                  linked_person_name: z.string().optional(),
                  mail_message_party_id: z.number().int().optional(),
                })).optional(),
              body_url: z.string().optional(),
              account_id: z.string().optional(),
              user_id: z.number().int().optional(),
              mail_thread_id: z.number().int().optional(),
              subject: z.string().optional(),
              snippet: z.string().optional(),
              mail_tracking_status: z.enum(["opened", "not opened"]).nullable().optional(),
              mail_link_tracking_enabled_flag: z.number().optional(),
              read_flag: z.number().optional(),
              draft: z.string().optional(),
              draft_flag: z.number().optional(),
              synced_flag: z.number().optional(),
              deleted_flag: z.number().optional(),
              has_body_flag: z.number().optional(),
              sent_flag: z.number().optional(),
              sent_from_pipedrive_flag: z.number().optional(),
              smart_bcc_flag: z.number().optional(),
              message_time: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              has_attachments_flag: z.number().optional(),
              has_inline_attachments_flag: z.number().optional(),
              has_real_attachments_flag: z.number().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getMailThreads: {
    /**
     * Get mail threads 
     * @description Returns mail threads in a specified folder ordered by the most recent message within.
     */
    parameters: {
        /** @description The type of folder to fetch */
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        folder: z.enum(["inbox", "drafts", "sent", "archive"]),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }),
    },
    responses: {
      /** @description Get mail threads */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                account_id: z.string().optional(),
                user_id: z.number().int().optional(),
                subject: z.string().optional(),
                snippet: z.string().optional(),
                read_flag: z.number().optional(),
                mail_tracking_status: z.string().nullable().optional(),
                has_attachments_flag: z.number().optional(),
                has_inline_attachments_flag: z.number().optional(),
                has_real_attachments_flag: z.number().optional(),
                deleted_flag: z.number().optional(),
                synced_flag: z.number().optional(),
                smart_bcc_flag: z.number().optional(),
                mail_link_tracking_enabled_flag: z.number().optional(),
              }), z.object({
                parties: z.object({
                  to: z.array(z.object({
                      id: z.number().int().optional(),
                      name: z.string().optional(),
                      latest_sent: z.boolean().optional(),
                      email_address: z.string().optional(),
                      message_time: z.number().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                      linked_organization_id: z.number().int().nullable().optional(),
                    })).optional(),
                  from: z.array(z.object({
                      id: z.number().int().optional(),
                      name: z.string().optional(),
                      latest_sent: z.boolean().optional(),
                      email_address: z.string().optional(),
                      message_time: z.number().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                      linked_organization_id: z.number().int().nullable().optional(),
                    })).optional(),
                }).optional(),
                drafts_parties: z.array(z.record(z.any())).optional(),
                folders: z.array(z.string()).optional(),
                version: z.number().optional(),
                snippet_draft: z.string().nullable().optional(),
                snippet_sent: z.string().optional(),
                message_count: z.number().int().optional(),
                has_draft_flag: z.number().optional(),
                has_sent_flag: z.number().optional(),
                archived_flag: z.number().optional(),
                shared_flag: z.number().optional(),
                external_deleted_flag: z.number().optional(),
                first_message_to_me_flag: z.number().optional(),
                last_message_timestamp: z.string().optional(),
                first_message_timestamp: z.string().optional(),
                last_message_sent_timestamp: z.string().nullable().optional(),
                last_message_received_timestamp: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                deal_id: z.number().int().nullable().optional(),
                deal_status: z.string().nullable().optional(),
                lead_id: z.string().nullable().optional(),
                all_messages_sent_flag: z.number().optional(),
              }))).optional(),
          })),
        },
      },
    },
  },
  getMailThread: {
    /**
     * Get one mail thread 
     * @description Returns a specific mail thread.
     */
    parameters: {
        /** @description The ID of the mail thread */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get mail threads */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              account_id: z.string().optional(),
              user_id: z.number().int().optional(),
              subject: z.string().optional(),
              snippet: z.string().optional(),
              read_flag: z.number().optional(),
              mail_tracking_status: z.string().nullable().optional(),
              has_attachments_flag: z.number().optional(),
              has_inline_attachments_flag: z.number().optional(),
              has_real_attachments_flag: z.number().optional(),
              deleted_flag: z.number().optional(),
              synced_flag: z.number().optional(),
              smart_bcc_flag: z.number().optional(),
              mail_link_tracking_enabled_flag: z.number().optional(),
            }), z.object({
              parties: z.object({
                to: z.array(z.object({
                    id: z.number().int().optional(),
                    name: z.string().optional(),
                    latest_sent: z.boolean().optional(),
                    email_address: z.string().optional(),
                    message_time: z.number().optional(),
                    linked_person_id: z.number().int().optional(),
                    linked_person_name: z.string().optional(),
                    mail_message_party_id: z.number().int().optional(),
                    linked_organization_id: z.number().int().nullable().optional(),
                  })).optional(),
                from: z.array(z.object({
                    id: z.number().int().optional(),
                    name: z.string().optional(),
                    latest_sent: z.boolean().optional(),
                    email_address: z.string().optional(),
                    message_time: z.number().optional(),
                    linked_person_id: z.number().int().optional(),
                    linked_person_name: z.string().optional(),
                    mail_message_party_id: z.number().int().optional(),
                    linked_organization_id: z.number().int().nullable().optional(),
                  })).optional(),
              }).optional(),
              drafts_parties: z.array(z.record(z.any())).optional(),
              folders: z.array(z.string()).optional(),
              version: z.number().optional(),
              snippet_draft: z.string().nullable().optional(),
              snippet_sent: z.string().optional(),
              message_count: z.number().int().optional(),
              has_draft_flag: z.number().optional(),
              has_sent_flag: z.number().optional(),
              archived_flag: z.number().optional(),
              shared_flag: z.number().optional(),
              external_deleted_flag: z.number().optional(),
              first_message_to_me_flag: z.number().optional(),
              last_message_timestamp: z.string().optional(),
              first_message_timestamp: z.string().optional(),
              last_message_sent_timestamp: z.string().nullable().optional(),
              last_message_received_timestamp: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              deal_id: z.number().int().nullable().optional(),
              deal_status: z.string().nullable().optional(),
              lead_id: z.string().nullable().optional(),
              all_messages_sent_flag: z.number().optional(),
            })).optional(),
          })),
        },
      },
    },
  },
  updateMailThreadDetails: {
    /**
     * Update mail thread details 
     * @description Updates the properties of a mail thread.
     */
    parameters: {
        /** @description The ID of the mail thread */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": z.object({
          deal_id: z.number().int().nullish(),
          lead_id: z.string().nullish(),
          shared_flag: z.number().nullish(),
          read_flag: z.number().nullish(),
          archived_flag: z.number().nullish(),
        }),
      },
    },
    responses: {
      /** @description Updates the properties of a mail thread */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              account_id: z.string().optional(),
              user_id: z.number().int().optional(),
              subject: z.string().optional(),
              snippet: z.string().optional(),
              read_flag: z.number().optional(),
              mail_tracking_status: z.string().nullable().optional(),
              has_attachments_flag: z.number().optional(),
              has_inline_attachments_flag: z.number().optional(),
              has_real_attachments_flag: z.number().optional(),
              deleted_flag: z.number().optional(),
              synced_flag: z.number().optional(),
              smart_bcc_flag: z.number().optional(),
              mail_link_tracking_enabled_flag: z.number().optional(),
            }), z.object({
              parties: z.object({
                to: z.array(z.object({
                    id: z.number().int().optional(),
                    name: z.string().optional(),
                    latest_sent: z.boolean().optional(),
                    email_address: z.string().optional(),
                    message_time: z.number().optional(),
                    linked_person_id: z.number().int().optional(),
                    linked_person_name: z.string().optional(),
                    mail_message_party_id: z.number().int().optional(),
                    linked_organization_id: z.number().int().nullable().optional(),
                  })).optional(),
                from: z.array(z.object({
                    id: z.number().int().optional(),
                    name: z.string().optional(),
                    latest_sent: z.boolean().optional(),
                    email_address: z.string().optional(),
                    message_time: z.number().optional(),
                    linked_person_id: z.number().int().optional(),
                    linked_person_name: z.string().optional(),
                    mail_message_party_id: z.number().int().optional(),
                    linked_organization_id: z.number().int().nullable().optional(),
                  })).optional(),
              }).optional(),
              drafts_parties: z.array(z.record(z.any())).optional(),
              folders: z.array(z.string()).optional(),
              version: z.number().optional(),
              snippet_draft: z.string().nullable().optional(),
              snippet_sent: z.string().optional(),
              message_count: z.number().int().optional(),
              has_draft_flag: z.number().optional(),
              has_sent_flag: z.number().optional(),
              archived_flag: z.number().optional(),
              shared_flag: z.number().optional(),
              external_deleted_flag: z.number().optional(),
              first_message_to_me_flag: z.number().optional(),
              last_message_timestamp: z.string().optional(),
              first_message_timestamp: z.string().optional(),
              last_message_sent_timestamp: z.string().nullable().optional(),
              last_message_received_timestamp: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              deal_id: z.number().int().nullable().optional(),
              deal_status: z.string().nullable().optional(),
              lead_id: z.string().nullable().optional(),
              all_messages_sent_flag: z.number().optional(),
            })).optional(),
          })),
        },
      },
    },
  },
  deleteMailThread: {
    /**
     * Delete mail thread 
     * @description Marks a mail thread as deleted.
     */
    parameters: {
        /** @description The ID of the mail thread */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Marks mail thread as deleted */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getMailThreadMessages: {
    /**
     * Get all mail messages of mail thread 
     * @description Returns all the mail messages inside a specified mail thread.
     */
    parameters: {
        /** @description The ID of the mail thread */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get mail messages from thread */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                account_id: z.string().optional(),
                user_id: z.number().int().optional(),
                subject: z.string().optional(),
                snippet: z.string().optional(),
                read_flag: z.number().optional(),
                mail_tracking_status: z.string().nullable().optional(),
                has_attachments_flag: z.number().optional(),
                has_inline_attachments_flag: z.number().optional(),
                has_real_attachments_flag: z.number().optional(),
                deleted_flag: z.number().optional(),
                synced_flag: z.number().optional(),
                smart_bcc_flag: z.number().optional(),
                mail_link_tracking_enabled_flag: z.number().optional(),
              }), z.object({
                from: z.array(z.object({
                    id: z.number().int().optional(),
                    name: z.string().optional(),
                    latest_sent: z.boolean().optional(),
                    email_address: z.string().optional(),
                    message_time: z.number().optional(),
                    linked_person_id: z.number().int().optional(),
                    linked_person_name: z.string().optional(),
                    mail_message_party_id: z.number().int().optional(),
                    linked_organization_id: z.number().int().nullable().optional(),
                  })).optional(),
                to: z.array(z.object({
                    id: z.number().int().optional(),
                    name: z.string().optional(),
                    latest_sent: z.boolean().optional(),
                    email_address: z.string().optional(),
                    message_time: z.number().optional(),
                    linked_person_id: z.number().int().optional(),
                    linked_person_name: z.string().optional(),
                    mail_message_party_id: z.number().int().optional(),
                    linked_organization_id: z.number().int().nullable().optional(),
                  })).optional(),
                cc: z.array(z.object({
                    id: z.number().int().optional(),
                    name: z.string().optional(),
                    latest_sent: z.boolean().optional(),
                    email_address: z.string().optional(),
                    message_time: z.number().optional(),
                    linked_person_id: z.number().int().optional(),
                    linked_person_name: z.string().optional(),
                    mail_message_party_id: z.number().int().optional(),
                    linked_organization_id: z.number().int().nullable().optional(),
                  })).optional(),
                bcc: z.array(z.object({
                    id: z.number().int().optional(),
                    name: z.string().optional(),
                    latest_sent: z.boolean().optional(),
                    email_address: z.string().optional(),
                    message_time: z.number().optional(),
                    linked_person_id: z.number().int().optional(),
                    linked_person_name: z.string().optional(),
                    mail_message_party_id: z.number().int().optional(),
                    linked_organization_id: z.number().int().nullable().optional(),
                  })).optional(),
                body_url: z.string().optional(),
                mail_thread_id: z.number().int().optional(),
                draft: z.string().nullable().optional(),
                has_body_flag: z.number().optional(),
                sent_flag: z.number().optional(),
                sent_from_pipedrive_flag: z.number().optional(),
                message_time: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              }))).optional(),
          })),
        },
      },
    },
  },
  saveUserProviderLink: {
    /**
     * Link a user with the installed video call integration 
     * @description A video calling provider must call this endpoint after a user has installed the video calling app so that the new user's information is sent.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          user_provider_id: z.string(),
          user_id: z.number().int(),
          company_id: z.number().int(),
          marketplace_client_id: z.string(),
        }),
      },
    },
    responses: {
      /** @description User provider link was successfully created */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              message: z.string().optional(),
            }).optional(),
          }),
        },
      },
      /** @description No permission to create user provider link */
      401: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            message: z.string().optional(),
          }),
        },
      },
    },
  },
  deleteUserProviderLink: {
    /**
     * Delete the link between a user and the installed video call integration 
     * @description A video calling provider must call this endpoint to remove the link between a user and the installed video calling app.
     */
    parameters: {
        /** @description Unique identifier linking a user to the installed integration */
      path: z.object({
        id: z.string(),
      }),
    },
    responses: {
      /** @description User provider link successfully removed */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              message: z.string().optional(),
            }).optional(),
          }),
        },
      },
      /** @description No permission to remove user provider link */
      401: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            message: z.string().optional(),
          }),
        },
      },
      /** @description Incorrect parameter provided */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            message: z.string().optional(),
          }),
        },
      },
    },
  },
  getNotes: {
    /**
     * Get all notes 
     * @description Returns all notes.
     */
    parameters: {
        /** @description The ID of the user whose notes to fetch. If omitted, notes by all users will be returned. */
        /** @description The ID of the lead which notes to fetch. If omitted, notes about all leads will be returned. */
        /** @description The ID of the deal which notes to fetch. If omitted, notes about all deals will be returned. */
        /** @description The ID of the person whose notes to fetch. If omitted, notes about all persons will be returned. */
        /** @description The ID of the organization which notes to fetch. If omitted, notes about all organizations will be returned. */
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys). Supported fields: `id`, `user_id`, `deal_id`, `person_id`, `org_id`, `content`, `add_time`, `update_time`. */
        /** @description The date in format of YYYY-MM-DD from which notes to fetch */
        /** @description The date in format of YYYY-MM-DD until which notes to fetch to */
        /** @description If set, the results are filtered by note to lead pinning state */
        /** @description If set, the results are filtered by note to deal pinning state */
        /** @description If set, the results are filtered by note to organization pinning state */
        /** @description If set, the results are filtered by note to person pinning state */
      query: z.object({
        user_id: z.number().int().optional(),
        lead_id: z.string().optional(),
        deal_id: z.number().int().optional(),
        person_id: z.number().int().optional(),
        org_id: z.number().int().optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        sort: z.string().optional(),
        start_date: z.string().optional(),
        end_date: z.string().optional(),
        pinned_to_lead_flag: z.number().optional(),
        pinned_to_deal_flag: z.number().optional(),
        pinned_to_organization_flag: z.number().optional(),
        pinned_to_person_flag: z.number().optional(),
      }).optional(),
    },
    responses: {
      /** @description Get all notes */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                add_time: z.string().optional(),
                content: z.string().optional(),
                deal: z.object({
                  title: z.string().optional(),
                }).optional(),
                lead_id: z.string().optional(),
                deal_id: z.number().int().optional(),
                last_update_user_id: z.number().int().optional(),
                org_id: z.number().int().optional(),
                organization: z.object({
                  name: z.string().optional(),
                }).optional(),
                person: z.object({
                  name: z.string().optional(),
                }).optional(),
                person_id: z.number().int().optional(),
                pinned_to_deal_flag: z.boolean().optional(),
                pinned_to_organization_flag: z.boolean().optional(),
                pinned_to_person_flag: z.boolean().optional(),
                update_time: z.string().optional(),
                user: z.object({
                  email: z.string().optional(),
                  icon_url: z.string().optional(),
                  is_you: z.boolean().optional(),
                  name: z.string().optional(),
                }).optional(),
                user_id: z.number().int().optional(),
              })).optional(),
            additional_data: z.object({
              pagination: z.intersection(z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
              }), z.object({
                next_start: z.number().int().optional(),
              })).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  addNote: {
    /**
     * Add a note 
     * @description Adds a new note.
     */
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          content: z.string(),
          lead_id: z.string().nullish(),
          deal_id: z.number().int().nullish(),
          person_id: z.number().int().nullish(),
          org_id: z.number().int().nullish(),
        }), z.object({
          user_id: z.number().int().nullish(),
          add_time: z.string().nullish(),
          pinned_to_lead_flag: z.number().nullish(),
          pinned_to_deal_flag: z.number().nullish(),
          pinned_to_organization_flag: z.number().nullish(),
          pinned_to_person_flag: z.number().nullish(),
        })),
      },
    },
    responses: {
      /** @description Add, update or get a note */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              add_time: z.string().optional(),
              content: z.string().optional(),
              deal: z.object({
                title: z.string().optional(),
              }).optional(),
              lead_id: z.string().optional(),
              deal_id: z.number().int().optional(),
              last_update_user_id: z.number().int().optional(),
              org_id: z.number().int().optional(),
              organization: z.object({
                name: z.string().optional(),
              }).optional(),
              person: z.object({
                name: z.string().optional(),
              }).optional(),
              person_id: z.number().int().optional(),
              pinned_to_deal_flag: z.boolean().optional(),
              pinned_to_organization_flag: z.boolean().optional(),
              pinned_to_person_flag: z.boolean().optional(),
              update_time: z.string().optional(),
              user: z.object({
                email: z.string().optional(),
                icon_url: z.string().optional(),
                is_you: z.boolean().optional(),
                name: z.string().optional(),
              }).optional(),
              user_id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getNote: {
    /**
     * Get one note 
     * @description Returns details about a specific note.
     */
    parameters: {
        /** @description The ID of the note */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Add, update or get a note */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              add_time: z.string().optional(),
              content: z.string().optional(),
              deal: z.object({
                title: z.string().optional(),
              }).optional(),
              lead_id: z.string().optional(),
              deal_id: z.number().int().optional(),
              last_update_user_id: z.number().int().optional(),
              org_id: z.number().int().optional(),
              organization: z.object({
                name: z.string().optional(),
              }).optional(),
              person: z.object({
                name: z.string().optional(),
              }).optional(),
              person_id: z.number().int().optional(),
              pinned_to_deal_flag: z.boolean().optional(),
              pinned_to_organization_flag: z.boolean().optional(),
              pinned_to_person_flag: z.boolean().optional(),
              update_time: z.string().optional(),
              user: z.object({
                email: z.string().optional(),
                icon_url: z.string().optional(),
                is_you: z.boolean().optional(),
                name: z.string().optional(),
              }).optional(),
              user_id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  updateNote: {
    /**
     * Update a note 
     * @description Updates a note.
     */
    parameters: {
        /** @description The ID of the note */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          content: z.string().nullish(),
        }), z.object({
          lead_id: z.string().nullish(),
          deal_id: z.number().int().nullish(),
          person_id: z.number().int().nullish(),
          org_id: z.number().int().nullish(),
        }), z.object({
          user_id: z.number().int().nullish(),
          add_time: z.string().nullish(),
          pinned_to_lead_flag: z.number().nullish(),
          pinned_to_deal_flag: z.number().nullish(),
          pinned_to_organization_flag: z.number().nullish(),
          pinned_to_person_flag: z.number().nullish(),
        })),
      },
    },
    responses: {
      /** @description Add, update or get a note */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              add_time: z.string().optional(),
              content: z.string().optional(),
              deal: z.object({
                title: z.string().optional(),
              }).optional(),
              lead_id: z.string().optional(),
              deal_id: z.number().int().optional(),
              last_update_user_id: z.number().int().optional(),
              org_id: z.number().int().optional(),
              organization: z.object({
                name: z.string().optional(),
              }).optional(),
              person: z.object({
                name: z.string().optional(),
              }).optional(),
              person_id: z.number().int().optional(),
              pinned_to_deal_flag: z.boolean().optional(),
              pinned_to_organization_flag: z.boolean().optional(),
              pinned_to_person_flag: z.boolean().optional(),
              update_time: z.string().optional(),
              user: z.object({
                email: z.string().optional(),
                icon_url: z.string().optional(),
                is_you: z.boolean().optional(),
                name: z.string().optional(),
              }).optional(),
              user_id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteNote: {
    /**
     * Delete a note 
     * @description Deletes a specific note.
     */
    parameters: {
        /** @description The ID of the note */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Delete a note */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.boolean().optional(),
          }),
        },
      },
    },
  },
  getNoteComments: {
    /**
     * Get all comments for a note 
     * @description Returns all comments associated with a note.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the note */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get all comments */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                uuid: z.string().optional(),
                active_flag: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                content: z.string().optional(),
                object_id: z.string().optional(),
                object_type: z.string().optional(),
                user_id: z.number().int().optional(),
                updater_id: z.number().int().optional(),
                company_id: z.number().int().optional(),
              })).optional(),
            additional_data: z.object({
              pagination: z.intersection(z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
              }), z.object({
                next_start: z.number().int().optional(),
              })).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  addNoteComment: {
    /**
     * Add a comment to a note 
     * @description Adds a new comment to a note.
     */
    parameters: {
        /** @description The ID of the note */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          content: z.string(),
        }),
      },
    },
    responses: {
      /** @description Add, update or get a comment */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              uuid: z.string().optional(),
              active_flag: z.boolean().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              content: z.string().optional(),
              object_id: z.string().optional(),
              object_type: z.string().optional(),
              user_id: z.number().int().optional(),
              updater_id: z.number().int().optional(),
              company_id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getComment: {
    /**
     * Get one comment 
     * @description Returns the details of a comment.
     */
    parameters: {
        /** @description The ID of the note */
        /** @description The ID of the comment */
      path: z.object({
        id: z.number().int(),
        commentId: z.string(),
      }),
    },
    responses: {
      /** @description Add, update or get a comment */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              uuid: z.string().optional(),
              active_flag: z.boolean().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              content: z.string().optional(),
              object_id: z.string().optional(),
              object_type: z.string().optional(),
              user_id: z.number().int().optional(),
              updater_id: z.number().int().optional(),
              company_id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  updateCommentForNote: {
    /**
     * Update a comment related to a note 
     * @description Updates a comment related to a note.
     */
    parameters: {
        /** @description The ID of the note */
        /** @description The ID of the comment */
      path: z.object({
        id: z.number().int(),
        commentId: z.string(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          content: z.string(),
        }),
      },
    },
    responses: {
      /** @description Add, update or get a comment */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              uuid: z.string().optional(),
              active_flag: z.boolean().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              content: z.string().optional(),
              object_id: z.string().optional(),
              object_type: z.string().optional(),
              user_id: z.number().int().optional(),
              updater_id: z.number().int().optional(),
              company_id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteComment: {
    /**
     * Delete a comment related to a note 
     * @description Deletes a comment.
     */
    parameters: {
        /** @description The ID of the note */
        /** @description The ID of the comment */
      path: z.object({
        id: z.number().int(),
        commentId: z.string(),
      }),
    },
    responses: {
      /** @description Delete a comment */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.boolean().optional(),
          }),
        },
      },
    },
  },
  getNoteFields: {
    /**
     * Get all note fields 
     * @description Returns data about all note fields.
     */
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                key: z.string().optional(),
                name: z.string().optional(),
                field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
                active_flag: z.boolean().optional(),
                edit_flag: z.boolean().optional(),
                bulk_edit_allowed: z.boolean().optional(),
                mandatory_flag: z.boolean().optional(),
                options: z.array(z.object({
                    id: z.number().int().optional(),
                    label: z.string().optional(),
                  })).optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getOrganizations: {
    /**
     * Get all organizations 
     * @description Returns all organizations.
     */
    parameters: {
        /** @description If supplied, only organizations owned by the given user will be returned. However, `filter_id` takes precedence over `user_id` when both are supplied. */
        /** @description The ID of the filter to use */
        /** @description If supplied, only organizations whose name starts with the specified letter will be returned (case-insensitive) */
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys). */
      query: z.object({
        user_id: z.number().int().optional(),
        filter_id: z.number().int().optional(),
        first_char: z.string().optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        sort: z.string().optional(),
      }).optional(),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                company_id: z.number().int().optional(),
                owner_id: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                name: z.string().optional(),
                active_flag: z.boolean().optional(),
                picture_id: z.intersection(z.object({
                  value: z.number().int().optional(),
                }), z.object({
                  item_type: z.string().optional(),
                  item_id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  added_by_user_id: z.number().int().optional(),
                  pictures: z.object({
                    128: z.string().optional(),
                    512: z.string().optional(),
                  }).optional(),
                })).optional(),
                country_code: z.string().optional(),
                first_char: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                visible_to: z.string().optional(),
                label: z.number().int().optional(),
                owner_name: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.intersection(z.intersection(z.object({
                email_messages_count: z.number().int().optional(),
                people_count: z.number().int().optional(),
                activities_count: z.number().int().optional(),
                done_activities_count: z.number().int().optional(),
                undone_activities_count: z.number().int().optional(),
                files_count: z.number().int().optional(),
                notes_count: z.number().int().optional(),
                followers_count: z.number().int().optional(),
              }), z.object({
                address: z.string().optional(),
                address_subpremise: z.string().optional(),
                address_street_number: z.string().optional(),
                address_route: z.string().optional(),
                address_sublocality: z.string().optional(),
                address_locality: z.string().optional(),
                address_admin_area_level_1: z.string().optional(),
                address_admin_area_level_2: z.string().optional(),
                address_country: z.string().optional(),
                address_postal_code: z.string().optional(),
                address_formatted_address: z.string().optional(),
              })), z.intersection(z.object({
                open_deals_count: z.number().int().optional(),
                related_open_deals_count: z.number().int().optional(),
                closed_deals_count: z.number().int().optional(),
                related_closed_deals_count: z.number().int().optional(),
                won_deals_count: z.number().int().optional(),
                related_won_deals_count: z.number().int().optional(),
                lost_deals_count: z.number().int().optional(),
                related_lost_deals_count: z.number().int().optional(),
              }), z.object({
                next_activity_date: z.string().nullable().optional(),
                next_activity_time: z.string().nullable().optional(),
                next_activity_id: z.number().int().nullable().optional(),
                last_activity_id: z.number().int().nullable().optional(),
                last_activity_date: z.string().nullable().optional(),
              }))))).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
                next_start: z.number().int().optional(),
              }).optional(),
            }).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              picture: z.object({
                PICTURE_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  item_type: z.string().optional(),
                  item_id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  added_by_user_id: z.number().int().optional(),
                  pictures: z.object({
                    128: z.string().optional(),
                    512: z.string().optional(),
                  }).optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addOrganization: {
    /**
     * Add an organization 
     * @description Adds a new organization. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the organizationFields and look for `key` values. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-an-organization" target="_blank" rel="noopener noreferrer">adding an organization</a>.
     */
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          name: z.string(),
          add_time: z.string().nullish(),
        }), z.object({
          owner_id: z.number().int().nullish(),
          label: z.number().int().nullish(),
          visible_to: z.string().nullish(),
        })),
      },
    },
    responses: {
      /** @description Success */
      201: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.intersection(z.object({
              id: z.number().int().optional(),
              company_id: z.number().int().optional(),
              owner_id: z.intersection(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.string().optional(),
                has_pic: z.number().int().optional(),
                pic_hash: z.string().nullable().optional(),
                active_flag: z.boolean().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              name: z.string().optional(),
              active_flag: z.boolean().optional(),
              picture_id: z.intersection(z.object({
                value: z.number().int().optional(),
              }), z.object({
                item_type: z.string().optional(),
                item_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                added_by_user_id: z.number().int().optional(),
                pictures: z.object({
                  128: z.string().optional(),
                  512: z.string().optional(),
                }).optional(),
              })).optional(),
              country_code: z.string().optional(),
              first_char: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.string().optional(),
              label: z.number().int().optional(),
              owner_name: z.string().optional(),
              cc_email: z.string().optional(),
            }), z.intersection(z.intersection(z.object({
              email_messages_count: z.number().int().optional(),
              people_count: z.number().int().optional(),
              activities_count: z.number().int().optional(),
              done_activities_count: z.number().int().optional(),
              undone_activities_count: z.number().int().optional(),
              files_count: z.number().int().optional(),
              notes_count: z.number().int().optional(),
              followers_count: z.number().int().optional(),
            }), z.object({
              address: z.string().optional(),
              address_subpremise: z.string().optional(),
              address_street_number: z.string().optional(),
              address_route: z.string().optional(),
              address_sublocality: z.string().optional(),
              address_locality: z.string().optional(),
              address_admin_area_level_1: z.string().optional(),
              address_admin_area_level_2: z.string().optional(),
              address_country: z.string().optional(),
              address_postal_code: z.string().optional(),
              address_formatted_address: z.string().optional(),
            })), z.intersection(z.object({
              open_deals_count: z.number().int().optional(),
              related_open_deals_count: z.number().int().optional(),
              closed_deals_count: z.number().int().optional(),
              related_closed_deals_count: z.number().int().optional(),
              won_deals_count: z.number().int().optional(),
              related_won_deals_count: z.number().int().optional(),
              lost_deals_count: z.number().int().optional(),
              related_lost_deals_count: z.number().int().optional(),
            }), z.object({
              next_activity_date: z.string().nullable().optional(),
              next_activity_time: z.string().nullable().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              last_activity_id: z.number().int().nullable().optional(),
              last_activity_date: z.string().nullable().optional(),
            })))), z.object({
              edit_name: z.boolean().optional(),
            })).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              picture: z.object({
                PICTURE_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  item_type: z.string().optional(),
                  item_id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  added_by_user_id: z.number().int().optional(),
                  pictures: z.object({
                    128: z.string().optional(),
                    512: z.string().optional(),
                  }).optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteOrganizations: {
    /**
     * Delete multiple organizations in bulk 
     * @description Marks multiple organizations as deleted. After 30 days, the organizations will be permanently deleted.
     */
    parameters: {
        /** @description The comma-separated IDs that will be deleted */
      query: z.object({
        ids: z.string(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.array(z.number()).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getOrganizationsCollection: {
    /**
     * Get all organizations (BETA) 
     * @description Returns all organizations. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href="https://support.pipedrive.com/en/article/global-user-management" target="_blank" rel="noopener noreferrer">here</a>.
     */
    parameters: {
        /** @description For pagination, the marker (an opaque string value) representing the first item on the next page */
        /** @description For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed. */
        /** @description The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field. */
        /** @description The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field. */
        /** @description If supplied, only organizations owned by the given user will be returned */
        /** @description If supplied, only organizations whose name starts with the specified letter will be returned (case-insensitive) */
      query: z.object({
        cursor: z.string().optional(),
        limit: z.number().int().optional(),
        since: z.string().optional(),
        until: z.string().optional(),
        owner_id: z.number().int().optional(),
        first_char: z.string().optional(),
      }).optional(),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                address: z.string().optional(),
                address_subpremise: z.string().optional(),
                address_street_number: z.string().optional(),
                address_route: z.string().optional(),
                address_sublocality: z.string().optional(),
                address_locality: z.string().optional(),
                address_admin_area_level_1: z.string().optional(),
                address_admin_area_level_2: z.string().optional(),
                address_country: z.string().optional(),
                address_postal_code: z.string().optional(),
                address_formatted_address: z.string().optional(),
              }), z.object({
                id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                owner_id: z.number().int().optional(),
                name: z.string().optional(),
                update_time: z.string().optional(),
                delete_time: z.string().nullable().optional(),
                add_time: z.string().optional(),
                visible_to: z.string().optional(),
                label: z.number().int().nullable().optional(),
                cc_email: z.string().optional(),
              }))).optional(),
            additional_data: z.object({
              next_cursor: z.string().optional(),
            }).optional(),
          }),
        },
      },
      /** @description Forbidden response */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  searchOrganization: {
    /**
     * Search organizations 
     * @description Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href="https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem">/v1/itemSearch</a> with a narrower OAuth scope.
     */
    parameters: {
        /** @description The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded. */
        /** @description A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: `address`, `varchar`, `text`, `varchar_auto`, `double`, `monetary` and `phone`. Read more about searching by custom fields <a href="https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields" target="_blank" rel="noopener noreferrer">here</a>. */
        /** @description When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive. */
        /** @description Pagination start. Note that the pagination is based on main results and does not include related items when using `search_for_related_items` parameter. */
        /** @description Items shown per page */
      query: z.object({
        term: z.string(),
        fields: z.enum(["address", "custom_fields", "notes", "name"]).optional(),
        exact_match: z.boolean().optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              items: z.array(z.object({
                  result_score: z.number().optional(),
                  item: z.object({
                    id: z.number().int().optional(),
                    type: z.string().optional(),
                    name: z.string().optional(),
                    address: z.string().optional(),
                    visible_to: z.number().int().optional(),
                    owner: z.object({
                      id: z.number().int().optional(),
                    }).optional(),
                    custom_fields: z.array(z.string()).optional(),
                    notes: z.array(z.string()).optional(),
                  }).optional(),
                })).optional(),
            }).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
                next_start: z.number().int().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getOrganization: {
    /**
     * Get details of an organization 
     * @description Returns the details of an organization. Note that this also returns some additional fields which are not present when asking for all organizations. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of organizationFields.
     */
    parameters: {
        /** @description The ID of the organization */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.intersection(z.intersection(z.object({
              id: z.number().int().optional(),
              company_id: z.number().int().optional(),
              owner_id: z.intersection(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.string().optional(),
                has_pic: z.number().int().optional(),
                pic_hash: z.string().nullable().optional(),
                active_flag: z.boolean().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              name: z.string().optional(),
              active_flag: z.boolean().optional(),
              picture_id: z.intersection(z.object({
                value: z.number().int().optional(),
              }), z.object({
                item_type: z.string().optional(),
                item_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                added_by_user_id: z.number().int().optional(),
                pictures: z.object({
                  128: z.string().optional(),
                  512: z.string().optional(),
                }).optional(),
              })).optional(),
              country_code: z.string().optional(),
              first_char: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.string().optional(),
              label: z.number().int().optional(),
              owner_name: z.string().optional(),
              cc_email: z.string().optional(),
            }), z.intersection(z.intersection(z.object({
              email_messages_count: z.number().int().optional(),
              people_count: z.number().int().optional(),
              activities_count: z.number().int().optional(),
              done_activities_count: z.number().int().optional(),
              undone_activities_count: z.number().int().optional(),
              files_count: z.number().int().optional(),
              notes_count: z.number().int().optional(),
              followers_count: z.number().int().optional(),
            }), z.object({
              address: z.string().optional(),
              address_subpremise: z.string().optional(),
              address_street_number: z.string().optional(),
              address_route: z.string().optional(),
              address_sublocality: z.string().optional(),
              address_locality: z.string().optional(),
              address_admin_area_level_1: z.string().optional(),
              address_admin_area_level_2: z.string().optional(),
              address_country: z.string().optional(),
              address_postal_code: z.string().optional(),
              address_formatted_address: z.string().optional(),
            })), z.intersection(z.object({
              open_deals_count: z.number().int().optional(),
              related_open_deals_count: z.number().int().optional(),
              closed_deals_count: z.number().int().optional(),
              related_closed_deals_count: z.number().int().optional(),
              won_deals_count: z.number().int().optional(),
              related_won_deals_count: z.number().int().optional(),
              lost_deals_count: z.number().int().optional(),
              related_lost_deals_count: z.number().int().optional(),
            }), z.object({
              next_activity_date: z.string().nullable().optional(),
              next_activity_time: z.string().nullable().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              last_activity_id: z.number().int().nullable().optional(),
              last_activity_date: z.string().nullable().optional(),
            })))), z.object({
              edit_name: z.boolean().optional(),
            })), z.object({
              last_activity: z.record(z.unknown()).nullable().optional(),
              next_activity: z.record(z.unknown()).nullable().optional(),
            })).optional(),
            additional_data: z.object({
              followers: z.object({
                FOLLOWER_USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  email: z.string().optional(),
                  user_id: z.number().int().optional(),
                  pic_hash: z.string().optional(),
                })).optional(),
              }).optional(),
              dropbox_email: z.string().optional(),
            }).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              picture: z.object({
                PICTURE_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  item_type: z.string().optional(),
                  item_id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  added_by_user_id: z.number().int().optional(),
                  pictures: z.object({
                    128: z.string().optional(),
                    512: z.string().optional(),
                  }).optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  updateOrganization: {
    /**
     * Update an organization 
     * @description Updates the properties of an organization.
     */
    parameters: {
        /** @description The ID of the organization */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          name: z.string().nullish(),
        }), z.object({
          owner_id: z.number().int().nullish(),
          label: z.number().int().nullish(),
          visible_to: z.string().nullish(),
        })),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              company_id: z.number().int().optional(),
              owner_id: z.intersection(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.string().optional(),
                has_pic: z.number().int().optional(),
                pic_hash: z.string().nullable().optional(),
                active_flag: z.boolean().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              name: z.string().optional(),
              active_flag: z.boolean().optional(),
              picture_id: z.intersection(z.object({
                value: z.number().int().optional(),
              }), z.object({
                item_type: z.string().optional(),
                item_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                added_by_user_id: z.number().int().optional(),
                pictures: z.object({
                  128: z.string().optional(),
                  512: z.string().optional(),
                }).optional(),
              })).optional(),
              country_code: z.string().optional(),
              first_char: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.string().optional(),
              label: z.number().int().optional(),
              owner_name: z.string().optional(),
              cc_email: z.string().optional(),
            }), z.intersection(z.intersection(z.object({
              email_messages_count: z.number().int().optional(),
              people_count: z.number().int().optional(),
              activities_count: z.number().int().optional(),
              done_activities_count: z.number().int().optional(),
              undone_activities_count: z.number().int().optional(),
              files_count: z.number().int().optional(),
              notes_count: z.number().int().optional(),
              followers_count: z.number().int().optional(),
            }), z.object({
              address: z.string().optional(),
              address_subpremise: z.string().optional(),
              address_street_number: z.string().optional(),
              address_route: z.string().optional(),
              address_sublocality: z.string().optional(),
              address_locality: z.string().optional(),
              address_admin_area_level_1: z.string().optional(),
              address_admin_area_level_2: z.string().optional(),
              address_country: z.string().optional(),
              address_postal_code: z.string().optional(),
              address_formatted_address: z.string().optional(),
            })), z.intersection(z.object({
              open_deals_count: z.number().int().optional(),
              related_open_deals_count: z.number().int().optional(),
              closed_deals_count: z.number().int().optional(),
              related_closed_deals_count: z.number().int().optional(),
              won_deals_count: z.number().int().optional(),
              related_won_deals_count: z.number().int().optional(),
              lost_deals_count: z.number().int().optional(),
              related_lost_deals_count: z.number().int().optional(),
            }), z.object({
              next_activity_date: z.string().nullable().optional(),
              next_activity_time: z.string().nullable().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              last_activity_id: z.number().int().nullable().optional(),
              last_activity_date: z.string().nullable().optional(),
            })))).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              picture: z.object({
                PICTURE_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  item_type: z.string().optional(),
                  item_id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  added_by_user_id: z.number().int().optional(),
                  pictures: z.object({
                    128: z.string().optional(),
                    512: z.string().optional(),
                  }).optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteOrganization: {
    /**
     * Delete an organization 
     * @description Marks an organization as deleted. After 30 days, the organization will be permanently deleted.
     */
    parameters: {
        /** @description The ID of the organization */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getOrganizationActivities: {
    /**
     * List activities associated with an organization 
     * @description Lists activities associated with an organization.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description Whether the activity is done or not. 0 = Not done, 1 = Done. If omitted returns both Done and Not done activities. */
        /** @description A comma-separated string of activity IDs to exclude from result */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        done: z.number().optional(),
        exclude: z.string().optional(),
      }).optional(),
        /** @description The ID of the organization */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                due_date: z.string().optional(),
                due_time: z.string().optional(),
                duration: z.string().optional(),
                deal_id: z.number().int().optional(),
                lead_id: z.string().nullable().optional(),
                person_id: z.number().int().optional(),
                project_id: z.number().int().nullable().optional(),
                org_id: z.number().int().optional(),
                location: z.string().optional(),
                public_description: z.string().optional(),
              }), z.object({
                id: z.number().int().optional(),
                note: z.string().optional(),
                done: z.boolean().optional(),
                subject: z.string().optional(),
                type: z.string().optional(),
                user_id: z.number().int().optional(),
                participants: z.array(z.record(z.any())).nullable().optional(),
                busy_flag: z.boolean().optional(),
                attendees: z.array(z.record(z.any())).nullable().optional(),
                company_id: z.number().int().optional(),
                reference_type: z.string().optional(),
                reference_id: z.number().int().optional(),
                conference_meeting_client: z.string().optional(),
                conference_meeting_url: z.string().optional(),
                conference_meeting_id: z.string().optional(),
                add_time: z.string().optional(),
                marked_as_done_time: z.string().optional(),
                last_notification_time: z.string().optional(),
                last_notification_user_id: z.number().int().optional(),
                notification_language_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                update_time: z.string().optional(),
                update_user_id: z.number().int().optional(),
                gcal_event_id: z.string().optional(),
                google_calendar_id: z.string().optional(),
                google_calendar_etag: z.string().optional(),
                calendar_sync_include_context: z.string().optional(),
                source_timezone: z.string().optional(),
                rec_rule: z.string().optional(),
                rec_rule_extension: z.string().optional(),
                rec_master_activity_id: z.number().int().optional(),
                series: z.array(z.record(z.any())).optional(),
                created_by_user_id: z.number().int().optional(),
                location_subpremise: z.string().optional(),
                location_street_number: z.string().optional(),
                location_route: z.string().optional(),
                location_sublocality: z.string().optional(),
                location_locality: z.string().optional(),
                location_admin_area_level_1: z.string().optional(),
                location_admin_area_level_2: z.string().optional(),
                location_country: z.string().optional(),
                location_postal_code: z.string().optional(),
                location_formatted_address: z.string().optional(),
                org_name: z.string().optional(),
                person_name: z.string().optional(),
                deal_title: z.string().optional(),
                owner_name: z.string().optional(),
                person_dropbox_bcc: z.string().optional(),
                deal_dropbox_bcc: z.string().optional(),
                assigned_to_user_id: z.number().int().optional(),
                file: z.record(z.any()).optional(),
              }))).optional(),
            additional_data: z.intersection(z.object({
              activity_distribution: z.object({
                ASSIGNED_TO_USER_ID: z.object({
                  activities: z.object({
                    ACTIVITY_TYPE_NAME: z.number().int().optional(),
                  }).optional(),
                  name: z.string().optional(),
                  activity_count: z.number().int().optional(),
                  share: z.number().int().optional(),
                }).optional(),
              }).optional(),
            }), z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            })).optional(),
          })),
        },
      },
    },
  },
  getOrganizationDeals: {
    /**
     * List deals associated with an organization 
     * @description Lists deals associated with an organization.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. */
        /** @description The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys). */
        /** @description If set, only deals that are directly associated to the organization are fetched. If not set (default), all deals are fetched that are either directly or indirectly related to the organization. Indirect relations include relations through custom, organization-type fields and through persons of the given organization. */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        status: z.enum(["open", "won", "lost", "deleted", "all_not_deleted"]).optional(),
        sort: z.string().optional(),
        only_primary_association: z.number().optional(),
      }).optional(),
        /** @description The ID of the organization */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                creator_user_id: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.boolean().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                  value: z.number().int().optional(),
                }).optional(),
                user_id: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.boolean().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                person_id: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                org_id: z.intersection(z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  active_flag: z.boolean().optional(),
                  cc_email: z.string().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
              }), z.object({
                stage_id: z.number().int().optional(),
                title: z.string().optional(),
                value: z.number().optional(),
                currency: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                stage_change_time: z.string().optional(),
                active: z.boolean().optional(),
                deleted: z.boolean().optional(),
                status: z.string().optional(),
                probability: z.number().nullable().optional(),
                next_activity_date: z.string().optional(),
                next_activity_time: z.string().optional(),
                next_activity_id: z.number().int().nullable().optional(),
                last_activity_id: z.number().int().nullable().optional(),
                last_activity_date: z.string().nullable().optional(),
                lost_reason: z.string().nullable().optional(),
                visible_to: z.string().optional(),
                close_time: z.string().nullable().optional(),
                pipeline_id: z.number().int().optional(),
                won_time: z.string().optional(),
                first_won_time: z.string().optional(),
                lost_time: z.string().optional(),
                products_count: z.number().int().optional(),
                files_count: z.number().int().optional(),
                notes_count: z.number().int().optional(),
                followers_count: z.number().int().optional(),
                email_messages_count: z.number().int().optional(),
                activities_count: z.number().int().optional(),
                done_activities_count: z.number().int().optional(),
                undone_activities_count: z.number().int().optional(),
                participants_count: z.number().int().optional(),
                expected_close_date: z.string().optional(),
                last_incoming_mail_time: z.string().optional(),
                last_outgoing_mail_time: z.string().optional(),
                label: z.string().optional(),
                stage_order_nr: z.number().int().optional(),
                person_name: z.string().optional(),
                org_name: z.string().optional(),
                next_activity_subject: z.string().optional(),
                next_activity_type: z.string().optional(),
                next_activity_duration: z.string().optional(),
                next_activity_note: z.string().optional(),
                formatted_value: z.string().optional(),
                weighted_value: z.number().optional(),
                formatted_weighted_value: z.string().optional(),
                weighted_value_currency: z.string().optional(),
                rotten_time: z.string().nullable().optional(),
                owner_name: z.string().optional(),
                cc_email: z.string().optional(),
                org_hidden: z.boolean().optional(),
                person_hidden: z.boolean().optional(),
              }))).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }))).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              stage: z.object({
                id: z.number().int().optional(),
                order_nr: z.number().int().optional(),
                name: z.string().optional(),
                active_flag: z.boolean().optional(),
                deal_probability: z.number().int().optional(),
                pipeline_id: z.number().int().optional(),
                rotten_flag: z.boolean().optional(),
                rotten_days: z.number().int().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              }).optional(),
              pipeline: z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                url_title: z.string().optional(),
                order_nr: z.number().int().optional(),
                active: z.boolean().optional(),
                deal_probability: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getOrganizationFiles: {
    /**
     * List files attached to an organization 
     * @description Lists files associated with an organization.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys). Supported fields: `id`, `user_id`, `deal_id`, `person_id`, `org_id`, `product_id`, `add_time`, `update_time`, `file_name`, `file_type`, `file_size`, `comment`. */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        sort: z.string().optional(),
      }).optional(),
        /** @description The ID of the organization */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                user_id: z.number().int().optional(),
                deal_id: z.number().int().optional(),
                person_id: z.number().int().optional(),
                org_id: z.number().int().optional(),
                product_id: z.number().int().optional(),
                activity_id: z.number().int().optional(),
                lead_id: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                file_name: z.string().optional(),
                file_size: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                inline_flag: z.boolean().optional(),
                remote_location: z.string().optional(),
                remote_id: z.string().optional(),
                cid: z.string().optional(),
                s3_bucket: z.string().optional(),
                mail_message_id: z.string().optional(),
                mail_template_id: z.string().optional(),
                deal_name: z.string().optional(),
                person_name: z.string().optional(),
                org_name: z.string().optional(),
                product_name: z.string().optional(),
                lead_name: z.string().optional(),
                url: z.string().optional(),
                name: z.string().optional(),
                description: z.string().optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getOrganizationUpdates: {
    /**
     * List updates about an organization 
     * @description Lists updates about an organization.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description Whether to show custom field updates or not. 1 = Include custom field changes. If omitted, returns changes without custom field updates. */
        /** @description A comma-separated string for filtering out item specific updates. (Possible values - activity, plannedActivity, note, file, change, deal, follower, participant, mailMessage, mailMessageWithAttachment, invoice, activityFile, document). */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        all_changes: z.string().optional(),
        items: z.string().optional(),
      }).optional(),
        /** @description The ID of the organization */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get the organization updates */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                object: z.string().optional(),
                timestamp: z.string().optional(),
                data: z.record(z.any()).optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getOrganizationFollowers: {
    /**
     * List followers of an organization 
     * @description Lists the followers of an organization.
     */
    parameters: {
        /** @description The ID of the organization */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                org_id: z.number().int().optional(),
              }), z.object({
                user_id: z.number().int().optional(),
                id: z.number().int().optional(),
                add_time: z.string().optional(),
              }))).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
                next_start: z.number().int().optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  addOrganizationFollower: {
    /**
     * Add a follower to an organization 
     * @description Adds a follower to an organization.
     */
    parameters: {
        /** @description The ID of the organization */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          user_id: z.number().int(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              org_id: z.number().int().optional(),
            }), z.object({
              user_id: z.number().int().optional(),
              id: z.number().int().optional(),
              add_time: z.string().optional(),
            })).optional(),
          }),
        },
      },
    },
  },
  deleteOrganizationFollower: {
    /**
     * Delete a follower from an organization 
     * @description Deletes a follower from an organization. You can retrieve the `follower_id` from the <a href="https://developers.pipedrive.com/docs/api/v1/Organizations#getOrganizationFollowers">List followers of an organization</a> endpoint.
     */
    parameters: {
        /** @description The ID of the organization */
        /** @description The ID of the follower */
      path: z.object({
        id: z.number().int(),
        follower_id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getOrganizationMailMessages: {
    /**
     * List mail messages associated with an organization 
     * @description Lists mail messages associated with an organization.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the organization */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                object: z.string().optional(),
                timestamp: z.string().optional(),
                data: z.intersection(z.object({
                  id: z.number().int().optional(),
                  from: z.array(z.object({
                      id: z.number().int().optional(),
                      email_address: z.string().optional(),
                      name: z.string().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                    })).optional(),
                  to: z.array(z.object({
                      id: z.number().int().optional(),
                      email_address: z.string().optional(),
                      name: z.string().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                    })).optional(),
                  cc: z.array(z.object({
                      id: z.number().int().optional(),
                      email_address: z.string().optional(),
                      name: z.string().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                    })).optional(),
                  bcc: z.array(z.object({
                      id: z.number().int().optional(),
                      email_address: z.string().optional(),
                      name: z.string().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                    })).optional(),
                  body_url: z.string().optional(),
                  account_id: z.string().optional(),
                  user_id: z.number().int().optional(),
                  mail_thread_id: z.number().int().optional(),
                  subject: z.string().optional(),
                  snippet: z.string().optional(),
                  mail_tracking_status: z.enum(["opened", "not opened"]).nullable().optional(),
                  mail_link_tracking_enabled_flag: z.number().optional(),
                  read_flag: z.number().optional(),
                  draft: z.string().optional(),
                  draft_flag: z.number().optional(),
                  synced_flag: z.number().optional(),
                  deleted_flag: z.number().optional(),
                  has_body_flag: z.number().optional(),
                  sent_flag: z.number().optional(),
                  sent_from_pipedrive_flag: z.number().optional(),
                  smart_bcc_flag: z.number().optional(),
                  message_time: z.string().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  has_attachments_flag: z.number().optional(),
                  has_inline_attachments_flag: z.number().optional(),
                  has_real_attachments_flag: z.number().optional(),
                }), z.object({
                  nylas_id: z.string().optional(),
                  s3_bucket: z.string().optional(),
                  s3_bucket_path: z.string().optional(),
                  external_deleted_flag: z.boolean().optional(),
                  mua_message_id: z.string().optional(),
                  template_id: z.number().int().optional(),
                  timestamp: z.string().optional(),
                  item_type: z.string().optional(),
                  company_id: z.number().int().optional(),
                })).optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  mergeOrganizations: {
    /**
     * Merge two organizations 
     * @description Merges an organization with another organization. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/merging-two-organizations" target="_blank" rel="noopener noreferrer">merging two organizations</a>.
     */
    parameters: {
        /** @description The ID of the organization */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          merge_with_id: z.number().int(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getOrganizationUsers: {
    /**
     * List permitted users 
     * @description List users permitted to access an organization.
     */
    parameters: {
        /** @description The ID of the organization */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.number()).optional(),
          })),
        },
      },
    },
  },
  getOrganizationPersons: {
    /**
     * List persons of an organization 
     * @description Lists persons associated with an organization.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the organization */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                company_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                phone: z.array(z.object({
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                    label: z.string().optional(),
                  })).optional(),
                email: z.array(z.object({
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                    label: z.string().optional(),
                  })).optional(),
                first_char: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                visible_to: z.string().optional(),
                picture_id: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  item_type: z.string().optional(),
                  item_id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  added_by_user_id: z.number().int().optional(),
                  pictures: z.object({
                    128: z.string().optional(),
                    512: z.string().optional(),
                  }).optional(),
                })).optional(),
                label: z.number().int().optional(),
                org_name: z.string().optional(),
                owner_name: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.intersection(z.intersection(z.object({
                owner_id: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                org_id: z.intersection(z.intersection(z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })), z.object({
                  active_flag: z.boolean().optional(),
                })).optional(),
              }), z.object({
                name: z.string().optional(),
                first_name: z.string().optional(),
                last_name: z.string().optional(),
              })), z.intersection(z.intersection(z.object({
                email_messages_count: z.number().int().optional(),
                activities_count: z.number().int().optional(),
                done_activities_count: z.number().int().optional(),
                undone_activities_count: z.number().int().optional(),
                files_count: z.number().int().optional(),
                notes_count: z.number().int().optional(),
                followers_count: z.number().int().optional(),
              }), z.object({
                last_incoming_mail_time: z.string().optional(),
                last_outgoing_mail_time: z.string().optional(),
              })), z.intersection(z.object({
                open_deals_count: z.number().int().optional(),
                related_open_deals_count: z.number().int().optional(),
                closed_deals_count: z.number().int().optional(),
                related_closed_deals_count: z.number().int().optional(),
                won_deals_count: z.number().int().optional(),
                related_won_deals_count: z.number().int().optional(),
                lost_deals_count: z.number().int().optional(),
                related_lost_deals_count: z.number().int().optional(),
              }), z.object({
                next_activity_date: z.string().nullable().optional(),
                next_activity_time: z.string().nullable().optional(),
                next_activity_id: z.number().int().nullable().optional(),
                last_activity_id: z.number().int().nullable().optional(),
                last_activity_date: z.string().nullable().optional(),
              })))))).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }))).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getOrganizationFields: {
    /**
     * Get all organization fields 
     * @description Returns data about all organization fields.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                key: z.string().optional(),
                name: z.string().optional(),
                order_nr: z.number().int().optional(),
                field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                last_updated_by_user_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                edit_flag: z.boolean().optional(),
                index_visible_flag: z.boolean().optional(),
                details_visible_flag: z.boolean().optional(),
                add_visible_flag: z.boolean().optional(),
                important_flag: z.boolean().optional(),
                bulk_edit_allowed: z.boolean().optional(),
                searchable_flag: z.boolean().optional(),
                filtering_allowed: z.boolean().optional(),
                sortable_flag: z.boolean().optional(),
                mandatory_flag: z.boolean().optional(),
                options: z.array(z.record(z.any())).nullable().optional(),
                options_deleted: z.array(z.record(z.any())).optional(),
                is_subfield: z.boolean().optional(),
                subfields: z.array(z.record(z.any())).optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addOrganizationField: {
    /**
     * Add a new organization field 
     * @description Adds a new organization field. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-new-custom-field" target="_blank" rel="noopener noreferrer">adding a new custom field</a>.
     */
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          name: z.string(),
          options: z.array(z.record(z.any())).nullish(),
          add_visible_flag: z.boolean().nullish(),
        }), z.object({
          field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]),
        })),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              key: z.string().optional(),
              name: z.string().optional(),
              order_nr: z.number().int().optional(),
              field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              last_updated_by_user_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              edit_flag: z.boolean().optional(),
              index_visible_flag: z.boolean().optional(),
              details_visible_flag: z.boolean().optional(),
              add_visible_flag: z.boolean().optional(),
              important_flag: z.boolean().optional(),
              bulk_edit_allowed: z.boolean().optional(),
              searchable_flag: z.boolean().optional(),
              filtering_allowed: z.boolean().optional(),
              sortable_flag: z.boolean().optional(),
              mandatory_flag: z.boolean().optional(),
              options: z.array(z.record(z.any())).nullable().optional(),
              options_deleted: z.array(z.record(z.any())).optional(),
              is_subfield: z.boolean().optional(),
              subfields: z.array(z.record(z.any())).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteOrganizationFields: {
    /**
     * Delete multiple organization fields in bulk 
     * @description Marks multiple fields as deleted.
     */
    parameters: {
        /** @description The comma-separated field IDs to delete */
      query: z.object({
        ids: z.string(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.array(z.number().int()).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getOrganizationField: {
    /**
     * Get one organization field 
     * @description Returns data about a specific organization field.
     */
    parameters: {
        /** @description The ID of the field */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              key: z.string().optional(),
              name: z.string().optional(),
              order_nr: z.number().int().optional(),
              field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              last_updated_by_user_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              edit_flag: z.boolean().optional(),
              index_visible_flag: z.boolean().optional(),
              details_visible_flag: z.boolean().optional(),
              add_visible_flag: z.boolean().optional(),
              important_flag: z.boolean().optional(),
              bulk_edit_allowed: z.boolean().optional(),
              searchable_flag: z.boolean().optional(),
              filtering_allowed: z.boolean().optional(),
              sortable_flag: z.boolean().optional(),
              mandatory_flag: z.boolean().optional(),
              options: z.array(z.record(z.any())).nullable().optional(),
              options_deleted: z.array(z.record(z.any())).optional(),
              is_subfield: z.boolean().optional(),
              subfields: z.array(z.record(z.any())).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  updateOrganizationField: {
    /**
     * Update an organization field 
     * @description Updates an organization field. For more information, see the tutorial for <a href=" https://pipedrive.readme.io/docs/updating-custom-field-value " target="_blank" rel="noopener noreferrer">updating custom fields' values</a>.
     */
    parameters: {
        /** @description The ID of the field */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string().nullish(),
          options: z.array(z.record(z.any())).nullish(),
          add_visible_flag: z.boolean().nullish(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              key: z.string().optional(),
              name: z.string().optional(),
              order_nr: z.number().int().optional(),
              field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              last_updated_by_user_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              edit_flag: z.boolean().optional(),
              index_visible_flag: z.boolean().optional(),
              details_visible_flag: z.boolean().optional(),
              add_visible_flag: z.boolean().optional(),
              important_flag: z.boolean().optional(),
              bulk_edit_allowed: z.boolean().optional(),
              searchable_flag: z.boolean().optional(),
              filtering_allowed: z.boolean().optional(),
              sortable_flag: z.boolean().optional(),
              mandatory_flag: z.boolean().optional(),
              options: z.array(z.record(z.any())).nullable().optional(),
              options_deleted: z.array(z.record(z.any())).optional(),
              is_subfield: z.boolean().optional(),
              subfields: z.array(z.record(z.any())).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteOrganizationField: {
    /**
     * Delete an organization field 
     * @description Marks a field as deleted. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/deleting-a-custom-field" target="_blank" rel="noopener noreferrer">deleting a custom field</a>.
     */
    parameters: {
        /** @description The ID of the field */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getOrganizationRelationships: {
    /**
     * Get all relationships for organization 
     * @description Gets all of the relationships for a supplied organization ID.
     */
    parameters: {
        /** @description The ID of the organization to get relationships for */
      query: z.object({
        org_id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.intersection(z.object({
                id: z.number().int().optional(),
                type: z.string().optional(),
                rel_owner_org_id: z.intersection(z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                rel_linked_org_id: z.intersection(z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                active_flag: z.string().optional(),
              }), z.object({
                calculated_type: z.string().optional(),
                calculated_related_org_id: z.number().int().optional(),
              })), z.object({
                related_organization_name: z.string().optional(),
              }))).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addOrganizationRelationship: {
    /**
     * Create an organization relationship 
     * @description Creates and returns an organization relationship.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          org_id: z.number().int().nullish(),
          type: z.enum(["parent", "related"]),
          rel_owner_org_id: z.number().int(),
          rel_linked_org_id: z.number().int(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              type: z.string().optional(),
              rel_owner_org_id: z.intersection(z.object({
                name: z.string().optional(),
                people_count: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                address: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              rel_linked_org_id: z.intersection(z.object({
                name: z.string().optional(),
                people_count: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                address: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              active_flag: z.string().optional(),
            }).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getOrganizationRelationship: {
    /**
     * Get one organization relationship 
     * @description Finds and returns an organization relationship from its ID.
     */
    parameters: {
        /** @description The ID of the base organization for the returned calculated values */
      query: z.object({
        org_id: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the organization relationship */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              type: z.string().optional(),
              rel_owner_org_id: z.intersection(z.object({
                name: z.string().optional(),
                people_count: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                address: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              rel_linked_org_id: z.intersection(z.object({
                name: z.string().optional(),
                people_count: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                address: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              active_flag: z.string().optional(),
            }), z.object({
              calculated_type: z.string().optional(),
              calculated_related_org_id: z.number().int().optional(),
            })).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  updateOrganizationRelationship: {
    /**
     * Update an organization relationship 
     * @description Updates and returns an organization relationship.
     */
    parameters: {
        /** @description The ID of the organization relationship */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          org_id: z.number().int().nullish(),
          type: z.enum(["parent", "related"]).nullish(),
          rel_owner_org_id: z.number().int().nullish(),
          rel_linked_org_id: z.number().int().nullish(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              type: z.string().optional(),
              rel_owner_org_id: z.intersection(z.object({
                name: z.string().optional(),
                people_count: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                address: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              rel_linked_org_id: z.intersection(z.object({
                name: z.string().optional(),
                people_count: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                address: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              active_flag: z.string().optional(),
            }).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteOrganizationRelationship: {
    /**
     * Delete an organization relationship 
     * @description Deletes an organization relationship and returns the deleted ID.
     */
    parameters: {
        /** @description The ID of the organization relationship */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPermissionSets: {
    /**
     * Get all permission sets 
     * @description Returns data about all permission sets.
     */
    parameters: {
        /** @description The app to filter the permission sets by */
      query: z.object({
        app: z.enum(["sales", "projects", "campaigns", "global", "account_settings"]).optional(),
      }).optional(),
    },
    responses: {
      /** @description Get all permissions */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.string().optional(),
                name: z.string().optional(),
                description: z.string().optional(),
                app: z.enum(["sales", "projects", "campaigns", "global", "account_settings"]).optional(),
                type: z.enum(["admin", "manager", "regular", "custom"]).optional(),
                assignment_count: z.number().int().optional(),
              })).optional(),
          })),
        },
      },
    },
  },
  getPermissionSet: {
    /**
     * Get one permission set 
     * @description Returns data about a specific permission set.
     */
    parameters: {
        /** @description The ID of the permission set */
      path: z.object({
        id: z.string(),
      }),
    },
    responses: {
      /** @description The permission set of a specific user ID */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            id: z.string().optional(),
            name: z.string().optional(),
            description: z.string().optional(),
            app: z.enum(["sales", "projects", "campaigns", "global", "account_settings"]).optional(),
            type: z.enum(["admin", "manager", "regular", "custom"]).optional(),
            assignment_count: z.number().int().optional(),
          }), z.object({
            contents: z.array(z.string()).optional(),
          })),
        },
      },
      /** @description If the user ID has no assignments, then it will return NotFound */
      404: {
        content: {
          "application/json": z.record(z.any()),
        },
      },
    },
  },
  getPermissionSetAssignments: {
    /**
     * List permission set assignments 
     * @description Returns the list of assignments for a permission set.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the permission set */
      path: z.object({
        id: z.string(),
      }),
    },
    responses: {
      /** @description The assignments of a specific user ID */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                user_id: z.number().int().optional(),
                permission_set_id: z.string().optional(),
                name: z.string().optional(),
              })).optional(),
          })),
        },
      },
      /** @description If the user ID has no assignments, then it will return NotFound */
      404: {
        content: {
          "application/json": z.record(z.any()),
        },
      },
    },
  },
  getPersons: {
    /**
     * Get all persons 
     * @description Returns all persons.
     */
    parameters: {
        /** @description If supplied, only persons owned by the given user will be returned. However, `filter_id` takes precedence over `user_id` when both are supplied. */
        /** @description The ID of the filter to use */
        /** @description If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive) */
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys). */
      query: z.object({
        user_id: z.number().int().optional(),
        filter_id: z.number().int().optional(),
        first_char: z.string().optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        sort: z.string().optional(),
      }).optional(),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                company_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                phone: z.array(z.object({
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                    label: z.string().optional(),
                  })).optional(),
                email: z.array(z.object({
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                    label: z.string().optional(),
                  })).optional(),
                first_char: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                visible_to: z.string().optional(),
                picture_id: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  item_type: z.string().optional(),
                  item_id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  added_by_user_id: z.number().int().optional(),
                  pictures: z.object({
                    128: z.string().optional(),
                    512: z.string().optional(),
                  }).optional(),
                })).optional(),
                label: z.number().int().optional(),
                org_name: z.string().optional(),
                owner_name: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.intersection(z.intersection(z.object({
                owner_id: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                org_id: z.intersection(z.intersection(z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })), z.object({
                  active_flag: z.boolean().optional(),
                })).optional(),
              }), z.object({
                name: z.string().optional(),
                first_name: z.string().optional(),
                last_name: z.string().optional(),
              })), z.intersection(z.intersection(z.object({
                email_messages_count: z.number().int().optional(),
                activities_count: z.number().int().optional(),
                done_activities_count: z.number().int().optional(),
                undone_activities_count: z.number().int().optional(),
                files_count: z.number().int().optional(),
                notes_count: z.number().int().optional(),
                followers_count: z.number().int().optional(),
              }), z.object({
                last_incoming_mail_time: z.string().optional(),
                last_outgoing_mail_time: z.string().optional(),
              })), z.intersection(z.object({
                open_deals_count: z.number().int().optional(),
                related_open_deals_count: z.number().int().optional(),
                closed_deals_count: z.number().int().optional(),
                related_closed_deals_count: z.number().int().optional(),
                won_deals_count: z.number().int().optional(),
                related_won_deals_count: z.number().int().optional(),
                lost_deals_count: z.number().int().optional(),
                related_lost_deals_count: z.number().int().optional(),
              }), z.object({
                next_activity_date: z.string().nullable().optional(),
                next_activity_time: z.string().nullable().optional(),
                next_activity_id: z.number().int().nullable().optional(),
                last_activity_id: z.number().int().nullable().optional(),
                last_activity_date: z.string().nullable().optional(),
              })))))).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
                next_start: z.number().int().optional(),
              }).optional(),
            }).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              picture: z.object({
                PICTURE_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  item_type: z.string().optional(),
                  item_id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  added_by_user_id: z.number().int().optional(),
                  pictures: z.object({
                    128: z.string().optional(),
                    512: z.string().optional(),
                  }).optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addPerson: {
    /**
     * Add a person 
     * @description Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
     */
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          name: z.string(),
        }), z.object({
          owner_id: z.number().int().nullish(),
          org_id: z.number().int().nullish(),
          email: z.array(z.object({
              value: z.string().nullish(),
              primary: z.boolean().nullish(),
              label: z.string().nullish(),
            })).nullish(),
          phone: z.array(z.object({
              value: z.string().nullish(),
              primary: z.boolean().nullish(),
              label: z.string().nullish(),
            })).nullish(),
          label: z.number().int().nullish(),
          visible_to: z.string().nullish(),
          marketing_status: z.enum(["no_consent", "unsubscribed", "subscribed", "archived"]).nullish(),
          add_time: z.string().nullish(),
        })),
      },
    },
    responses: {
      /** @description Success */
      201: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              company_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              phone: z.array(z.object({
                  value: z.string().optional(),
                  primary: z.boolean().optional(),
                  label: z.string().optional(),
                })).optional(),
              email: z.array(z.object({
                  value: z.string().optional(),
                  primary: z.boolean().optional(),
                  label: z.string().optional(),
                })).optional(),
              first_char: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.string().optional(),
              picture_id: z.intersection(z.object({
                id: z.number().int().optional(),
              }), z.object({
                item_type: z.string().optional(),
                item_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                added_by_user_id: z.number().int().optional(),
                pictures: z.object({
                  128: z.string().optional(),
                  512: z.string().optional(),
                }).optional(),
              })).optional(),
              label: z.number().int().optional(),
              org_name: z.string().optional(),
              owner_name: z.string().optional(),
              cc_email: z.string().optional(),
            }), z.intersection(z.intersection(z.object({
              owner_id: z.intersection(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.string().optional(),
                has_pic: z.number().int().optional(),
                pic_hash: z.string().nullable().optional(),
                active_flag: z.boolean().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              org_id: z.intersection(z.intersection(z.object({
                name: z.string().optional(),
                people_count: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                address: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })), z.object({
                active_flag: z.boolean().optional(),
              })).optional(),
            }), z.object({
              name: z.string().optional(),
              first_name: z.string().optional(),
              last_name: z.string().optional(),
            })), z.intersection(z.intersection(z.object({
              email_messages_count: z.number().int().optional(),
              activities_count: z.number().int().optional(),
              done_activities_count: z.number().int().optional(),
              undone_activities_count: z.number().int().optional(),
              files_count: z.number().int().optional(),
              notes_count: z.number().int().optional(),
              followers_count: z.number().int().optional(),
            }), z.object({
              last_incoming_mail_time: z.string().optional(),
              last_outgoing_mail_time: z.string().optional(),
            })), z.intersection(z.object({
              open_deals_count: z.number().int().optional(),
              related_open_deals_count: z.number().int().optional(),
              closed_deals_count: z.number().int().optional(),
              related_closed_deals_count: z.number().int().optional(),
              won_deals_count: z.number().int().optional(),
              related_won_deals_count: z.number().int().optional(),
              lost_deals_count: z.number().int().optional(),
              related_lost_deals_count: z.number().int().optional(),
            }), z.object({
              next_activity_date: z.string().nullable().optional(),
              next_activity_time: z.string().nullable().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              last_activity_id: z.number().int().nullable().optional(),
              last_activity_date: z.string().nullable().optional(),
            }))))).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deletePersons: {
    /**
     * Delete multiple persons in bulk 
     * @description Marks multiple persons as deleted. After 30 days, the persons will be permanently deleted.
     */
    parameters: {
        /** @description The comma-separated IDs that will be deleted */
      query: z.object({
        ids: z.string(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.array(z.number().int()).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPersonsCollection: {
    /**
     * Get all persons (BETA) 
     * @description Returns all persons. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href="https://support.pipedrive.com/en/article/global-user-management" target="_blank" rel="noopener noreferrer">here</a>.
     */
    parameters: {
        /** @description For pagination, the marker (an opaque string value) representing the first item on the next page */
        /** @description For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed. */
        /** @description The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field. */
        /** @description The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field. */
        /** @description If supplied, only persons owned by the given user will be returned */
        /** @description If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive) */
      query: z.object({
        cursor: z.string().optional(),
        limit: z.number().int().optional(),
        since: z.string().optional(),
        until: z.string().optional(),
        owner_id: z.number().int().optional(),
        first_char: z.string().optional(),
      }).optional(),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                owner_id: z.number().int().optional(),
                org_id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.array(z.object({
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                    label: z.string().optional(),
                  })).optional(),
                phone: z.array(z.object({
                    value: z.string().optional(),
                    primary: z.boolean().optional(),
                    label: z.string().optional(),
                  })).optional(),
                update_time: z.string().optional(),
                delete_time: z.string().nullable().optional(),
                add_time: z.string().optional(),
                visible_to: z.string().optional(),
                picture_id: z.number().int().nullable().optional(),
                label: z.number().int().nullable().optional(),
                cc_email: z.string().optional(),
              })).optional(),
            additional_data: z.object({
              next_cursor: z.string().optional(),
            }).optional(),
          }),
        },
      },
      /** @description Forbidden response */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  searchPersons: {
    /**
     * Search persons 
     * @description Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href="https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
     */
    parameters: {
        /** @description The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded. */
        /** @description A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: `address`, `varchar`, `text`, `varchar_auto`, `double`, `monetary` and `phone`. Read more about searching by custom fields <a href="https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields" target="_blank" rel="noopener noreferrer">here</a>. */
        /** @description When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive. */
        /** @description Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000. */
        /** @description Supports including optional fields in the results which are not provided by default */
        /** @description Pagination start. Note that the pagination is based on main results and does not include related items when using `search_for_related_items` parameter. */
        /** @description Items shown per page */
      query: z.object({
        term: z.string(),
        fields: z.enum(["custom_fields", "email", "notes", "phone", "name"]).optional(),
        exact_match: z.boolean().optional(),
        organization_id: z.number().int().optional(),
        include_fields: z.literal("person.picture").optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              items: z.array(z.object({
                  result_score: z.number().optional(),
                  item: z.object({
                    id: z.number().int().optional(),
                    type: z.string().optional(),
                    name: z.string().optional(),
                    phones: z.array(z.string()).optional(),
                    emails: z.array(z.string()).optional(),
                    visible_to: z.number().int().optional(),
                    owner: z.object({
                      id: z.number().int().optional(),
                    }).optional(),
                    organization: z.object({
                      id: z.number().int().optional(),
                      name: z.string().optional(),
                    }).optional(),
                    custom_fields: z.array(z.string()).optional(),
                    notes: z.array(z.string()).optional(),
                  }).optional(),
                })).optional(),
            }).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
                next_start: z.number().int().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPerson: {
    /**
     * Get details of a person 
     * @description Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     */
    parameters: {
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              company_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              phone: z.array(z.object({
                  value: z.string().optional(),
                  primary: z.boolean().optional(),
                  label: z.string().optional(),
                })).optional(),
              email: z.array(z.object({
                  value: z.string().optional(),
                  primary: z.boolean().optional(),
                  label: z.string().optional(),
                })).optional(),
              first_char: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.string().optional(),
              picture_id: z.intersection(z.object({
                id: z.number().int().optional(),
              }), z.object({
                item_type: z.string().optional(),
                item_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                added_by_user_id: z.number().int().optional(),
                pictures: z.object({
                  128: z.string().optional(),
                  512: z.string().optional(),
                }).optional(),
              })).optional(),
              label: z.number().int().optional(),
              org_name: z.string().optional(),
              owner_name: z.string().optional(),
              cc_email: z.string().optional(),
            }), z.intersection(z.intersection(z.object({
              owner_id: z.intersection(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.string().optional(),
                has_pic: z.number().int().optional(),
                pic_hash: z.string().nullable().optional(),
                active_flag: z.boolean().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              org_id: z.intersection(z.intersection(z.object({
                name: z.string().optional(),
                people_count: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                address: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })), z.object({
                active_flag: z.boolean().optional(),
              })).optional(),
            }), z.object({
              name: z.string().optional(),
              first_name: z.string().optional(),
              last_name: z.string().optional(),
            })), z.intersection(z.intersection(z.object({
              email_messages_count: z.number().int().optional(),
              activities_count: z.number().int().optional(),
              done_activities_count: z.number().int().optional(),
              undone_activities_count: z.number().int().optional(),
              files_count: z.number().int().optional(),
              notes_count: z.number().int().optional(),
              followers_count: z.number().int().optional(),
            }), z.object({
              last_incoming_mail_time: z.string().optional(),
              last_outgoing_mail_time: z.string().optional(),
            })), z.intersection(z.object({
              open_deals_count: z.number().int().optional(),
              related_open_deals_count: z.number().int().optional(),
              closed_deals_count: z.number().int().optional(),
              related_closed_deals_count: z.number().int().optional(),
              won_deals_count: z.number().int().optional(),
              related_won_deals_count: z.number().int().optional(),
              lost_deals_count: z.number().int().optional(),
              related_lost_deals_count: z.number().int().optional(),
            }), z.object({
              next_activity_date: z.string().nullable().optional(),
              next_activity_time: z.string().nullable().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              last_activity_id: z.number().int().nullable().optional(),
              last_activity_date: z.string().nullable().optional(),
            }))))).optional(),
            additional_data: z.object({
              dropbox_email: z.string().optional(),
            }).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              picture: z.object({
                PICTURE_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  item_type: z.string().optional(),
                  item_id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  added_by_user_id: z.number().int().optional(),
                  pictures: z.object({
                    128: z.string().optional(),
                    512: z.string().optional(),
                  }).optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  updatePerson: {
    /**
     * Update a person 
     * @description Updates the properties of a person. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/updating-a-person" target="_blank" rel="noopener noreferrer">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
     */
    parameters: {
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          name: z.string().nullish(),
        }), z.object({
          owner_id: z.number().int().nullish(),
          org_id: z.number().int().nullish(),
          email: z.array(z.object({
              value: z.string().nullish(),
              primary: z.boolean().nullish(),
              label: z.string().nullish(),
            })).nullish(),
          phone: z.array(z.object({
              value: z.string().nullish(),
              primary: z.boolean().nullish(),
              label: z.string().nullish(),
            })).nullish(),
          label: z.number().int().nullish(),
          visible_to: z.string().nullish(),
          marketing_status: z.enum(["no_consent", "unsubscribed", "subscribed", "archived"]).nullish(),
          add_time: z.string().nullish(),
        })),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              company_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              phone: z.array(z.object({
                  value: z.string().optional(),
                  primary: z.boolean().optional(),
                  label: z.string().optional(),
                })).optional(),
              email: z.array(z.object({
                  value: z.string().optional(),
                  primary: z.boolean().optional(),
                  label: z.string().optional(),
                })).optional(),
              first_char: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.string().optional(),
              picture_id: z.intersection(z.object({
                id: z.number().int().optional(),
              }), z.object({
                item_type: z.string().optional(),
                item_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                added_by_user_id: z.number().int().optional(),
                pictures: z.object({
                  128: z.string().optional(),
                  512: z.string().optional(),
                }).optional(),
              })).optional(),
              label: z.number().int().optional(),
              org_name: z.string().optional(),
              owner_name: z.string().optional(),
              cc_email: z.string().optional(),
            }), z.intersection(z.intersection(z.object({
              owner_id: z.intersection(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                email: z.string().optional(),
                has_pic: z.number().int().optional(),
                pic_hash: z.string().nullable().optional(),
                active_flag: z.boolean().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })).optional(),
              org_id: z.intersection(z.intersection(z.object({
                name: z.string().optional(),
                people_count: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                address: z.string().optional(),
                cc_email: z.string().optional(),
              }), z.object({
                value: z.number().int().optional(),
              })), z.object({
                active_flag: z.boolean().optional(),
              })).optional(),
            }), z.object({
              name: z.string().optional(),
              first_name: z.string().optional(),
              last_name: z.string().optional(),
            })), z.intersection(z.intersection(z.object({
              email_messages_count: z.number().int().optional(),
              activities_count: z.number().int().optional(),
              done_activities_count: z.number().int().optional(),
              undone_activities_count: z.number().int().optional(),
              files_count: z.number().int().optional(),
              notes_count: z.number().int().optional(),
              followers_count: z.number().int().optional(),
            }), z.object({
              last_incoming_mail_time: z.string().optional(),
              last_outgoing_mail_time: z.string().optional(),
            })), z.intersection(z.object({
              open_deals_count: z.number().int().optional(),
              related_open_deals_count: z.number().int().optional(),
              closed_deals_count: z.number().int().optional(),
              related_closed_deals_count: z.number().int().optional(),
              won_deals_count: z.number().int().optional(),
              related_won_deals_count: z.number().int().optional(),
              lost_deals_count: z.number().int().optional(),
              related_lost_deals_count: z.number().int().optional(),
            }), z.object({
              next_activity_date: z.string().nullable().optional(),
              next_activity_time: z.string().nullable().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              last_activity_id: z.number().int().nullable().optional(),
              last_activity_date: z.string().nullable().optional(),
            }))))).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deletePerson: {
    /**
     * Delete a person 
     * @description Marks a person as deleted. After 30 days, the person will be permanently deleted.
     */
    parameters: {
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPersonActivities: {
    /**
     * List activities associated with a person 
     * @description Lists activities associated with a person.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description Whether the activity is done or not. 0 = Not done, 1 = Done. If omitted, returns both Done and Not done activities. */
        /** @description A comma-separated string of activity IDs to exclude from result */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        done: z.number().optional(),
        exclude: z.string().optional(),
      }).optional(),
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                due_date: z.string().optional(),
                due_time: z.string().optional(),
                duration: z.string().optional(),
                deal_id: z.number().int().optional(),
                lead_id: z.string().nullable().optional(),
                person_id: z.number().int().optional(),
                project_id: z.number().int().nullable().optional(),
                org_id: z.number().int().optional(),
                location: z.string().optional(),
                public_description: z.string().optional(),
              }), z.object({
                id: z.number().int().optional(),
                note: z.string().optional(),
                done: z.boolean().optional(),
                subject: z.string().optional(),
                type: z.string().optional(),
                user_id: z.number().int().optional(),
                participants: z.array(z.record(z.any())).nullable().optional(),
                busy_flag: z.boolean().optional(),
                attendees: z.array(z.record(z.any())).nullable().optional(),
                company_id: z.number().int().optional(),
                reference_type: z.string().optional(),
                reference_id: z.number().int().optional(),
                conference_meeting_client: z.string().optional(),
                conference_meeting_url: z.string().optional(),
                conference_meeting_id: z.string().optional(),
                add_time: z.string().optional(),
                marked_as_done_time: z.string().optional(),
                last_notification_time: z.string().optional(),
                last_notification_user_id: z.number().int().optional(),
                notification_language_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                update_time: z.string().optional(),
                update_user_id: z.number().int().optional(),
                gcal_event_id: z.string().optional(),
                google_calendar_id: z.string().optional(),
                google_calendar_etag: z.string().optional(),
                calendar_sync_include_context: z.string().optional(),
                source_timezone: z.string().optional(),
                rec_rule: z.string().optional(),
                rec_rule_extension: z.string().optional(),
                rec_master_activity_id: z.number().int().optional(),
                series: z.array(z.record(z.any())).optional(),
                created_by_user_id: z.number().int().optional(),
                location_subpremise: z.string().optional(),
                location_street_number: z.string().optional(),
                location_route: z.string().optional(),
                location_sublocality: z.string().optional(),
                location_locality: z.string().optional(),
                location_admin_area_level_1: z.string().optional(),
                location_admin_area_level_2: z.string().optional(),
                location_country: z.string().optional(),
                location_postal_code: z.string().optional(),
                location_formatted_address: z.string().optional(),
                org_name: z.string().optional(),
                person_name: z.string().optional(),
                deal_title: z.string().optional(),
                owner_name: z.string().optional(),
                person_dropbox_bcc: z.string().optional(),
                deal_dropbox_bcc: z.string().optional(),
                assigned_to_user_id: z.number().int().optional(),
                file: z.record(z.any()).optional(),
              }))).optional(),
            additional_data: z.intersection(z.object({
              activity_distribution: z.object({
                ASSIGNED_TO_USER_ID: z.object({
                  activities: z.object({
                    ACTIVITY_TYPE_NAME: z.number().int().optional(),
                  }).optional(),
                  name: z.string().optional(),
                  activity_count: z.number().int().optional(),
                  share: z.number().int().optional(),
                }).optional(),
              }).optional(),
            }), z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            })).optional(),
          })),
        },
      },
    },
  },
  getPersonDeals: {
    /**
     * List deals associated with a person 
     * @description Lists deals associated with a person.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. */
        /** @description The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys). */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        status: z.enum(["open", "won", "lost", "deleted", "all_not_deleted"]).optional(),
        sort: z.string().optional(),
      }).optional(),
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                creator_user_id: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.boolean().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                  value: z.number().int().optional(),
                }).optional(),
                user_id: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.boolean().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                person_id: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                org_id: z.intersection(z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  active_flag: z.boolean().optional(),
                  cc_email: z.string().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
              }), z.object({
                stage_id: z.number().int().optional(),
                title: z.string().optional(),
                value: z.number().optional(),
                currency: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                stage_change_time: z.string().optional(),
                active: z.boolean().optional(),
                deleted: z.boolean().optional(),
                status: z.string().optional(),
                probability: z.number().nullable().optional(),
                next_activity_date: z.string().optional(),
                next_activity_time: z.string().optional(),
                next_activity_id: z.number().int().nullable().optional(),
                last_activity_id: z.number().int().nullable().optional(),
                last_activity_date: z.string().nullable().optional(),
                lost_reason: z.string().nullable().optional(),
                visible_to: z.string().optional(),
                close_time: z.string().nullable().optional(),
                pipeline_id: z.number().int().optional(),
                won_time: z.string().optional(),
                first_won_time: z.string().optional(),
                lost_time: z.string().optional(),
                products_count: z.number().int().optional(),
                files_count: z.number().int().optional(),
                notes_count: z.number().int().optional(),
                followers_count: z.number().int().optional(),
                email_messages_count: z.number().int().optional(),
                activities_count: z.number().int().optional(),
                done_activities_count: z.number().int().optional(),
                undone_activities_count: z.number().int().optional(),
                participants_count: z.number().int().optional(),
                expected_close_date: z.string().optional(),
                last_incoming_mail_time: z.string().optional(),
                last_outgoing_mail_time: z.string().optional(),
                label: z.string().optional(),
                stage_order_nr: z.number().int().optional(),
                person_name: z.string().optional(),
                org_name: z.string().optional(),
                next_activity_subject: z.string().optional(),
                next_activity_type: z.string().optional(),
                next_activity_duration: z.string().optional(),
                next_activity_note: z.string().optional(),
                formatted_value: z.string().optional(),
                weighted_value: z.number().optional(),
                formatted_weighted_value: z.string().optional(),
                weighted_value_currency: z.string().optional(),
                rotten_time: z.string().nullable().optional(),
                owner_name: z.string().optional(),
                cc_email: z.string().optional(),
                org_hidden: z.boolean().optional(),
                person_hidden: z.boolean().optional(),
              }))).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }))).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              stage: z.object({
                id: z.number().int().optional(),
                order_nr: z.number().int().optional(),
                name: z.string().optional(),
                active_flag: z.boolean().optional(),
                deal_probability: z.number().int().optional(),
                pipeline_id: z.number().int().optional(),
                rotten_flag: z.boolean().optional(),
                rotten_days: z.number().int().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              }).optional(),
              pipeline: z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                url_title: z.string().optional(),
                order_nr: z.number().int().optional(),
                active: z.boolean().optional(),
                deal_probability: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPersonFiles: {
    /**
     * List files attached to a person 
     * @description Lists files associated with a person.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys). Supported fields: `id`, `user_id`, `deal_id`, `person_id`, `org_id`, `product_id`, `add_time`, `update_time`, `file_name`, `file_type`, `file_size`, `comment`. */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        sort: z.string().optional(),
      }).optional(),
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                user_id: z.number().int().optional(),
                deal_id: z.number().int().optional(),
                person_id: z.number().int().optional(),
                org_id: z.number().int().optional(),
                product_id: z.number().int().optional(),
                activity_id: z.number().int().optional(),
                lead_id: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                file_name: z.string().optional(),
                file_size: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                inline_flag: z.boolean().optional(),
                remote_location: z.string().optional(),
                remote_id: z.string().optional(),
                cid: z.string().optional(),
                s3_bucket: z.string().optional(),
                mail_message_id: z.string().optional(),
                mail_template_id: z.string().optional(),
                deal_name: z.string().optional(),
                person_name: z.string().optional(),
                org_name: z.string().optional(),
                product_name: z.string().optional(),
                lead_name: z.string().optional(),
                url: z.string().optional(),
                name: z.string().optional(),
                description: z.string().optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPersonUpdates: {
    /**
     * List updates about a person 
     * @description Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint's response will also include updates for the `marketing_status` field.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description Whether to show custom field updates or not. 1 = Include custom field changes. If omitted returns changes without custom field updates. */
        /** @description A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change). */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        all_changes: z.string().optional(),
        items: z.string().optional(),
      }).optional(),
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get the person updates */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                object: z.string().optional(),
                timestamp: z.string().optional(),
                data: z.record(z.any()).optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
            related_objects: z.object({
              deal: z.object({
                DEAL_ID: z.object({
                  id: z.number().int().optional(),
                  title: z.string().optional(),
                  status: z.string().optional(),
                  value: z.number().optional(),
                  currency: z.string().optional(),
                  stage_id: z.number().int().optional(),
                  pipeline_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPersonFollowers: {
    /**
     * List followers of a person 
     * @description Lists the followers of a person.
     */
    parameters: {
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                user_id: z.number().int().optional(),
                id: z.number().int().optional(),
                deal_id: z.number().int().optional(),
                add_time: z.string().optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addPersonFollower: {
    /**
     * Add a follower to a person 
     * @description Adds a follower to a person.
     */
    parameters: {
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          user_id: z.number().int(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              user_id: z.number().int().optional(),
              id: z.number().int().optional(),
              person_id: z.number().int().optional(),
              add_time: z.string().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deletePersonFollower: {
    /**
     * Delete a follower from a person 
     * @description Deletes a follower from a person.
     */
    parameters: {
        /** @description The ID of the person */
        /** @description The ID of the follower */
      path: z.object({
        id: z.number().int(),
        follower_id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPersonMailMessages: {
    /**
     * List mail messages associated with a person 
     * @description Lists mail messages associated with a person.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                object: z.string().optional(),
                timestamp: z.string().optional(),
                data: z.intersection(z.object({
                  id: z.number().int().optional(),
                  from: z.array(z.object({
                      id: z.number().int().optional(),
                      email_address: z.string().optional(),
                      name: z.string().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                    })).optional(),
                  to: z.array(z.object({
                      id: z.number().int().optional(),
                      email_address: z.string().optional(),
                      name: z.string().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                    })).optional(),
                  cc: z.array(z.object({
                      id: z.number().int().optional(),
                      email_address: z.string().optional(),
                      name: z.string().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                    })).optional(),
                  bcc: z.array(z.object({
                      id: z.number().int().optional(),
                      email_address: z.string().optional(),
                      name: z.string().optional(),
                      linked_person_id: z.number().int().optional(),
                      linked_person_name: z.string().optional(),
                      mail_message_party_id: z.number().int().optional(),
                    })).optional(),
                  body_url: z.string().optional(),
                  account_id: z.string().optional(),
                  user_id: z.number().int().optional(),
                  mail_thread_id: z.number().int().optional(),
                  subject: z.string().optional(),
                  snippet: z.string().optional(),
                  mail_tracking_status: z.enum(["opened", "not opened"]).nullable().optional(),
                  mail_link_tracking_enabled_flag: z.number().optional(),
                  read_flag: z.number().optional(),
                  draft: z.string().optional(),
                  draft_flag: z.number().optional(),
                  synced_flag: z.number().optional(),
                  deleted_flag: z.number().optional(),
                  has_body_flag: z.number().optional(),
                  sent_flag: z.number().optional(),
                  sent_from_pipedrive_flag: z.number().optional(),
                  smart_bcc_flag: z.number().optional(),
                  message_time: z.string().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  has_attachments_flag: z.number().optional(),
                  has_inline_attachments_flag: z.number().optional(),
                  has_real_attachments_flag: z.number().optional(),
                }), z.object({
                  nylas_id: z.string().optional(),
                  s3_bucket: z.string().optional(),
                  s3_bucket_path: z.string().optional(),
                  external_deleted_flag: z.boolean().optional(),
                  mua_message_id: z.string().optional(),
                  template_id: z.number().int().optional(),
                  timestamp: z.string().optional(),
                  item_type: z.string().optional(),
                  company_id: z.number().int().optional(),
                })).optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  mergePersons: {
    /**
     * Merge two persons 
     * @description Merges a person with another person. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/merging-two-persons" target="_blank" rel="noopener noreferrer">merging two persons</a>.
     */
    parameters: {
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          merge_with_id: z.number().int(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              company_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              phone: z.array(z.object({
                  value: z.string().optional(),
                  primary: z.boolean().optional(),
                  label: z.string().optional(),
                })).optional(),
              email: z.array(z.object({
                  value: z.string().optional(),
                  primary: z.boolean().optional(),
                  label: z.string().optional(),
                })).optional(),
              first_char: z.string().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              visible_to: z.string().optional(),
              picture_id: z.intersection(z.object({
                id: z.number().int().optional(),
              }), z.object({
                item_type: z.string().optional(),
                item_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                added_by_user_id: z.number().int().optional(),
                pictures: z.object({
                  128: z.string().optional(),
                  512: z.string().optional(),
                }).optional(),
              })).optional(),
              label: z.number().int().optional(),
              org_name: z.string().optional(),
              owner_name: z.string().optional(),
              cc_email: z.string().optional(),
            }), z.intersection(z.intersection(z.object({
              owner_id: z.number().int().optional(),
              org_id: z.number().int().optional(),
              merge_what_id: z.number().int().optional(),
            }), z.intersection(z.object({
              name: z.string().optional(),
              first_name: z.string().optional(),
              last_name: z.string().optional(),
            }), z.intersection(z.object({
              email_messages_count: z.number().int().optional(),
              activities_count: z.number().int().optional(),
              done_activities_count: z.number().int().optional(),
              undone_activities_count: z.number().int().optional(),
              files_count: z.number().int().optional(),
              notes_count: z.number().int().optional(),
              followers_count: z.number().int().optional(),
            }), z.object({
              last_incoming_mail_time: z.string().optional(),
              last_outgoing_mail_time: z.string().optional(),
            })))), z.intersection(z.intersection(z.object({
              open_deals_count: z.number().int().optional(),
              related_open_deals_count: z.number().int().optional(),
              closed_deals_count: z.number().int().optional(),
              related_closed_deals_count: z.number().int().optional(),
              won_deals_count: z.number().int().optional(),
              related_won_deals_count: z.number().int().optional(),
              lost_deals_count: z.number().int().optional(),
              related_lost_deals_count: z.number().int().optional(),
            }), z.object({
              next_activity_date: z.string().nullable().optional(),
              next_activity_time: z.string().nullable().optional(),
              next_activity_id: z.number().int().nullable().optional(),
              last_activity_id: z.number().int().nullable().optional(),
              last_activity_date: z.string().nullable().optional(),
            })), z.object({
              participant_open_deals_count: z.number().int().optional(),
              participant_closed_deals_count: z.number().int().optional(),
            })))).optional(),
          })),
        },
      },
    },
  },
  getPersonUsers: {
    /**
     * List permitted users 
     * @description List users permitted to access a person.
     */
    parameters: {
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.number()).optional(),
          })),
        },
      },
    },
  },
  addPersonPicture: {
    /**
     * Add person picture 
     * @description Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
     */
    parameters: {
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "multipart/form-data": z.object({
          file: z.string(),
          crop_x: z.number().int().nullish(),
          crop_y: z.number().int().nullish(),
          crop_width: z.number().int().nullish(),
          crop_height: z.number().int().nullish(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              PICTURE_ID: z.intersection(z.object({
                id: z.number().int().optional(),
              }), z.object({
                item_type: z.string().optional(),
                item_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                added_by_user_id: z.number().int().optional(),
                pictures: z.object({
                  128: z.string().optional(),
                  512: z.string().optional(),
                }).optional(),
              })).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deletePersonPicture: {
    /**
     * Delete person picture 
     * @description Deletes a persons picture.
     */
    parameters: {
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPersonProducts: {
    /**
     * List products associated with a person 
     * @description Lists products associated with a person.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the person */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                DEAL_ID: z.object({
                  deal: z.object({
                    id: z.number().int().optional(),
                    company_id: z.number().int().optional(),
                    creator_user_id: z.number().int().optional(),
                    user_id: z.number().int().optional(),
                    person_id: z.number().int().optional(),
                    org_id: z.number().int().optional(),
                    stage_id: z.number().int().optional(),
                    title: z.string().optional(),
                    value: z.number().optional(),
                    currency: z.string().optional(),
                    add_time: z.string().optional(),
                    first_add_time: z.string().optional(),
                    update_time: z.string().optional(),
                    stage_change_time: z.string().optional(),
                    active: z.boolean().optional(),
                    deleted: z.boolean().optional(),
                    status: z.string().optional(),
                    probability: z.number().nullable().optional(),
                    next_activity_date: z.string().optional(),
                    next_activity_time: z.string().optional(),
                    next_activity_id: z.number().int().nullable().optional(),
                    last_activity_id: z.number().int().nullable().optional(),
                    last_activity_date: z.string().nullable().optional(),
                    lost_reason: z.string().nullable().optional(),
                    visible_to: z.string().optional(),
                    close_time: z.string().nullable().optional(),
                    pipeline_id: z.number().int().optional(),
                    won_time: z.string().optional(),
                    first_won_time: z.string().optional(),
                    lost_time: z.string().optional(),
                    products_count: z.number().int().optional(),
                    files_count: z.number().int().optional(),
                    notes_count: z.number().int().optional(),
                    followers_count: z.number().int().optional(),
                    email_messages_count: z.number().int().optional(),
                    activities_count: z.number().int().optional(),
                    done_activities_count: z.number().int().optional(),
                    undone_activities_count: z.number().int().optional(),
                    participants_count: z.number().int().optional(),
                    expected_close_date: z.string().optional(),
                    last_incoming_mail_time: z.string().optional(),
                    last_outgoing_mail_time: z.string().optional(),
                    label: z.string().optional(),
                  }).optional(),
                  product: z.object({
                    id: z.number().int().optional(),
                    company_id: z.number().int().optional(),
                    name: z.string().optional(),
                    code: z.string().optional(),
                    description: z.string().optional(),
                    unit: z.string().optional(),
                    tax: z.number().optional(),
                    category: z.string().optional(),
                    active_flag: z.boolean().optional(),
                    selectable: z.boolean().optional(),
                    first_char: z.string().optional(),
                    visible_to: z.enum(["1", "3", "5", "7"]).optional(),
                    owner_id: z.number().int().optional(),
                    files_count: z.number().int().optional(),
                    add_time: z.string().optional(),
                    update_time: z.string().optional(),
                    deal_id: z.number().int().optional(),
                  }).optional(),
                }).optional(),
              })).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
                next_start: z.number().int().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPersonFields: {
    /**
     * Get all person fields 
     * @description Returns data about all person fields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                key: z.string().optional(),
                name: z.string().optional(),
                order_nr: z.number().int().optional(),
                field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                last_updated_by_user_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                edit_flag: z.boolean().optional(),
                index_visible_flag: z.boolean().optional(),
                details_visible_flag: z.boolean().optional(),
                add_visible_flag: z.boolean().optional(),
                important_flag: z.boolean().optional(),
                bulk_edit_allowed: z.boolean().optional(),
                searchable_flag: z.boolean().optional(),
                filtering_allowed: z.boolean().optional(),
                sortable_flag: z.boolean().optional(),
                mandatory_flag: z.boolean().optional(),
                options: z.array(z.record(z.any())).nullable().optional(),
                options_deleted: z.array(z.record(z.any())).optional(),
                is_subfield: z.boolean().optional(),
                subfields: z.array(z.record(z.any())).optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addPersonField: {
    /**
     * Add a new person field 
     * @description Adds a new person field. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-new-custom-field" target="_blank" rel="noopener noreferrer">adding a new custom field</a>.
     */
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          name: z.string(),
          options: z.array(z.record(z.any())).nullish(),
          add_visible_flag: z.boolean().nullish(),
        }), z.object({
          field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]),
        })),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              key: z.string().optional(),
              name: z.string().optional(),
              order_nr: z.number().int().optional(),
              field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              last_updated_by_user_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              edit_flag: z.boolean().optional(),
              index_visible_flag: z.boolean().optional(),
              details_visible_flag: z.boolean().optional(),
              add_visible_flag: z.boolean().optional(),
              important_flag: z.boolean().optional(),
              bulk_edit_allowed: z.boolean().optional(),
              searchable_flag: z.boolean().optional(),
              filtering_allowed: z.boolean().optional(),
              sortable_flag: z.boolean().optional(),
              mandatory_flag: z.boolean().optional(),
              options: z.array(z.record(z.any())).nullable().optional(),
              options_deleted: z.array(z.record(z.any())).optional(),
              is_subfield: z.boolean().optional(),
              subfields: z.array(z.record(z.any())).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deletePersonFields: {
    /**
     * Delete multiple person fields in bulk 
     * @description Marks multiple fields as deleted.
     */
    parameters: {
        /** @description The comma-separated field IDs to delete */
      query: z.object({
        ids: z.string(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.array(z.number().int()).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPersonField: {
    /**
     * Get one person field 
     * @description Returns data about a specific person field.
     */
    parameters: {
        /** @description The ID of the field */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              key: z.string().optional(),
              name: z.string().optional(),
              order_nr: z.number().int().optional(),
              field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              last_updated_by_user_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              edit_flag: z.boolean().optional(),
              index_visible_flag: z.boolean().optional(),
              details_visible_flag: z.boolean().optional(),
              add_visible_flag: z.boolean().optional(),
              important_flag: z.boolean().optional(),
              bulk_edit_allowed: z.boolean().optional(),
              searchable_flag: z.boolean().optional(),
              filtering_allowed: z.boolean().optional(),
              sortable_flag: z.boolean().optional(),
              mandatory_flag: z.boolean().optional(),
              options: z.array(z.record(z.any())).nullable().optional(),
              options_deleted: z.array(z.record(z.any())).optional(),
              is_subfield: z.boolean().optional(),
              subfields: z.array(z.record(z.any())).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  updatePersonField: {
    /**
     * Update a person field 
     * @description Updates a person field. For more information, see the tutorial for <a href=" https://pipedrive.readme.io/docs/updating-custom-field-value " target="_blank" rel="noopener noreferrer">updating custom fields' values</a>.
     */
    parameters: {
        /** @description The ID of the field */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string().nullish(),
          options: z.array(z.record(z.any())).nullish(),
          add_visible_flag: z.boolean().nullish(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              key: z.string().optional(),
              name: z.string().optional(),
              order_nr: z.number().int().optional(),
              field_type: z.enum(["address", "date", "daterange", "double", "enum", "monetary", "org", "people", "phone", "set", "text", "time", "timerange", "user", "varchar", "varchar_auto", "visible_to"]).optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              last_updated_by_user_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              edit_flag: z.boolean().optional(),
              index_visible_flag: z.boolean().optional(),
              details_visible_flag: z.boolean().optional(),
              add_visible_flag: z.boolean().optional(),
              important_flag: z.boolean().optional(),
              bulk_edit_allowed: z.boolean().optional(),
              searchable_flag: z.boolean().optional(),
              filtering_allowed: z.boolean().optional(),
              sortable_flag: z.boolean().optional(),
              mandatory_flag: z.boolean().optional(),
              options: z.array(z.record(z.any())).nullable().optional(),
              options_deleted: z.array(z.record(z.any())).optional(),
              is_subfield: z.boolean().optional(),
              subfields: z.array(z.record(z.any())).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deletePersonField: {
    /**
     * Delete a person field 
     * @description Marks a field as deleted. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/deleting-a-custom-field" target="_blank" rel="noopener noreferrer">deleting a custom field</a>.
     */
    parameters: {
        /** @description The ID of the field */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPipelines: {
    /**
     * Get all pipelines 
     * @description Returns data about all pipelines.
     */
    responses: {
      /** @description Get all pipelines */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                url_title: z.string().optional(),
                order_nr: z.number().int().optional(),
                active: z.boolean().optional(),
                deal_probability: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              }), z.object({
                selected: z.boolean().optional(),
              }))).optional(),
          })),
        },
      },
    },
  },
  addPipeline: {
    /**
     * Add a new pipeline 
     * @description Adds a new pipeline.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string(),
          deal_probability: z.number().nullish(),
          order_nr: z.number().int().nullish(),
          active: z.number().nullish(),
        }),
      },
    },
    responses: {
      /** @description Add pipeline */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              url_title: z.string().optional(),
              order_nr: z.number().int().optional(),
              active: z.boolean().optional(),
              deal_probability: z.boolean().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPipeline: {
    /**
     * Get one pipeline 
     * @description Returns data about a specific pipeline. Also returns the summary of the deals in this pipeline across its stages.
     */
    parameters: {
        /** @description The 3-letter currency code of any of the supported currencies. When supplied, `per_stages_converted` is returned in `deals_summary` which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to `default_currency` in which case users default currency is used. */
      query: z.object({
        totals_convert_currency: z.string().optional(),
      }).optional(),
        /** @description The ID of the pipeline */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get pipeline */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.intersection(z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              url_title: z.string().optional(),
              order_nr: z.number().int().optional(),
              active: z.boolean().optional(),
              deal_probability: z.boolean().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }), z.object({
              selected: z.boolean().optional(),
            })), z.object({
              deals_summary: z.object({
                per_stages: z.object({
                  STAGE_ID: z.object({
                    CURRENCY_ID: z.object({
                      count: z.number().int().optional(),
                      value: z.number().int().optional(),
                      value_formatted: z.string().optional(),
                      weighted_value: z.number().int().optional(),
                      weighted_value_formatted: z.string().optional(),
                    }).optional(),
                  }).optional(),
                }).optional(),
                per_currency: z.object({
                  CURRENCY_ID: z.number().int().optional(),
                }).optional(),
                total_count: z.number().int().optional(),
                per_currency_full: z.object({
                  CURRENCY_ID: z.object({
                    count: z.number().int().optional(),
                    value: z.number().int().optional(),
                  }).optional(),
                }).optional(),
              }).optional(),
            })).optional(),
          })),
        },
      },
    },
  },
  updatePipeline: {
    /**
     * Update a pipeline 
     * @description Updates the properties of a pipeline.
     */
    parameters: {
        /** @description The ID of the pipeline */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string().nullish(),
          deal_probability: z.number().nullish(),
          order_nr: z.number().int().nullish(),
          active: z.number().nullish(),
        }),
      },
    },
    responses: {
      /** @description Edit pipeline */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              url_title: z.string().optional(),
              order_nr: z.number().int().optional(),
              active: z.boolean().optional(),
              deal_probability: z.boolean().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }), z.object({
              selected: z.boolean().optional(),
            })).optional(),
          })),
        },
      },
    },
  },
  deletePipeline: {
    /**
     * Delete a pipeline 
     * @description Marks a pipeline as deleted.
     */
    parameters: {
        /** @description The ID of the pipeline */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Delete pipeline */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getPipelineConversionStatistics: {
    /**
     * Get deals conversion rates in pipeline 
     * @description Returns all stage-to-stage conversion and pipeline-to-close rates for the given time period.
     */
    parameters: {
        /** @description The start of the period. Date in format of YYYY-MM-DD. */
        /** @description The end of the period. Date in format of YYYY-MM-DD. */
        /** @description The ID of the user who's pipeline metrics statistics to fetch. If omitted, the authorized user will be used. */
      query: z.object({
        start_date: z.string(),
        end_date: z.string(),
        user_id: z.number().int().optional(),
      }),
        /** @description The ID of the pipeline */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get pipeline deals conversion rates */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              stage_conversions: z.array(z.object({
                  from_stage_id: z.number().int().optional(),
                  to_stage_id: z.number().int().optional(),
                  conversion_rate: z.number().int().optional(),
                })).optional(),
              won_conversion: z.number().int().optional(),
              lost_conversion: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getPipelineDeals: {
    /**
     * Get deals in a pipeline 
     * @description Lists deals in a specific pipeline across all its stages.
     */
    parameters: {
        /** @description If supplied, only deals matching the given filter will be returned */
        /** @description If supplied, `filter_id` will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned. */
        /** @description If supplied, `filter_id` and `user_id` will not be considered  instead, deals owned by everyone will be returned */
        /** @description If supplied, only deals within the given stage will be returned */
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description Whether to include a summary of the pipeline in the `additional_data` or not */
        /** @description The 3-letter currency code of any of the supported currencies. When supplied, `per_stages_converted` is returned inside `deals_summary` inside `additional_data` which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to `default_currency` in which case users default currency is used. Only works when `get_summary` parameter flag is enabled. */
      query: z.object({
        filter_id: z.number().int().optional(),
        user_id: z.number().int().optional(),
        everyone: z.number().optional(),
        stage_id: z.number().int().optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        get_summary: z.number().optional(),
        totals_convert_currency: z.string().optional(),
      }).optional(),
        /** @description The ID of the pipeline */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get deals in a stage */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                creator_user_id: z.number().int().optional(),
                user_id: z.number().int().optional(),
                person_id: z.number().int().optional(),
                org_id: z.number().int().optional(),
              }), z.object({
                stage_id: z.number().int().optional(),
                title: z.string().optional(),
                value: z.number().optional(),
                currency: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                stage_change_time: z.string().optional(),
                active: z.boolean().optional(),
                deleted: z.boolean().optional(),
                status: z.string().optional(),
                probability: z.number().nullable().optional(),
                next_activity_date: z.string().optional(),
                next_activity_time: z.string().optional(),
                next_activity_id: z.number().int().nullable().optional(),
                last_activity_id: z.number().int().nullable().optional(),
                last_activity_date: z.string().nullable().optional(),
                lost_reason: z.string().nullable().optional(),
                visible_to: z.string().optional(),
                close_time: z.string().nullable().optional(),
                pipeline_id: z.number().int().optional(),
                won_time: z.string().optional(),
                first_won_time: z.string().optional(),
                lost_time: z.string().optional(),
                products_count: z.number().int().optional(),
                files_count: z.number().int().optional(),
                notes_count: z.number().int().optional(),
                followers_count: z.number().int().optional(),
                email_messages_count: z.number().int().optional(),
                activities_count: z.number().int().optional(),
                done_activities_count: z.number().int().optional(),
                undone_activities_count: z.number().int().optional(),
                participants_count: z.number().int().optional(),
                expected_close_date: z.string().optional(),
                last_incoming_mail_time: z.string().optional(),
                last_outgoing_mail_time: z.string().optional(),
                label: z.string().optional(),
                stage_order_nr: z.number().int().optional(),
                person_name: z.string().optional(),
                org_name: z.string().optional(),
                next_activity_subject: z.string().optional(),
                next_activity_type: z.string().optional(),
                next_activity_duration: z.string().optional(),
                next_activity_note: z.string().optional(),
                formatted_value: z.string().optional(),
                weighted_value: z.number().optional(),
                formatted_weighted_value: z.string().optional(),
                weighted_value_currency: z.string().optional(),
                rotten_time: z.string().nullable().optional(),
                owner_name: z.string().optional(),
                cc_email: z.string().optional(),
                org_hidden: z.boolean().optional(),
                person_hidden: z.boolean().optional(),
              }))).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getPipelineMovementStatistics: {
    /**
     * Get deals movements in pipeline 
     * @description Returns statistics for deals movements for the given time period.
     */
    parameters: {
        /** @description The start of the period. Date in format of YYYY-MM-DD. */
        /** @description The end of the period. Date in format of YYYY-MM-DD. */
        /** @description The ID of the user who's pipeline statistics to fetch. If omitted, the authorized user will be used. */
      query: z.object({
        start_date: z.string(),
        end_date: z.string(),
        user_id: z.number().int().optional(),
      }),
        /** @description The ID of the pipeline */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get pipeline deals conversion rates */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              movements_between_stages: z.object({
                count: z.number().int().optional(),
              }).optional(),
              new_deals: z.object({
                count: z.number().int().optional(),
                deals_ids: z.array(z.number().int()).optional(),
                values: z.object({
                  CURRENCY_ID: z.number().int().optional(),
                }).optional(),
                formatted_values: z.object({
                  CURRENCY_ID: z.string().optional(),
                }).optional(),
              }).optional(),
              deals_left_open: z.object({
                count: z.number().int().optional(),
                deals_ids: z.array(z.number().int()).optional(),
                values: z.object({
                  CURRENCY_ID: z.number().int().optional(),
                }).optional(),
                formatted_values: z.object({
                  CURRENCY_ID: z.string().optional(),
                }).optional(),
              }).optional(),
              won_deals: z.object({
                count: z.number().int().optional(),
                deals_ids: z.array(z.number().int()).optional(),
                values: z.object({
                  CURRENCY_ID: z.number().int().optional(),
                }).optional(),
                formatted_values: z.object({
                  CURRENCY_ID: z.string().optional(),
                }).optional(),
              }).optional(),
              lost_deals: z.object({
                count: z.number().int().optional(),
                deals_ids: z.array(z.number().int()).optional(),
                values: z.object({
                  CURRENCY_ID: z.number().int().optional(),
                }).optional(),
                formatted_values: z.object({
                  CURRENCY_ID: z.string().optional(),
                }).optional(),
              }).optional(),
              average_age_in_days: z.object({
                across_all_stages: z.number().int().optional(),
                by_stages: z.array(z.object({
                    stage_id: z.number().int().optional(),
                    value: z.number().int().optional(),
                  })).optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getProducts: {
    /**
     * Get all products 
     * @description Returns data about all products.
     */
    parameters: {
        /** @description If supplied, only products owned by the given user will be returned */
        /** @description The ID of the filter to use */
        /** @description An array of integers with the IDs of the products that should be returned in the response */
        /** @description If supplied, only products whose name starts with the specified letter will be returned (case-insensitive) */
        /** @description If supplied, the response will return the total numbers of products in the `additional_data.summary.total_count` property */
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        user_id: z.number().int().optional(),
        filter_id: z.number().int().optional(),
        ids: z.array(z.number().int()).optional(),
        first_char: z.string().optional(),
        get_summary: z.boolean().optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
    },
    responses: {
      /** @description List of products */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                success: z.boolean().optional(),
                data: z.intersection(z.object({
                  id: z.number().optional(),
                  name: z.string().optional(),
                  code: z.string().optional(),
                  unit: z.string().optional(),
                  tax: z.number().optional(),
                  active_flag: z.boolean().optional(),
                  selectable: z.boolean().optional(),
                  visible_to: z.enum(["1", "3", "5", "7"]).optional(),
                  owner_id: z.record(z.any()).optional(),
                }), z.object({
                  prices: z.array(z.record(z.any())).optional(),
                })).optional(),
                related_objects: z.object({
                  user: z.object({
                    USER_ID: z.intersection(z.object({
                      id: z.number().int().optional(),
                      name: z.string().optional(),
                      email: z.string().optional(),
                      has_pic: z.number().int().optional(),
                      pic_hash: z.string().nullable().optional(),
                      active_flag: z.boolean().optional(),
                    }), z.record(z.any())).optional(),
                  }).optional(),
                  deal: z.object({
                    DEAL_ID: z.object({
                      id: z.number().int().optional(),
                      title: z.string().optional(),
                      status: z.string().optional(),
                      value: z.number().optional(),
                      currency: z.string().optional(),
                      stage_id: z.number().int().optional(),
                      pipeline_id: z.number().int().optional(),
                    }).optional(),
                  }).optional(),
                  person: z.object({
                    PERSON_ID: z.object({
                      id: z.number().int().optional(),
                      name: z.string().optional(),
                      email: z.array(z.object({
                          label: z.string().optional(),
                          value: z.string().optional(),
                          primary: z.boolean().optional(),
                        })).optional(),
                      phone: z.array(z.object({
                          label: z.string().optional(),
                          value: z.string().optional(),
                          primary: z.boolean().optional(),
                        })).optional(),
                      owner_id: z.number().int().optional(),
                    }).optional(),
                  }).optional(),
                  organization: z.object({
                    ORGANIZATION_ID: z.intersection(z.object({
                      id: z.number().int().optional(),
                    }), z.object({
                      name: z.string().optional(),
                      people_count: z.number().int().optional(),
                      owner_id: z.number().int().optional(),
                      address: z.string().optional(),
                      cc_email: z.string().optional(),
                    })).optional(),
                  }).optional(),
                }).optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              deal: z.object({
                DEAL_ID: z.object({
                  id: z.number().int().optional(),
                  title: z.string().optional(),
                  status: z.string().optional(),
                  value: z.number().optional(),
                  currency: z.string().optional(),
                  stage_id: z.number().int().optional(),
                  pipeline_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  addProduct: {
    /**
     * Add a product 
     * @description Adds a new product to the Products inventory. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-product" target="_blank" rel="noopener noreferrer">adding a product</a>.
     */
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          name: z.string(),
        }), z.object({
          code: z.string().nullish(),
          unit: z.string().nullish(),
          tax: z.number().nullish(),
          active_flag: z.boolean().nullish(),
          selectable: z.boolean().nullish(),
          visible_to: z.string().nullish(),
          owner_id: z.number().int().nullish(),
          prices: z.array(z.record(z.any())).nullish(),
        })),
      },
    },
    responses: {
      /** @description Add product data */
      201: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().optional(),
              name: z.string().optional(),
              code: z.string().optional(),
              unit: z.string().optional(),
              tax: z.number().optional(),
              active_flag: z.boolean().optional(),
              selectable: z.boolean().optional(),
              visible_to: z.enum(["1", "3", "5", "7"]).optional(),
              owner_id: z.record(z.any()).optional(),
            }), z.object({
              prices: z.array(z.record(z.any())).optional(),
            })).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              deal: z.object({
                DEAL_ID: z.object({
                  id: z.number().int().optional(),
                  title: z.string().optional(),
                  status: z.string().optional(),
                  value: z.number().optional(),
                  currency: z.string().optional(),
                  stage_id: z.number().int().optional(),
                  pipeline_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  searchProducts: {
    /**
     * Search products 
     * @description Searches all products by name, code and/or custom fields. This endpoint is a wrapper of <a href="https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem">/v1/itemSearch</a> with a narrower OAuth scope.
     */
    parameters: {
        /** @description The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded. */
        /** @description A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: `address`, `varchar`, `text`, `varchar_auto`, `double`, `monetary` and `phone`. Read more about searching by custom fields <a href="https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields" target="_blank" rel="noopener noreferrer">here</a>. */
        /** @description When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive. */
        /** @description Supports including optional fields in the results which are not provided by default */
        /** @description Pagination start. Note that the pagination is based on main results and does not include related items when using `search_for_related_items` parameter. */
        /** @description Items shown per page */
      query: z.object({
        term: z.string(),
        fields: z.enum(["code", "custom_fields", "name"]).optional(),
        exact_match: z.boolean().optional(),
        include_fields: z.literal("product.price").optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              items: z.array(z.object({
                  result_score: z.number().optional(),
                  item: z.object({
                    id: z.number().int().optional(),
                    type: z.string().optional(),
                    name: z.string().optional(),
                    code: z.number().int().optional(),
                    visible_to: z.number().int().optional(),
                    owner: z.object({
                      id: z.number().int().optional(),
                    }).optional(),
                    custom_fields: z.array(z.string()).optional(),
                  }).optional(),
                })).optional(),
            }).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
                next_start: z.number().int().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getProduct: {
    /**
     * Get one product 
     * @description Returns data about a specific product.
     */
    parameters: {
        /** @description The ID of the product */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get product information by id */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().optional(),
              name: z.string().optional(),
              code: z.string().optional(),
              unit: z.string().optional(),
              tax: z.number().optional(),
              active_flag: z.boolean().optional(),
              selectable: z.boolean().optional(),
              visible_to: z.enum(["1", "3", "5", "7"]).optional(),
              owner_id: z.record(z.any()).optional(),
            }), z.object({
              prices: z.array(z.record(z.any())).optional(),
            })).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              deal: z.object({
                DEAL_ID: z.object({
                  id: z.number().int().optional(),
                  title: z.string().optional(),
                  status: z.string().optional(),
                  value: z.number().optional(),
                  currency: z.string().optional(),
                  stage_id: z.number().int().optional(),
                  pipeline_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  updateProduct: {
    /**
     * Update a product 
     * @description Updates product data.
     */
    parameters: {
        /** @description The ID of the product */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          name: z.string().nullish(),
        }), z.object({
          code: z.string().nullish(),
          unit: z.string().nullish(),
          tax: z.number().nullish(),
          active_flag: z.boolean().nullish(),
          selectable: z.boolean().nullish(),
          visible_to: z.string().nullish(),
          owner_id: z.number().int().nullish(),
          prices: z.array(z.record(z.any())).nullish(),
        })),
      },
    },
    responses: {
      /** @description Updates product data */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().optional(),
              name: z.string().optional(),
              code: z.string().optional(),
              unit: z.string().optional(),
              tax: z.number().optional(),
              active_flag: z.boolean().optional(),
              selectable: z.boolean().optional(),
              visible_to: z.enum(["1", "3", "5", "7"]).optional(),
              owner_id: z.record(z.any()).optional(),
            }), z.object({
              prices: z.record(z.any()).optional(),
            })).optional(),
            related_objects: z.object({
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              deal: z.object({
                DEAL_ID: z.object({
                  id: z.number().int().optional(),
                  title: z.string().optional(),
                  status: z.string().optional(),
                  value: z.number().optional(),
                  currency: z.string().optional(),
                  stage_id: z.number().int().optional(),
                  pipeline_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                }).optional(),
              }).optional(),
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                })).optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteProduct: {
    /**
     * Delete a product 
     * @description Marks a product as deleted. After 30 days, the product will be permanently deleted.
     */
    parameters: {
        /** @description The ID of the product */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Deletes a product */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getProductDeals: {
    /**
     * Get deals where a product is attached to 
     * @description Returns data about deals that have a product attached to it.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        status: z.enum(["open", "won", "lost", "deleted", "all_not_deleted"]).optional(),
      }).optional(),
        /** @description The ID of the product */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description The data of deals that have a product attached */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                creator_user_id: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.boolean().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                  value: z.number().int().optional(),
                }).optional(),
                user_id: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.boolean().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                person_id: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
                org_id: z.intersection(z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  active_flag: z.boolean().optional(),
                  cc_email: z.string().optional(),
                }), z.object({
                  value: z.number().int().optional(),
                })).optional(),
              }), z.object({
                stage_id: z.number().int().optional(),
                title: z.string().optional(),
                value: z.number().optional(),
                currency: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                stage_change_time: z.string().optional(),
                active: z.boolean().optional(),
                deleted: z.boolean().optional(),
                status: z.string().optional(),
                probability: z.number().nullable().optional(),
                next_activity_date: z.string().optional(),
                next_activity_time: z.string().optional(),
                next_activity_id: z.number().int().nullable().optional(),
                last_activity_id: z.number().int().nullable().optional(),
                last_activity_date: z.string().nullable().optional(),
                lost_reason: z.string().nullable().optional(),
                visible_to: z.string().optional(),
                close_time: z.string().nullable().optional(),
                pipeline_id: z.number().int().optional(),
                won_time: z.string().optional(),
                first_won_time: z.string().optional(),
                lost_time: z.string().optional(),
                products_count: z.number().int().optional(),
                files_count: z.number().int().optional(),
                notes_count: z.number().int().optional(),
                followers_count: z.number().int().optional(),
                email_messages_count: z.number().int().optional(),
                activities_count: z.number().int().optional(),
                done_activities_count: z.number().int().optional(),
                undone_activities_count: z.number().int().optional(),
                participants_count: z.number().int().optional(),
                expected_close_date: z.string().optional(),
                last_incoming_mail_time: z.string().optional(),
                last_outgoing_mail_time: z.string().optional(),
                label: z.string().optional(),
                stage_order_nr: z.number().int().optional(),
                person_name: z.string().optional(),
                org_name: z.string().optional(),
                next_activity_subject: z.string().optional(),
                next_activity_type: z.string().optional(),
                next_activity_duration: z.string().optional(),
                next_activity_note: z.string().optional(),
                formatted_value: z.string().optional(),
                weighted_value: z.number().optional(),
                formatted_weighted_value: z.string().optional(),
                weighted_value_currency: z.string().optional(),
                rotten_time: z.string().nullable().optional(),
                owner_name: z.string().optional(),
                cc_email: z.string().optional(),
                org_hidden: z.boolean().optional(),
                person_hidden: z.boolean().optional(),
              }))).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
            related_objects: z.object({
              organization: z.object({
                ORGANIZATION_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.intersection(z.object({
                  id: z.number().int().optional(),
                }), z.object({
                  name: z.string().optional(),
                  people_count: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  address: z.string().optional(),
                  cc_email: z.string().optional(),
                }))).optional(),
              }).optional(),
              person: z.object({
                PERSON_ID: z.intersection(z.object({
                  active_flag: z.boolean().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  phone: z.array(z.object({
                      label: z.string().optional(),
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                    })).optional(),
                  owner_id: z.number().int().optional(),
                })).optional(),
              }).optional(),
              user: z.object({
                USER_ID: z.intersection(z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  email: z.string().optional(),
                  has_pic: z.number().int().optional(),
                  pic_hash: z.string().nullable().optional(),
                  active_flag: z.boolean().optional(),
                }), z.record(z.any())).optional(),
              }).optional(),
              stage: z.object({
                id: z.number().int().optional(),
                order_nr: z.number().int().optional(),
                name: z.string().optional(),
                active_flag: z.boolean().optional(),
                deal_probability: z.number().int().optional(),
                pipeline_id: z.number().int().optional(),
                rotten_flag: z.boolean().optional(),
                rotten_days: z.number().int().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              }).optional(),
              pipeline: z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                url_title: z.string().optional(),
                order_nr: z.number().int().optional(),
                active: z.boolean().optional(),
                deal_probability: z.boolean().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getProductFiles: {
    /**
     * List files attached to a product 
     * @description Lists files associated with a product.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
        /** @description The field name and sorting mode (`field_name_1 ASC` or `field_name_1 DESC`). Supported fields: `update_time`, `id`. */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
        sort: z.string().optional(),
      }).optional(),
        /** @description The ID of the product */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                product_id: z.number().int().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                file_name: z.string().optional(),
                file_size: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                inline_flag: z.boolean().optional(),
                remote_location: z.string().optional(),
                remote_id: z.string().optional(),
                s3_bucket: z.string().optional(),
                product_name: z.string().optional(),
                url: z.string().optional(),
                name: z.string().optional(),
                description: z.string().optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getProductFollowers: {
    /**
     * List followers of a product 
     * @description Lists the followers of a product.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the product */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Lists the followers of a product */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                user_id: z.number().int().optional(),
                id: z.number().int().optional(),
                product_id: z.number().int().optional(),
                add_time: z.string().optional(),
              })).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addProductFollower: {
    /**
     * Add a follower to a product 
     * @description Adds a follower to a product.
     */
    parameters: {
        /** @description The ID of the product */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          user_id: z.number().int(),
        }),
      },
    },
    responses: {
      /** @description Adds a follower to a product */
      201: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              user_id: z.number().int().optional(),
              id: z.number().int().optional(),
              product_id: z.number().int().optional(),
              add_time: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteProductFollower: {
    /**
     * Delete a follower from a product 
     * @description Deletes a follower from a product.
     */
    parameters: {
        /** @description The ID of the product */
        /** @description The ID of the relationship between the follower and the product */
      path: z.object({
        id: z.number().int(),
        follower_id: z.number().int(),
      }),
    },
    responses: {
      /** @description Deletes a follower from a product */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getProductUsers: {
    /**
     * List permitted users 
     * @description Lists users permitted to access a product.
     */
    parameters: {
        /** @description The ID of the product */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Lists users permitted to access a product */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.number().int()).optional(),
          })),
        },
      },
    },
  },
  getProductFields: {
    /**
     * Get all product fields 
     * @description Returns data about all product fields.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
    },
    responses: {
      /** @description Get data about all product fields */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                name: z.string(),
                options: z.array(z.record(z.any())).optional(),
                field_type: z.enum(["varchar", "varchar_auto", "text", "double", "monetary", "date", "set", "enum", "user", "org", "people", "phone", "time", "timerange", "daterange", "address"]),
              }), z.object({
                id: z.number().int().optional(),
                key: z.string().optional(),
                order_nr: z.number().int().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                last_updated_by_user_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                edit_flag: z.boolean().optional(),
                add_visible_flag: z.boolean().optional(),
                important_flag: z.boolean().optional(),
                bulk_edit_allowed: z.boolean().optional(),
                searchable_flag: z.boolean().optional(),
                filtering_allowed: z.boolean().optional(),
                sortable_flag: z.boolean().optional(),
                mandatory_flag: z.boolean().optional(),
              }))).optional(),
            additional_data: z.record(z.any()).optional(),
          }),
        },
      },
    },
  },
  addProductField: {
    /**
     * Add a new product field 
     * @description Adds a new product field. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-new-custom-field" target="_blank" rel="noopener noreferrer">adding a new custom field</a>.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string(),
          options: z.array(z.record(z.any())).nullish(),
          field_type: z.enum(["varchar", "varchar_auto", "text", "double", "monetary", "date", "set", "enum", "user", "org", "people", "phone", "time", "timerange", "daterange", "address"]),
        }),
      },
    },
    responses: {
      /** @description Get the data for a single product field */
      201: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              name: z.string(),
              options: z.array(z.record(z.any())).optional(),
              field_type: z.enum(["varchar", "varchar_auto", "text", "double", "monetary", "date", "set", "enum", "user", "org", "people", "phone", "time", "timerange", "daterange", "address"]),
            }), z.object({
              id: z.number().int().optional(),
              key: z.string().optional(),
              order_nr: z.number().int().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              last_updated_by_user_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              edit_flag: z.boolean().optional(),
              add_visible_flag: z.boolean().optional(),
              important_flag: z.boolean().optional(),
              bulk_edit_allowed: z.boolean().optional(),
              searchable_flag: z.boolean().optional(),
              filtering_allowed: z.boolean().optional(),
              sortable_flag: z.boolean().optional(),
              mandatory_flag: z.boolean().optional(),
            })).optional(),
          }),
        },
      },
    },
  },
  deleteProductFields: {
    /**
     * Delete multiple product fields in bulk 
     * @description Marks multiple fields as deleted.
     */
    parameters: {
        /** @description The comma-separated field IDs to delete */
      query: z.object({
        ids: z.string(),
      }),
    },
    responses: {
      /** @description Mark multiple product fields as deleted */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.array(z.number().int()).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getProductField: {
    /**
     * Get one product field 
     * @description Returns data about a specific product field.
     */
    parameters: {
        /** @description The ID of the product field */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get the data for a single product field */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              name: z.string(),
              options: z.array(z.record(z.any())).optional(),
              field_type: z.enum(["varchar", "varchar_auto", "text", "double", "monetary", "date", "set", "enum", "user", "org", "people", "phone", "time", "timerange", "daterange", "address"]),
            }), z.object({
              id: z.number().int().optional(),
              key: z.string().optional(),
              order_nr: z.number().int().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              last_updated_by_user_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              edit_flag: z.boolean().optional(),
              add_visible_flag: z.boolean().optional(),
              important_flag: z.boolean().optional(),
              bulk_edit_allowed: z.boolean().optional(),
              searchable_flag: z.boolean().optional(),
              filtering_allowed: z.boolean().optional(),
              sortable_flag: z.boolean().optional(),
              mandatory_flag: z.boolean().optional(),
            })).optional(),
          }),
        },
      },
      /** @description The product field with the specified ID does not exist or is inaccessible */
      410: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  updateProductField: {
    /**
     * Update a product field 
     * @description Updates a product field. For more information, see the tutorial for <a href=" https://pipedrive.readme.io/docs/updating-custom-field-value " target="_blank" rel="noopener noreferrer">updating custom fields' values</a>.
     */
    parameters: {
        /** @description The ID of the product field */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string().nullish(),
          options: z.array(z.record(z.any())).nullish(),
        }),
      },
    },
    responses: {
      /** @description Get the data for a single product field */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              name: z.string(),
              options: z.array(z.record(z.any())).optional(),
              field_type: z.enum(["varchar", "varchar_auto", "text", "double", "monetary", "date", "set", "enum", "user", "org", "people", "phone", "time", "timerange", "daterange", "address"]),
            }), z.object({
              id: z.number().int().optional(),
              key: z.string().optional(),
              order_nr: z.number().int().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              last_updated_by_user_id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              edit_flag: z.boolean().optional(),
              add_visible_flag: z.boolean().optional(),
              important_flag: z.boolean().optional(),
              bulk_edit_allowed: z.boolean().optional(),
              searchable_flag: z.boolean().optional(),
              filtering_allowed: z.boolean().optional(),
              sortable_flag: z.boolean().optional(),
              mandatory_flag: z.boolean().optional(),
            })).optional(),
          }),
        },
      },
    },
  },
  deleteProductField: {
    /**
     * Delete a product field 
     * @description Marks a product field as deleted. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/deleting-a-custom-field" target="_blank" rel="noopener noreferrer">deleting a custom field</a>.
     */
    parameters: {
        /** @description The ID of the product field */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Delete a product field */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
      /** @description The product field with the specified ID does not exist or is inaccessible */
      410: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  getProjects: {
    /**
     * Get all projects 
     * @description Returns all projects. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>.
     */
    parameters: {
        /** @description For pagination, the marker (an opaque string value) representing the first item on the next page */
        /** @description For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. */
        /** @description The ID of the filter to use */
        /** @description If supplied, includes only projects with the specified statuses. Possible values are `open`, `completed`, `canceled` and `deleted`. By default `deleted` projects are not returned. */
        /** @description If supplied, only projects in specified phase are returned */
        /** @description If supplied with `true` then archived projects are also included in the response. By default only not archived projects are returned. */
      query: z.object({
        cursor: z.string().optional(),
        limit: z.number().int().optional(),
        filter_id: z.number().int().optional(),
        status: z.string().optional(),
        phase_id: z.number().int().optional(),
        include_archived: z.boolean().optional(),
      }).optional(),
    },
    responses: {
      /** @description A list of projects. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
              }), z.intersection(z.object({
                title: z.string().optional(),
                board_id: z.number().optional(),
                phase_id: z.number().optional(),
              }), z.object({
                description: z.string().optional(),
                status: z.string().optional(),
                owner_id: z.number().optional(),
                start_date: z.string().optional(),
                end_date: z.string().optional(),
                deal_ids: z.array(z.number().int()).optional(),
                org_id: z.number().optional(),
                person_id: z.number().optional(),
                labels: z.array(z.number().int()).optional(),
              }), z.object({
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                status_change_time: z.string().optional(),
                archive_time: z.string().optional(),
              })))).optional(),
            additional_data: z.object({
              next_cursor: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  addProject: {
    /**
     * Add a project 
     * @description Adds a new project. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys.
     */
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          title: z.string(),
          board_id: z.number(),
          phase_id: z.number(),
        }), z.object({
          description: z.string().nullish(),
          status: z.string().nullish(),
          owner_id: z.number().nullish(),
          start_date: z.string().nullish(),
          end_date: z.string().nullish(),
          deal_ids: z.array(z.number().int()).nullish(),
          org_id: z.number().nullish(),
          person_id: z.number().nullish(),
          labels: z.array(z.number().int()).nullish(),
        }), z.object({
          template_id: z.number().nullish(),
        })),
      },
    },
    responses: {
      /** @description Created project. */
      201: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().int().optional(),
            }), z.intersection(z.object({
              title: z.string().optional(),
              board_id: z.number().optional(),
              phase_id: z.number().optional(),
            }), z.object({
              description: z.string().optional(),
              status: z.string().optional(),
              owner_id: z.number().optional(),
              start_date: z.string().optional(),
              end_date: z.string().optional(),
              deal_ids: z.array(z.number().int()).optional(),
              org_id: z.number().optional(),
              person_id: z.number().optional(),
              labels: z.array(z.number().int()).optional(),
            }), z.object({
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              status_change_time: z.string().optional(),
              archive_time: z.string().optional(),
            }))).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getProject: {
    /**
     * Get details of a project 
     * @description Returns the details of a specific project. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of project fields.
     */
    parameters: {
        /** @description The ID of the project */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get a project. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().int().optional(),
            }), z.intersection(z.object({
              title: z.string().optional(),
              board_id: z.number().optional(),
              phase_id: z.number().optional(),
            }), z.object({
              description: z.string().optional(),
              status: z.string().optional(),
              owner_id: z.number().optional(),
              start_date: z.string().optional(),
              end_date: z.string().optional(),
              deal_ids: z.array(z.number().int()).optional(),
              org_id: z.number().optional(),
              person_id: z.number().optional(),
              labels: z.array(z.number().int()).optional(),
            }), z.object({
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              status_change_time: z.string().optional(),
              archive_time: z.string().optional(),
            }))).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  updateProject: {
    /**
     * Update a project 
     * @description Updates a project.
     */
    parameters: {
        /** @description The ID of the project */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          title: z.string().nullish(),
          board_id: z.number().nullish(),
          phase_id: z.number().nullish(),
        }), z.object({
          description: z.string().nullish(),
          status: z.string().nullish(),
          owner_id: z.number().nullish(),
          start_date: z.string().nullish(),
          end_date: z.string().nullish(),
          deal_ids: z.array(z.number().int()).nullish(),
          org_id: z.number().nullish(),
          person_id: z.number().nullish(),
          labels: z.array(z.number().int()).nullish(),
        })),
      },
    },
    responses: {
      /** @description Updated project. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().int().optional(),
            }), z.intersection(z.object({
              title: z.string().optional(),
              board_id: z.number().optional(),
              phase_id: z.number().optional(),
            }), z.object({
              description: z.string().optional(),
              status: z.string().optional(),
              owner_id: z.number().optional(),
              start_date: z.string().optional(),
              end_date: z.string().optional(),
              deal_ids: z.array(z.number().int()).optional(),
              org_id: z.number().optional(),
              person_id: z.number().optional(),
              labels: z.array(z.number().int()).optional(),
            }), z.object({
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              status_change_time: z.string().optional(),
              archive_time: z.string().optional(),
            }))).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  deleteProject: {
    /**
     * Delete a project 
     * @description Marks a project as deleted.
     */
    parameters: {
        /** @description The ID of the project */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Delete a project. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              success: z.boolean().optional(),
              data: z.object({
                id: z.number().int().optional(),
              }).optional(),
            }).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  archiveProject: {
    /**
     * Archive a project 
     * @description Archives a project.
     */
    parameters: {
        /** @description The ID of the project */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Updated project. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().int().optional(),
            }), z.intersection(z.object({
              title: z.string().optional(),
              board_id: z.number().optional(),
              phase_id: z.number().optional(),
            }), z.object({
              description: z.string().optional(),
              status: z.string().optional(),
              owner_id: z.number().optional(),
              start_date: z.string().optional(),
              end_date: z.string().optional(),
              deal_ids: z.array(z.number().int()).optional(),
              org_id: z.number().optional(),
              person_id: z.number().optional(),
              labels: z.array(z.number().int()).optional(),
            }), z.object({
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              status_change_time: z.string().optional(),
              archive_time: z.string().optional(),
            }))).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getProjectPlan: {
    /**
     * Returns project plan 
     * @description Returns information about items in a project plan. Items consists of tasks and activities and are linked to specific project phase and group.
     */
    parameters: {
        /** @description The ID of the project */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get a project plan. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                item_id: z.number().optional(),
                item_type: z.string().optional(),
                phase_id: z.number().optional(),
                group_id: z.number().optional(),
              })).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  putProjectPlanActivity: {
    /**
     * Update activity in project plan 
     * @description Updates an activity phase or group in a project.
     */
    parameters: {
        /** @description The ID of the project */
        /** @description The ID of the activity */
      path: z.object({
        id: z.number().int(),
        activityId: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          phase_id: z.number().nullish(),
          group_id: z.number().nullish(),
        }),
      },
    },
    responses: {
      /** @description Updated activity in plan. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              item_id: z.number().optional(),
              item_type: z.string().optional(),
              phase_id: z.number().optional(),
              group_id: z.number().optional(),
            }).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  putProjectPlanTask: {
    /**
     * Update task in project plan 
     * @description Updates a task phase or group in a project.
     */
    parameters: {
        /** @description The ID of the project */
        /** @description The ID of the task */
      path: z.object({
        id: z.number().int(),
        taskId: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          phase_id: z.number().nullish(),
          group_id: z.number().nullish(),
        }),
      },
    },
    responses: {
      /** @description Updated task in plan. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              item_id: z.number().optional(),
              item_type: z.string().optional(),
              phase_id: z.number().optional(),
              group_id: z.number().optional(),
            }).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getProjectGroups: {
    /**
     * Returns project groups 
     * @description Returns all active groups under a specific project.
     */
    parameters: {
        /** @description The ID of the project */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get a project groups. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                id: z.number().optional(),
                name: z.string().optional(),
                order_nr: z.number().optional(),
              })).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getProjectTasks: {
    /**
     * Returns project tasks 
     * @description Returns tasks linked to a specific project.
     */
    parameters: {
        /** @description The ID of the project */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description A list of tasks. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
              }), z.intersection(z.object({
                title: z.string().optional(),
                project_id: z.number().optional(),
              }), z.object({
                description: z.string().optional(),
                parent_task_id: z.number().optional(),
                assignee_id: z.number().optional(),
                done: z.number().optional(),
                due_date: z.string().optional(),
              }), z.object({
                creator_id: z.number().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                marked_as_done_time: z.string().optional(),
              })))).optional(),
            additional_data: z.object({
              next_cursor: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getProjectActivities: {
    /**
     * Returns project activities 
     * @description Returns activities linked to a specific project.
     */
    parameters: {
        /** @description The ID of the project */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description A list of activities */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                due_date: z.string().optional(),
                due_time: z.string().optional(),
                duration: z.string().optional(),
                deal_id: z.number().int().optional(),
                lead_id: z.string().nullable().optional(),
                person_id: z.number().int().optional(),
                project_id: z.number().int().nullable().optional(),
                org_id: z.number().int().optional(),
                location: z.string().optional(),
                public_description: z.string().optional(),
              }), z.object({
                id: z.number().int().optional(),
                done: z.boolean().optional(),
                subject: z.string().optional(),
                type: z.string().optional(),
                user_id: z.number().int().optional(),
                busy_flag: z.boolean().optional(),
                company_id: z.number().int().optional(),
                conference_meeting_client: z.string().optional(),
                conference_meeting_url: z.string().optional(),
                conference_meeting_id: z.string().optional(),
                add_time: z.string().optional(),
                marked_as_done_time: z.string().optional(),
                active_flag: z.boolean().optional(),
                update_time: z.string().optional(),
                update_user_id: z.number().int().optional(),
                source_timezone: z.string().optional(),
                location_subpremise: z.string().optional(),
                location_street_number: z.string().optional(),
                location_route: z.string().optional(),
                location_sublocality: z.string().optional(),
                location_locality: z.string().optional(),
                location_admin_area_level_1: z.string().optional(),
                location_admin_area_level_2: z.string().optional(),
                location_country: z.string().optional(),
                location_postal_code: z.string().optional(),
                location_formatted_address: z.string().optional(),
              }))).optional(),
            additional_data: z.object({
              next_cursor: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getProjectsBoards: {
    /**
     * Get all project boards 
     * @description Returns all projects boards that are not deleted.
     */
    responses: {
      /** @description A list of project board. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                order_nr: z.number().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              })).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getProjectsBoard: {
    /**
     * Get details of a board 
     * @description Returns the details of a specific project board.
     */
    parameters: {
        /** @description The ID of the project board */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get a project board. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              order_nr: z.number().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getProjectsPhases: {
    /**
     * Get project phases 
     * @description Returns all active project phases under a specific board.
     */
    parameters: {
        /** @description ID of the board for which phases are requested */
      query: z.object({
        board_id: z.number().int(),
      }),
    },
    responses: {
      /** @description A list of project phases. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                board_id: z.number().optional(),
                order_nr: z.number().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              })).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getProjectsPhase: {
    /**
     * Get details of a phase 
     * @description Returns the details of a specific project phase.
     */
    parameters: {
        /** @description The ID of the project phase */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get a project phase. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              board_id: z.number().optional(),
              order_nr: z.number().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getProjectTemplates: {
    /**
     * Get all project templates 
     * @description Returns all not deleted project templates. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>.
     */
    parameters: {
        /** @description For pagination, the marker (an opaque string value) representing the first item on the next page */
        /** @description For pagination, the limit of entries to be returned. If not provided, up to 500 items will be returned. */
      query: z.object({
        cursor: z.string().optional(),
        limit: z.number().int().optional(),
      }).optional(),
    },
    responses: {
      /** @description A list of project template. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.object({
                id: z.number().optional(),
                title: z.string().optional(),
                description: z.string().optional(),
                projects_board_id: z.number().optional(),
                owner_id: z.number().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              })).optional(),
            additional_data: z.object({
              next_cursor: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getProjectTemplate: {
    /**
     * Get details of a template 
     * @description Returns the details of a specific project template.
     */
    parameters: {
        /** @description The ID of the project template */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get a project template. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().optional(),
              title: z.string().optional(),
              description: z.string().optional(),
              projects_board_id: z.number().optional(),
              owner_id: z.number().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getRecents: {
    /**
     * Get recents 
     * @description Returns data about all recent changes occurred after the given timestamp.
     */
    parameters: {
        /** @description The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS. */
        /** @description Multiple selection of item types to include in the query (optional) */
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        since_timestamp: z.string(),
        items: z.enum(["activity", "activityType", "deal", "file", "filter", "note", "person", "organization", "pipeline", "product", "stage", "user"]).optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }),
    },
    responses: {
      /** @description List of items changed since "since_timestamp" */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.union([z.object({
                item: z.literal("activity").optional(),
                id: z.number().int().optional(),
                data: z.intersection(z.object({
                  due_date: z.string().optional(),
                  due_time: z.string().optional(),
                  duration: z.string().optional(),
                  deal_id: z.number().int().optional(),
                  lead_id: z.string().nullable().optional(),
                  person_id: z.number().int().optional(),
                  project_id: z.number().int().nullable().optional(),
                  org_id: z.number().int().optional(),
                  location: z.string().optional(),
                  public_description: z.string().optional(),
                }), z.object({
                  id: z.number().int().optional(),
                  note: z.string().optional(),
                  done: z.boolean().optional(),
                  subject: z.string().optional(),
                  type: z.string().optional(),
                  user_id: z.number().int().optional(),
                  participants: z.array(z.record(z.any())).nullable().optional(),
                  busy_flag: z.boolean().optional(),
                  attendees: z.array(z.record(z.any())).nullable().optional(),
                  company_id: z.number().int().optional(),
                  reference_type: z.string().optional(),
                  reference_id: z.number().int().optional(),
                  conference_meeting_client: z.string().optional(),
                  conference_meeting_url: z.string().optional(),
                  conference_meeting_id: z.string().optional(),
                  add_time: z.string().optional(),
                  marked_as_done_time: z.string().optional(),
                  last_notification_time: z.string().optional(),
                  last_notification_user_id: z.number().int().optional(),
                  notification_language_id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  update_time: z.string().optional(),
                  update_user_id: z.number().int().optional(),
                  gcal_event_id: z.string().optional(),
                  google_calendar_id: z.string().optional(),
                  google_calendar_etag: z.string().optional(),
                  calendar_sync_include_context: z.string().optional(),
                  source_timezone: z.string().optional(),
                  rec_rule: z.string().optional(),
                  rec_rule_extension: z.string().optional(),
                  rec_master_activity_id: z.number().int().optional(),
                  series: z.array(z.record(z.any())).optional(),
                  created_by_user_id: z.number().int().optional(),
                  location_subpremise: z.string().optional(),
                  location_street_number: z.string().optional(),
                  location_route: z.string().optional(),
                  location_sublocality: z.string().optional(),
                  location_locality: z.string().optional(),
                  location_admin_area_level_1: z.string().optional(),
                  location_admin_area_level_2: z.string().optional(),
                  location_country: z.string().optional(),
                  location_postal_code: z.string().optional(),
                  location_formatted_address: z.string().optional(),
                  org_name: z.string().optional(),
                  person_name: z.string().optional(),
                  deal_title: z.string().optional(),
                  owner_name: z.string().optional(),
                  person_dropbox_bcc: z.string().optional(),
                  deal_dropbox_bcc: z.string().optional(),
                  assigned_to_user_id: z.number().int().optional(),
                  file: z.record(z.any()).optional(),
                })).optional(),
              }), z.object({
                item: z.literal("activityType").optional(),
                id: z.number().int().optional(),
                data: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  icon_key: z.enum(["task", "email", "meeting", "deadline", "call", "lunch", "calendar", "downarrow", "document", "smartphone", "camera", "scissors", "cogs", "bubble", "uparrow", "checkbox", "signpost", "shuffle", "addressbook", "linegraph", "picture", "car", "world", "search", "clip", "sound", "brush", "key", "padlock", "pricetag", "suitcase", "finish", "plane", "loop", "wifi", "truck", "cart", "bulb", "bell", "presentation"]).optional(),
                  color: z.string().optional(),
                  order_nr: z.number().int().optional(),
                  key_string: z.string().optional(),
                  active_flag: z.boolean().optional(),
                  is_custom_flag: z.boolean().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                }).optional(),
              }), z.object({
                item: z.literal("deal").optional(),
                id: z.number().int().optional(),
                data: z.intersection(z.object({
                  id: z.number().int().optional(),
                  creator_user_id: z.number().int().optional(),
                  user_id: z.number().int().optional(),
                  person_id: z.number().int().optional(),
                  org_id: z.number().int().optional(),
                }), z.object({
                  stage_id: z.number().int().optional(),
                  title: z.string().optional(),
                  value: z.number().optional(),
                  currency: z.string().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  stage_change_time: z.string().optional(),
                  active: z.boolean().optional(),
                  deleted: z.boolean().optional(),
                  status: z.string().optional(),
                  probability: z.number().nullable().optional(),
                  next_activity_date: z.string().optional(),
                  next_activity_time: z.string().optional(),
                  next_activity_id: z.number().int().nullable().optional(),
                  last_activity_id: z.number().int().nullable().optional(),
                  last_activity_date: z.string().nullable().optional(),
                  lost_reason: z.string().nullable().optional(),
                  visible_to: z.string().optional(),
                  close_time: z.string().nullable().optional(),
                  pipeline_id: z.number().int().optional(),
                  won_time: z.string().optional(),
                  first_won_time: z.string().optional(),
                  lost_time: z.string().optional(),
                  products_count: z.number().int().optional(),
                  files_count: z.number().int().optional(),
                  notes_count: z.number().int().optional(),
                  followers_count: z.number().int().optional(),
                  email_messages_count: z.number().int().optional(),
                  activities_count: z.number().int().optional(),
                  done_activities_count: z.number().int().optional(),
                  undone_activities_count: z.number().int().optional(),
                  participants_count: z.number().int().optional(),
                  expected_close_date: z.string().optional(),
                  last_incoming_mail_time: z.string().optional(),
                  last_outgoing_mail_time: z.string().optional(),
                  label: z.string().optional(),
                  stage_order_nr: z.number().int().optional(),
                  person_name: z.string().optional(),
                  org_name: z.string().optional(),
                  next_activity_subject: z.string().optional(),
                  next_activity_type: z.string().optional(),
                  next_activity_duration: z.string().optional(),
                  next_activity_note: z.string().optional(),
                  formatted_value: z.string().optional(),
                  weighted_value: z.number().optional(),
                  formatted_weighted_value: z.string().optional(),
                  weighted_value_currency: z.string().optional(),
                  rotten_time: z.string().nullable().optional(),
                  owner_name: z.string().optional(),
                  cc_email: z.string().optional(),
                  org_hidden: z.boolean().optional(),
                  person_hidden: z.boolean().optional(),
                })).optional(),
              }), z.object({
                item: z.literal("file").optional(),
                id: z.number().int().optional(),
                data: z.object({
                  id: z.number().int().optional(),
                  user_id: z.number().int().optional(),
                  deal_id: z.number().int().optional(),
                  person_id: z.number().int().optional(),
                  org_id: z.number().int().optional(),
                  product_id: z.number().int().optional(),
                  activity_id: z.number().int().optional(),
                  lead_id: z.string().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  file_name: z.string().optional(),
                  file_size: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  inline_flag: z.boolean().optional(),
                  remote_location: z.string().optional(),
                  remote_id: z.string().optional(),
                  cid: z.string().optional(),
                  s3_bucket: z.string().optional(),
                  mail_message_id: z.string().optional(),
                  mail_template_id: z.string().optional(),
                  deal_name: z.string().optional(),
                  person_name: z.string().optional(),
                  org_name: z.string().optional(),
                  product_name: z.string().optional(),
                  lead_name: z.string().optional(),
                  url: z.string().optional(),
                  name: z.string().optional(),
                  description: z.string().optional(),
                }).optional(),
              }), z.object({
                item: z.literal("filter").optional(),
                id: z.number().int().optional(),
                data: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  active_flag: z.boolean().optional(),
                  type: z.string().optional(),
                  user_id: z.number().int().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  visible_to: z.number().int().optional(),
                  custom_view_id: z.number().int().optional(),
                }).optional(),
              }), z.object({
                item: z.literal("note").optional(),
                id: z.number().int().optional(),
                data: z.object({
                  id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  add_time: z.string().optional(),
                  content: z.string().optional(),
                  deal: z.object({
                    title: z.string().optional(),
                  }).optional(),
                  lead_id: z.string().optional(),
                  deal_id: z.number().int().optional(),
                  last_update_user_id: z.number().int().optional(),
                  org_id: z.number().int().optional(),
                  organization: z.object({
                    name: z.string().optional(),
                  }).optional(),
                  person: z.object({
                    name: z.string().optional(),
                  }).optional(),
                  person_id: z.number().int().optional(),
                  pinned_to_deal_flag: z.boolean().optional(),
                  pinned_to_organization_flag: z.boolean().optional(),
                  pinned_to_person_flag: z.boolean().optional(),
                  update_time: z.string().optional(),
                  user: z.object({
                    email: z.string().optional(),
                    icon_url: z.string().optional(),
                    is_you: z.boolean().optional(),
                    name: z.string().optional(),
                  }).optional(),
                  user_id: z.number().int().optional(),
                }).optional(),
              }), z.object({
                item: z.literal("person").optional(),
                id: z.number().int().optional(),
                data: z.intersection(z.object({
                  id: z.number().int().optional(),
                  company_id: z.number().int().optional(),
                  active_flag: z.boolean().optional(),
                  phone: z.array(z.object({
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                      label: z.string().optional(),
                    })).optional(),
                  email: z.array(z.object({
                      value: z.string().optional(),
                      primary: z.boolean().optional(),
                      label: z.string().optional(),
                    })).optional(),
                  first_char: z.string().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  visible_to: z.string().optional(),
                  picture_id: z.intersection(z.object({
                    id: z.number().int().optional(),
                  }), z.object({
                    item_type: z.string().optional(),
                    item_id: z.number().int().optional(),
                    active_flag: z.boolean().optional(),
                    add_time: z.string().optional(),
                    update_time: z.string().optional(),
                    added_by_user_id: z.number().int().optional(),
                    pictures: z.object({
                      128: z.string().optional(),
                      512: z.string().optional(),
                    }).optional(),
                  })).optional(),
                  label: z.number().int().optional(),
                  org_name: z.string().optional(),
                  owner_name: z.string().optional(),
                  cc_email: z.string().optional(),
                }), z.intersection(z.intersection(z.object({
                  owner_id: z.number().int().optional(),
                  org_id: z.number().int().optional(),
                  merge_what_id: z.number().int().optional(),
                }), z.intersection(z.object({
                  name: z.string().optional(),
                  first_name: z.string().optional(),
                  last_name: z.string().optional(),
                }), z.intersection(z.object({
                  email_messages_count: z.number().int().optional(),
                  activities_count: z.number().int().optional(),
                  done_activities_count: z.number().int().optional(),
                  undone_activities_count: z.number().int().optional(),
                  files_count: z.number().int().optional(),
                  notes_count: z.number().int().optional(),
                  followers_count: z.number().int().optional(),
                }), z.object({
                  last_incoming_mail_time: z.string().optional(),
                  last_outgoing_mail_time: z.string().optional(),
                })))), z.intersection(z.intersection(z.object({
                  open_deals_count: z.number().int().optional(),
                  related_open_deals_count: z.number().int().optional(),
                  closed_deals_count: z.number().int().optional(),
                  related_closed_deals_count: z.number().int().optional(),
                  won_deals_count: z.number().int().optional(),
                  related_won_deals_count: z.number().int().optional(),
                  lost_deals_count: z.number().int().optional(),
                  related_lost_deals_count: z.number().int().optional(),
                }), z.object({
                  next_activity_date: z.string().nullable().optional(),
                  next_activity_time: z.string().nullable().optional(),
                  next_activity_id: z.number().int().nullable().optional(),
                  last_activity_id: z.number().int().nullable().optional(),
                  last_activity_date: z.string().nullable().optional(),
                })), z.object({
                  participant_open_deals_count: z.number().int().optional(),
                  participant_closed_deals_count: z.number().int().optional(),
                })))).optional(),
              }), z.object({
                item: z.literal("organization").optional(),
                id: z.number().int().optional(),
                data: z.intersection(z.object({
                  id: z.number().int().optional(),
                  company_id: z.number().int().optional(),
                  owner_id: z.intersection(z.object({
                    id: z.number().int().optional(),
                    name: z.string().optional(),
                    email: z.string().optional(),
                    has_pic: z.number().int().optional(),
                    pic_hash: z.string().nullable().optional(),
                    active_flag: z.boolean().optional(),
                  }), z.object({
                    value: z.number().int().optional(),
                  })).optional(),
                  name: z.string().optional(),
                  active_flag: z.boolean().optional(),
                  picture_id: z.intersection(z.object({
                    value: z.number().int().optional(),
                  }), z.object({
                    item_type: z.string().optional(),
                    item_id: z.number().int().optional(),
                    active_flag: z.boolean().optional(),
                    add_time: z.string().optional(),
                    update_time: z.string().optional(),
                    added_by_user_id: z.number().int().optional(),
                    pictures: z.object({
                      128: z.string().optional(),
                      512: z.string().optional(),
                    }).optional(),
                  })).optional(),
                  country_code: z.string().optional(),
                  first_char: z.string().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  visible_to: z.string().optional(),
                  label: z.number().int().optional(),
                  owner_name: z.string().optional(),
                  cc_email: z.string().optional(),
                }), z.intersection(z.intersection(z.object({
                  email_messages_count: z.number().int().optional(),
                  people_count: z.number().int().optional(),
                  activities_count: z.number().int().optional(),
                  done_activities_count: z.number().int().optional(),
                  undone_activities_count: z.number().int().optional(),
                  files_count: z.number().int().optional(),
                  notes_count: z.number().int().optional(),
                  followers_count: z.number().int().optional(),
                }), z.object({
                  address: z.string().optional(),
                  address_subpremise: z.string().optional(),
                  address_street_number: z.string().optional(),
                  address_route: z.string().optional(),
                  address_sublocality: z.string().optional(),
                  address_locality: z.string().optional(),
                  address_admin_area_level_1: z.string().optional(),
                  address_admin_area_level_2: z.string().optional(),
                  address_country: z.string().optional(),
                  address_postal_code: z.string().optional(),
                  address_formatted_address: z.string().optional(),
                })), z.intersection(z.object({
                  open_deals_count: z.number().int().optional(),
                  related_open_deals_count: z.number().int().optional(),
                  closed_deals_count: z.number().int().optional(),
                  related_closed_deals_count: z.number().int().optional(),
                  won_deals_count: z.number().int().optional(),
                  related_won_deals_count: z.number().int().optional(),
                  lost_deals_count: z.number().int().optional(),
                  related_lost_deals_count: z.number().int().optional(),
                }), z.object({
                  next_activity_date: z.string().nullable().optional(),
                  next_activity_time: z.string().nullable().optional(),
                  next_activity_id: z.number().int().nullable().optional(),
                  last_activity_id: z.number().int().nullable().optional(),
                  last_activity_date: z.string().nullable().optional(),
                })))).optional(),
              }), z.object({
                item: z.literal("pipeline").optional(),
                id: z.number().int().optional(),
                data: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  url_title: z.string().optional(),
                  order_nr: z.number().int().optional(),
                  active: z.boolean().optional(),
                  deal_probability: z.boolean().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                }).optional(),
              }), z.object({
                item: z.literal("product").optional(),
                id: z.number().int().optional(),
                data: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  code: z.string().optional(),
                  description: z.string().optional(),
                  unit: z.string().optional(),
                  tax: z.number().optional(),
                  category: z.string().optional(),
                  active_flag: z.boolean().optional(),
                  selectable: z.boolean().optional(),
                  first_char: z.string().optional(),
                  visible_to: z.number().int().optional(),
                  owner_id: z.number().int().optional(),
                  files_count: z.number().int().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                  prices: z.array(z.record(z.any())).optional(),
                }).optional(),
              }), z.object({
                item: z.literal("stage").optional(),
                id: z.number().int().optional(),
                data: z.object({
                  id: z.number().int().optional(),
                  order_nr: z.number().int().optional(),
                  name: z.string().optional(),
                  active_flag: z.boolean().optional(),
                  deal_probability: z.number().int().optional(),
                  pipeline_id: z.number().int().optional(),
                  rotten_flag: z.boolean().optional(),
                  rotten_days: z.number().int().optional(),
                  add_time: z.string().optional(),
                  update_time: z.string().optional(),
                }).optional(),
              }), z.object({
                item: z.literal("user").optional(),
                id: z.number().int().optional(),
                data: z.object({
                  id: z.number().int().optional(),
                  name: z.string().optional(),
                  default_currency: z.string().optional(),
                  locale: z.string().optional(),
                  lang: z.number().int().optional(),
                  email: z.string().optional(),
                  phone: z.string().nullable().optional(),
                  activated: z.boolean().optional(),
                  last_login: z.string().optional(),
                  created: z.string().optional(),
                  modified: z.string().nullable().optional(),
                  has_created_company: z.boolean().optional(),
                  access: z.array(z.object({
                      app: z.enum(["sales", "projects", "campaigns", "global", "account_settings"]).optional(),
                      admin: z.boolean().optional(),
                      permission_set_id: z.string().optional(),
                    })).optional(),
                  active_flag: z.boolean().optional(),
                  timezone_name: z.string().optional(),
                  timezone_offset: z.string().optional(),
                  role_id: z.number().int().optional(),
                  icon_url: z.string().nullable().optional(),
                  is_you: z.boolean().optional(),
                }).optional(),
              })])).optional(),
            additional_data: z.object({
              since_timestamp: z.string().optional(),
              last_timestamp_on_page: z.string().optional(),
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
              }).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getRoles: {
    /**
     * Get all roles 
     * @description Returns all the roles within the company.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
    },
    responses: {
      /** @description Get all roles */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.intersection(z.object({
                parent_role_id: z.number().int().optional(),
                name: z.string().optional(),
              }), z.object({
                id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                assignment_count: z.string().optional(),
                sub_role_count: z.string().optional(),
              })), z.object({
                level: z.number().int().optional(),
              }))).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addRole: {
    /**
     * Add a role 
     * @description Adds a new role.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string(),
          parent_role_id: z.number().int().nullish(),
        }),
      },
    },
    responses: {
      /** @description Add a role */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getRole: {
    /**
     * Get one role 
     * @description Returns the details of a specific role.
     */
    parameters: {
        /** @description The ID of the role */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get one role */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              parent_role_id: z.number().int().optional(),
              name: z.string().optional(),
            }), z.object({
              id: z.number().int().optional(),
              active_flag: z.boolean().optional(),
              assignment_count: z.string().optional(),
              sub_role_count: z.string().optional(),
            })).optional(),
            additional_data: z.object({
              settings: z.object({
                deal_default_visibility: z.number().optional(),
                lead_default_visibility: z.number().optional(),
                org_default_visibility: z.number().optional(),
                person_default_visibility: z.number().optional(),
                product_default_visibility: z.number().optional(),
                deal_access_level: z.number().optional(),
                org_access_level: z.number().optional(),
                person_access_level: z.number().optional(),
                product_access_level: z.number().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  updateRole: {
    /**
     * Update role details 
     * @description Updates the parent role and/or the name of a specific role.
     */
    parameters: {
        /** @description The ID of the role */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          parent_role_id: z.number().int().nullish(),
          name: z.string().nullish(),
        }),
      },
    },
    responses: {
      /** @description Update role details */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteRole: {
    /**
     * Delete a role 
     * @description Marks a role as deleted.
     */
    parameters: {
        /** @description The ID of the role */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Delete a role */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getRoleAssignments: {
    /**
     * List role assignments 
     * @description Returns all users assigned to a role.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the role */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description List assignments for a role */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                parent_role_id: z.number().int().optional(),
                name: z.string().optional(),
              }), z.object({
                user_id: z.number().int().optional(),
                role_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                type: z.string().optional(),
              }))).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addRoleAssignment: {
    /**
     * Add role assignment 
     * @description Assigns a user to a role.
     */
    parameters: {
        /** @description The ID of the role */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          user_id: z.number().int(),
        }),
      },
    },
    responses: {
      /** @description Add assignment for a role */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              user_id: z.number().int().optional(),
              role_id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteRoleAssignment: {
    /**
     * Delete a role assignment 
     * @description Removes the assigned user from a role and adds to the default role.
     */
    parameters: {
        /** @description The ID of the role */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          user_id: z.number().int(),
        }),
      },
    },
    responses: {
      /** @description Delete assignment from a role */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getRoleSettings: {
    /**
     * List role settings 
     * @description Returns the visibility settings of a specific role.
     */
    parameters: {
        /** @description The ID of the role */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description List role settings */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              deal_default_visibility: z.number().optional(),
              lead_default_visibility: z.number().optional(),
              org_default_visibility: z.number().optional(),
              person_default_visibility: z.number().optional(),
              product_default_visibility: z.number().optional(),
              deal_access_level: z.number().optional(),
              org_access_level: z.number().optional(),
              person_access_level: z.number().optional(),
              product_access_level: z.number().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addOrUpdateRoleSetting: {
    /**
     * Add or update role setting 
     * @description Adds or updates the visibility setting for a role.
     */
    parameters: {
        /** @description The ID of the role */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          setting_key: z.enum(["deal_default_visibility", "lead_default_visibility", "org_default_visibility", "person_default_visibility", "product_default_visibility"]),
          value: z.enum(['1', '3', '5', '7']),
        }),
      },
    },
    responses: {
      /** @description List role settings */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              deal_default_visibility: z.number().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getRolePipelines: {
    /**
     * List pipeline visibility for a role 
     * @description Returns the list of either visible or hidden pipeline IDs for a specific role. For more information on pipeline visibility, please refer to the <a href="https://support.pipedrive.com/en/article/visibility-groups" target="_blank" rel="noopener noreferrer">Visibility groups article</a>.
     */
    parameters: {
        /** @description Whether to return the visible or hidden pipelines for the role */
      query: z.object({
        visible: z.boolean().optional(),
      }).optional(),
        /** @description The ID of the role */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get either visible or hidden pipeline ids for a role */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              pipeline_ids: z.array(z.number()).optional(),
              visible: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  updateRolePipelines: {
    /**
     * Update pipeline visibility for a role 
     * @description Updates the specified pipelines to be visible and/or hidden for a specific role. For more information on pipeline visibility, please refer to the <a href="https://support.pipedrive.com/en/article/visibility-groups" target="_blank" rel="noopener noreferrer">Visibility groups article</a>.
     */
    parameters: {
        /** @description The ID of the role */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          visible_pipeline_ids: z.record(z.any()),
        }),
      },
    },
    responses: {
      /** @description Update pipeline visibility for a role */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              pipeline_ids: z.array(z.number()).optional(),
              visible: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getStages: {
    /**
     * Get all stages 
     * @description Returns data about all stages.
     */
    parameters: {
        /** @description The ID of the pipeline to fetch stages for. If omitted, stages for all pipelines will be fetched. */
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        pipeline_id: z.number().int().optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
    },
    responses: {
      /** @description Get all stages */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                order_nr: z.number().int().optional(),
                name: z.string().optional(),
                active_flag: z.boolean().optional(),
                deal_probability: z.number().int().optional(),
                pipeline_id: z.number().int().optional(),
                rotten_flag: z.boolean().optional(),
                rotten_days: z.number().int().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
              }), z.object({
                pipeline_name: z.string().optional(),
                pipeline_deal_probability: z.boolean().optional(),
              }))).optional(),
          }),
        },
      },
    },
  },
  addStage: {
    /**
     * Add a new stage 
     * @description Adds a new stage, returns the ID upon success.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          name: z.string(),
          pipeline_id: z.number().int(),
          deal_probability: z.number().int().nullish(),
          rotten_flag: z.boolean().nullish(),
          rotten_days: z.number().int().nullish(),
        }),
      },
    },
    responses: {
      /** @description Get all stages */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
              order_nr: z.number().int().optional(),
              name: z.string().optional(),
              active_flag: z.boolean().optional(),
              deal_probability: z.number().int().optional(),
              pipeline_id: z.number().int().optional(),
              rotten_flag: z.boolean().optional(),
              rotten_days: z.number().int().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteStages: {
    /**
     * Delete multiple stages in bulk 
     * @description Marks multiple stages as deleted.
     */
    parameters: {
        /** @description The comma-separated stage IDs to delete */
      query: z.object({
        ids: z.string(),
      }),
    },
    responses: {
      /** @description Delete multiple stages */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.array(z.number().int()).optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getStage: {
    /**
     * Get one stage 
     * @description Returns data about a specific stage.
     */
    parameters: {
        /** @description If `everyone=1` is provided, deals summary will return deals owned by every user */
      query: z.object({
        everyone: z.number().optional(),
      }).optional(),
        /** @description The ID of the stage */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get stage */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              order_nr: z.number().int().optional(),
              name: z.string().optional(),
              active_flag: z.boolean().optional(),
              deal_probability: z.number().int().optional(),
              pipeline_id: z.number().int().optional(),
              rotten_flag: z.boolean().optional(),
              rotten_days: z.number().int().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }), z.object({
              deals_summary: z.object({
                per_stages: z.object({
                  STAGE_ID: z.object({
                    CURRENCY_ID: z.object({
                      count: z.number().int().optional(),
                      value: z.number().int().optional(),
                      value_formatted: z.string().optional(),
                      weighted_value: z.number().int().optional(),
                      weighted_value_formatted: z.string().optional(),
                    }).optional(),
                  }).optional(),
                }).optional(),
                per_currency: z.object({
                  CURRENCY_ID: z.number().int().optional(),
                }).optional(),
                total_count: z.number().int().optional(),
                per_currency_full: z.object({
                  CURRENCY_ID: z.object({
                    count: z.number().int().optional(),
                    value: z.number().int().optional(),
                  }).optional(),
                }).optional(),
              }).optional(),
            })).optional(),
          }),
        },
      },
    },
  },
  updateStage: {
    /**
     * Update stage details 
     * @description Updates the properties of a stage.
     */
    parameters: {
        /** @description The ID of the stage */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          name: z.string().nullish(),
          pipeline_id: z.number().int().nullish(),
          deal_probability: z.number().int().nullish(),
          rotten_flag: z.boolean().nullish(),
          rotten_days: z.number().int().nullish(),
        }), z.object({
          order_nr: z.number().int().nullish(),
        })),
      },
    },
    responses: {
      /** @description Get all stages */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
              order_nr: z.number().int().optional(),
              name: z.string().optional(),
              active_flag: z.boolean().optional(),
              deal_probability: z.number().int().optional(),
              pipeline_id: z.number().int().optional(),
              rotten_flag: z.boolean().optional(),
              rotten_days: z.number().int().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  deleteStage: {
    /**
     * Delete a stage 
     * @description Marks a stage as deleted.
     */
    parameters: {
        /** @description The ID of the stage */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Delete stage */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              id: z.number().int().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getStageDeals: {
    /**
     * Get deals in a stage 
     * @description Lists deals in a specific stage.
     */
    parameters: {
        /** @description If supplied, only deals matching the given filter will be returned */
        /** @description If supplied, `filter_id` will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned. */
        /** @description If supplied, `filter_id` and `user_id` will not be considered  instead, deals owned by everyone will be returned */
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        filter_id: z.number().int().optional(),
        user_id: z.number().int().optional(),
        everyone: z.number().optional(),
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the stage */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get deals in a stage */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
                creator_user_id: z.number().int().optional(),
                user_id: z.number().int().optional(),
                person_id: z.number().int().optional(),
                org_id: z.number().int().optional(),
              }), z.object({
                stage_id: z.number().int().optional(),
                title: z.string().optional(),
                value: z.number().optional(),
                currency: z.string().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                stage_change_time: z.string().optional(),
                active: z.boolean().optional(),
                deleted: z.boolean().optional(),
                status: z.string().optional(),
                probability: z.number().nullable().optional(),
                next_activity_date: z.string().optional(),
                next_activity_time: z.string().optional(),
                next_activity_id: z.number().int().nullable().optional(),
                last_activity_id: z.number().int().nullable().optional(),
                last_activity_date: z.string().nullable().optional(),
                lost_reason: z.string().nullable().optional(),
                visible_to: z.string().optional(),
                close_time: z.string().nullable().optional(),
                pipeline_id: z.number().int().optional(),
                won_time: z.string().optional(),
                first_won_time: z.string().optional(),
                lost_time: z.string().optional(),
                products_count: z.number().int().optional(),
                files_count: z.number().int().optional(),
                notes_count: z.number().int().optional(),
                followers_count: z.number().int().optional(),
                email_messages_count: z.number().int().optional(),
                activities_count: z.number().int().optional(),
                done_activities_count: z.number().int().optional(),
                undone_activities_count: z.number().int().optional(),
                participants_count: z.number().int().optional(),
                expected_close_date: z.string().optional(),
                last_incoming_mail_time: z.string().optional(),
                last_outgoing_mail_time: z.string().optional(),
                label: z.string().optional(),
                stage_order_nr: z.number().int().optional(),
                person_name: z.string().optional(),
                org_name: z.string().optional(),
                next_activity_subject: z.string().optional(),
                next_activity_type: z.string().optional(),
                next_activity_duration: z.string().optional(),
                next_activity_note: z.string().optional(),
                formatted_value: z.string().optional(),
                weighted_value: z.number().optional(),
                formatted_weighted_value: z.string().optional(),
                weighted_value_currency: z.string().optional(),
                rotten_time: z.string().nullable().optional(),
                owner_name: z.string().optional(),
                cc_email: z.string().optional(),
                org_hidden: z.boolean().optional(),
                person_hidden: z.boolean().optional(),
              }))).optional(),
            additional_data: z.object({
              start: z.number().int().optional(),
              limit: z.number().int().optional(),
              more_items_in_collection: z.boolean().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  getSubscription: {
    /**
     * Get details of a subscription 
     * @description Returns details of an installment or a recurring subscription.
     */
    parameters: {
        /** @description The ID of the subscription */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              description: z.string().optional(),
              is_active: z.boolean().optional(),
              cycles_count: z.number().int().optional(),
              cycle_amount: z.number().int().optional(),
              infinite: z.boolean().optional(),
              currency: z.string().optional(),
              cadence_type: z.string().optional(),
              start_date: z.string().optional(),
              end_date: z.string().optional(),
              lifetime_value: z.number().optional(),
              final_status: z.string().nullable().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  deleteSubscription: {
    /**
     * Delete a subscription 
     * @description Marks an installment or a recurring subscription as deleted.
     */
    parameters: {
        /** @description The ID of the subscription */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              description: z.string().optional(),
              is_active: z.boolean().optional(),
              cycles_count: z.number().int().optional(),
              cycle_amount: z.number().int().optional(),
              infinite: z.boolean().optional(),
              currency: z.string().optional(),
              cadence_type: z.string().optional(),
              start_date: z.string().optional(),
              end_date: z.string().optional(),
              lifetime_value: z.number().optional(),
              final_status: z.string().nullable().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  findSubscriptionByDeal: {
    /**
     * Find subscription by deal 
     * @description Returns details of an installment or a recurring subscription by the deal ID.
     */
    parameters: {
        /** @description The ID of the deal */
      path: z.object({
        dealId: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              description: z.string().optional(),
              is_active: z.boolean().optional(),
              cycles_count: z.number().int().optional(),
              cycle_amount: z.number().int().optional(),
              infinite: z.boolean().optional(),
              currency: z.string().optional(),
              cadence_type: z.string().optional(),
              start_date: z.string().optional(),
              end_date: z.string().optional(),
              lifetime_value: z.number().optional(),
              final_status: z.string().nullable().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getSubscriptionPayments: {
    /**
     * Get all payments of a subscription 
     * @description Returns all payments of an installment or recurring subscription.
     */
    parameters: {
        /** @description The ID of the subscription */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.record(z.any()).optional(),
          })),
        },
      },
    },
  },
  addRecurringSubscription: {
    /**
     * Add a recurring subscription 
     * @description Adds a new recurring subscription.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          deal_id: z.number().int(),
          currency: z.string(),
          description: z.string().nullish(),
          cadence_type: z.enum(["weekly", "monthly", "quarterly", "yearly"]),
          cycles_count: z.number().int().nullish(),
          cycle_amount: z.number().int(),
          start_date: z.string(),
          infinite: z.boolean().nullish(),
          payments: z.array(z.record(z.any())).nullish(),
          update_deal_value: z.boolean().nullish(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              description: z.string().optional(),
              is_active: z.boolean().optional(),
              cycles_count: z.number().int().optional(),
              cycle_amount: z.number().int().optional(),
              infinite: z.boolean().optional(),
              currency: z.string().optional(),
              cadence_type: z.string().optional(),
              start_date: z.string().optional(),
              end_date: z.string().optional(),
              lifetime_value: z.number().optional(),
              final_status: z.string().nullable().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  addSubscriptionInstallment: {
    /**
     * Add an installment subscription 
     * @description Adds a new installment subscription.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          deal_id: z.number().int(),
          currency: z.string(),
          payments: z.array(z.record(z.any())),
          update_deal_value: z.boolean().nullish(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              description: z.string().optional(),
              is_active: z.boolean().optional(),
              cycles_count: z.number().int().optional(),
              cycle_amount: z.number().int().optional(),
              infinite: z.boolean().optional(),
              currency: z.string().optional(),
              cadence_type: z.string().optional(),
              start_date: z.string().optional(),
              end_date: z.string().optional(),
              lifetime_value: z.number().optional(),
              final_status: z.string().nullable().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  updateRecurringSubscription: {
    /**
     * Update a recurring subscription 
     * @description Updates a recurring subscription.
     */
    parameters: {
        /** @description The ID of the subscription */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          description: z.string().nullish(),
          cycle_amount: z.number().int().nullish(),
          payments: z.array(z.record(z.any())).nullish(),
          update_deal_value: z.boolean().nullish(),
          effective_date: z.string(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              description: z.string().optional(),
              is_active: z.boolean().optional(),
              cycles_count: z.number().int().optional(),
              cycle_amount: z.number().int().optional(),
              infinite: z.boolean().optional(),
              currency: z.string().optional(),
              cadence_type: z.string().optional(),
              start_date: z.string().optional(),
              end_date: z.string().optional(),
              lifetime_value: z.number().optional(),
              final_status: z.string().nullable().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  updateSubscriptionInstallment: {
    /**
     * Update an installment subscription 
     * @description Updates an installment subscription.
     */
    parameters: {
        /** @description The ID of the subscription */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          payments: z.array(z.record(z.any())),
          update_deal_value: z.boolean().nullish(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              description: z.string().optional(),
              is_active: z.boolean().optional(),
              cycles_count: z.number().int().optional(),
              cycle_amount: z.number().int().optional(),
              infinite: z.boolean().optional(),
              currency: z.string().optional(),
              cadence_type: z.string().optional(),
              start_date: z.string().optional(),
              end_date: z.string().optional(),
              lifetime_value: z.number().optional(),
              final_status: z.string().nullable().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  cancelRecurringSubscription: {
    /**
     * Cancel a recurring subscription 
     * @description Cancels a recurring subscription.
     */
    parameters: {
        /** @description The ID of the subscription */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          end_date: z.string().nullish(),
        }),
      },
    },
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              deal_id: z.number().int().optional(),
              description: z.string().optional(),
              is_active: z.boolean().optional(),
              cycles_count: z.number().int().optional(),
              cycle_amount: z.number().int().optional(),
              infinite: z.boolean().optional(),
              currency: z.string().optional(),
              cadence_type: z.string().optional(),
              start_date: z.string().optional(),
              end_date: z.string().optional(),
              lifetime_value: z.number().optional(),
              final_status: z.string().nullable().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getTasks: {
    /**
     * Get all tasks 
     * @description Returns all tasks. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>.
     */
    parameters: {
        /** @description For pagination, the marker (an opaque string value) representing the first item on the next page */
        /** @description For pagination, the limit of entries to be returned. If not provided, up to 500 items will be returned. */
        /** @description If supplied, only tasks that are assigned to this user are returned */
        /** @description If supplied, only tasks that are assigned to this project are returned */
        /** @description If `null` is supplied then only parent tasks are returned. If integer is supplied then only subtasks of a specific task are returned. By default all tasks are returned. */
        /** @description Whether the task is done or not. `0` = Not done, `1` = Done. If not omitted then returns both done and not done tasks. */
      query: z.object({
        cursor: z.string().optional(),
        limit: z.number().int().optional(),
        assignee_id: z.number().int().optional(),
        project_id: z.number().int().optional(),
        parent_task_id: z.number().int().optional(),
        done: z.number().optional(),
      }).optional(),
    },
    responses: {
      /** @description A list of tasks. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.array(z.intersection(z.object({
                id: z.number().int().optional(),
              }), z.intersection(z.object({
                title: z.string().optional(),
                project_id: z.number().optional(),
              }), z.object({
                description: z.string().optional(),
                parent_task_id: z.number().optional(),
                assignee_id: z.number().optional(),
                done: z.number().optional(),
                due_date: z.string().optional(),
              }), z.object({
                creator_id: z.number().optional(),
                add_time: z.string().optional(),
                update_time: z.string().optional(),
                marked_as_done_time: z.string().optional(),
              })))).optional(),
            additional_data: z.object({
              next_cursor: z.string().optional(),
            }).optional(),
          }),
        },
      },
    },
  },
  addTask: {
    /**
     * Add a task 
     * @description Adds a new task.
     */
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          title: z.string(),
          project_id: z.number(),
        }), z.object({
          description: z.string().nullish(),
          parent_task_id: z.number().nullish(),
          assignee_id: z.number().nullish(),
          done: z.number().nullish(),
          due_date: z.string().nullish(),
        })),
      },
    },
    responses: {
      /** @description Created task. */
      201: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().int().optional(),
            }), z.intersection(z.object({
              title: z.string().optional(),
              project_id: z.number().optional(),
            }), z.object({
              description: z.string().optional(),
              parent_task_id: z.number().optional(),
              assignee_id: z.number().optional(),
              done: z.number().optional(),
              due_date: z.string().optional(),
            }), z.object({
              creator_id: z.number().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              marked_as_done_time: z.string().optional(),
            }))).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getTask: {
    /**
     * Get details of a task 
     * @description Returns the details of a specific task.
     */
    parameters: {
        /** @description The ID of the task */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Get a task. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().int().optional(),
            }), z.intersection(z.object({
              title: z.string().optional(),
              project_id: z.number().optional(),
            }), z.object({
              description: z.string().optional(),
              parent_task_id: z.number().optional(),
              assignee_id: z.number().optional(),
              done: z.number().optional(),
              due_date: z.string().optional(),
            }), z.object({
              creator_id: z.number().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              marked_as_done_time: z.string().optional(),
            }))).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  updateTask: {
    /**
     * Update a task 
     * @description Updates a task.
     */
    parameters: {
        /** @description The ID of the task */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.intersection(z.object({
          title: z.string().nullish(),
          project_id: z.number().nullish(),
        }), z.object({
          description: z.string().nullish(),
          parent_task_id: z.number().nullish(),
          assignee_id: z.number().nullish(),
          done: z.number().nullish(),
          due_date: z.string().nullish(),
        })),
      },
    },
    responses: {
      /** @description Updated task. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.intersection(z.object({
              id: z.number().int().optional(),
            }), z.intersection(z.object({
              title: z.string().optional(),
              project_id: z.number().optional(),
            }), z.object({
              description: z.string().optional(),
              parent_task_id: z.number().optional(),
              assignee_id: z.number().optional(),
              done: z.number().optional(),
              due_date: z.string().optional(),
            }), z.object({
              creator_id: z.number().optional(),
              add_time: z.string().optional(),
              update_time: z.string().optional(),
              marked_as_done_time: z.string().optional(),
            }))).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  deleteTask: {
    /**
     * Delete a task 
     * @description Marks a task as deleted. If the task has subtasks then those will also be deleted.
     */
    parameters: {
        /** @description The ID of the task */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description Deleted task. */
      200: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            data: z.object({
              success: z.boolean().optional(),
              data: z.object({
                id: z.number().int().optional(),
              }).optional(),
            }).optional(),
            additional_data: z.record(z.unknown()).nullable().optional(),
          }),
        },
      },
    },
  },
  getUsers: {
    /**
     * Get all users 
     * @description Returns data about all users within the company.
     */
    responses: {
      /** @description The list of user objects */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                default_currency: z.string().optional(),
                locale: z.string().optional(),
                lang: z.number().int().optional(),
                email: z.string().optional(),
                phone: z.string().nullable().optional(),
                activated: z.boolean().optional(),
                last_login: z.string().optional(),
                created: z.string().optional(),
                modified: z.string().nullable().optional(),
                has_created_company: z.boolean().optional(),
                access: z.array(z.object({
                    app: z.enum(["sales", "projects", "campaigns", "global", "account_settings"]).optional(),
                    admin: z.boolean().optional(),
                    permission_set_id: z.string().optional(),
                  })).optional(),
                active_flag: z.boolean().optional(),
                timezone_name: z.string().optional(),
                timezone_offset: z.string().optional(),
                role_id: z.number().int().optional(),
                icon_url: z.string().nullable().optional(),
                is_you: z.boolean().optional(),
              })).optional(),
          })),
        },
      },
    },
  },
  addUser: {
    /**
     * Add a new user 
     * @description Adds a new user to the company, returns the ID upon success.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          email: z.string(),
          access: z.array(z.object({
              app: z.enum(["sales", "projects", "campaigns", "global", "account_settings"]),
              admin: z.boolean().nullish(),
              permission_set_id: z.string().nullish(),
            })).nullish(),
          active_flag: z.boolean().nullish(),
        }),
      },
    },
    responses: {
      /** @description The data of the user */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              default_currency: z.string().optional(),
              locale: z.string().optional(),
              lang: z.number().int().optional(),
              email: z.string().optional(),
              phone: z.string().nullable().optional(),
              activated: z.boolean().optional(),
              last_login: z.string().optional(),
              created: z.string().optional(),
              modified: z.string().nullable().optional(),
              has_created_company: z.boolean().optional(),
              access: z.array(z.object({
                  app: z.enum(["sales", "projects", "campaigns", "global", "account_settings"]).optional(),
                  admin: z.boolean().optional(),
                  permission_set_id: z.string().optional(),
                })).optional(),
              active_flag: z.boolean().optional(),
              timezone_name: z.string().optional(),
              timezone_offset: z.string().optional(),
              role_id: z.number().int().optional(),
              icon_url: z.string().nullable().optional(),
              is_you: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
      /** @description Forbidden response */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  findUsersByName: {
    /**
     * Find users by name 
     * @description Finds users by their name.
     */
    parameters: {
        /** @description The search term to look for */
        /** @description When enabled, the term will only be matched against email addresses of users. Default: `false`. */
      query: z.object({
        term: z.string(),
        search_by_email: z.number().optional(),
      }),
    },
    responses: {
      /** @description The list of user objects */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                name: z.string().optional(),
                default_currency: z.string().optional(),
                locale: z.string().optional(),
                lang: z.number().int().optional(),
                email: z.string().optional(),
                phone: z.string().nullable().optional(),
                activated: z.boolean().optional(),
                last_login: z.string().optional(),
                created: z.string().optional(),
                modified: z.string().nullable().optional(),
                has_created_company: z.boolean().optional(),
                access: z.array(z.object({
                    app: z.enum(["sales", "projects", "campaigns", "global", "account_settings"]).optional(),
                    admin: z.boolean().optional(),
                    permission_set_id: z.string().optional(),
                  })).optional(),
                active_flag: z.boolean().optional(),
                timezone_name: z.string().optional(),
                timezone_offset: z.string().optional(),
                role_id: z.number().int().optional(),
                icon_url: z.string().nullable().optional(),
                is_you: z.boolean().optional(),
              })).optional(),
          })),
        },
      },
    },
  },
  getCurrentUser: {
    /**
     * Get current user data 
     * @description Returns data about an authorized user within the company with bound company data: company ID, company name, and domain. Note that the `locale` property means 'Date/number format' in the Pipedrive account settings, not the chosen language.
     */
    responses: {
      /** @description The data of the logged in user */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.intersection(z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              default_currency: z.string().optional(),
              locale: z.string().optional(),
              lang: z.number().int().optional(),
              email: z.string().optional(),
              phone: z.string().nullable().optional(),
              activated: z.boolean().optional(),
              last_login: z.string().optional(),
              created: z.string().optional(),
              modified: z.string().nullable().optional(),
              has_created_company: z.boolean().optional(),
              access: z.array(z.object({
                  app: z.enum(["sales", "projects", "campaigns", "global", "account_settings"]).optional(),
                  admin: z.boolean().optional(),
                  permission_set_id: z.string().optional(),
                })).optional(),
              active_flag: z.boolean().optional(),
              timezone_name: z.string().optional(),
              timezone_offset: z.string().optional(),
              role_id: z.number().int().optional(),
              icon_url: z.string().nullable().optional(),
              is_you: z.boolean().optional(),
            }), z.object({
              company_id: z.number().int().optional(),
              company_name: z.string().optional(),
              company_domain: z.string().optional(),
              company_country: z.string().optional(),
              company_industry: z.string().optional(),
              language: z.object({
                language_code: z.string().optional(),
                country_code: z.string().optional(),
              }).optional(),
            })).optional(),
          })),
        },
      },
      /** @description Unauthorized response */
      401: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            errorCode: z.number().int().optional(),
          }),
        },
      },
    },
  },
  getUser: {
    /**
     * Get one user 
     * @description Returns data about a specific user within the company.
     */
    parameters: {
        /** @description The ID of the user */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description The data of the user */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              default_currency: z.string().optional(),
              locale: z.string().optional(),
              lang: z.number().int().optional(),
              email: z.string().optional(),
              phone: z.string().nullable().optional(),
              activated: z.boolean().optional(),
              last_login: z.string().optional(),
              created: z.string().optional(),
              modified: z.string().nullable().optional(),
              has_created_company: z.boolean().optional(),
              access: z.array(z.object({
                  app: z.enum(["sales", "projects", "campaigns", "global", "account_settings"]).optional(),
                  admin: z.boolean().optional(),
                  permission_set_id: z.string().optional(),
                })).optional(),
              active_flag: z.boolean().optional(),
              timezone_name: z.string().optional(),
              timezone_offset: z.string().optional(),
              role_id: z.number().int().optional(),
              icon_url: z.string().nullable().optional(),
              is_you: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
      /** @description User with specified ID does not exist or is inaccessible */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  updateUser: {
    /**
     * Update user details 
     * @description Updates the properties of a user. Currently, only `active_flag` can be updated.
     */
    parameters: {
        /** @description The ID of the user */
      path: z.object({
        id: z.number().int(),
      }),
    },
    requestBody: {
      content: {
        "application/json": z.object({
          active_flag: z.boolean(),
        }),
      },
    },
    responses: {
      /** @description The data of the user */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
              default_currency: z.string().optional(),
              locale: z.string().optional(),
              lang: z.number().int().optional(),
              email: z.string().optional(),
              phone: z.string().nullable().optional(),
              activated: z.boolean().optional(),
              last_login: z.string().optional(),
              created: z.string().optional(),
              modified: z.string().nullable().optional(),
              has_created_company: z.boolean().optional(),
              access: z.array(z.object({
                  app: z.enum(["sales", "projects", "campaigns", "global", "account_settings"]).optional(),
                  admin: z.boolean().optional(),
                  permission_set_id: z.string().optional(),
                })).optional(),
              active_flag: z.boolean().optional(),
              timezone_name: z.string().optional(),
              timezone_offset: z.string().optional(),
              role_id: z.number().int().optional(),
              icon_url: z.string().nullable().optional(),
              is_you: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
      /** @description Forbidden response */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
      /** @description User with specified ID does not exist or is inaccessible */
      404: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  getUserFollowers: {
    /**
     * List followers of a user 
     * @description Lists the followers of a specific user.
     */
    parameters: {
        /** @description The ID of the user */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description The list of user IDs */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.number().int()).optional(),
          })),
        },
      },
      /** @description Forbidden response */
      403: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
          }),
        },
      },
    },
  },
  getUserPermissions: {
    /**
     * List user permissions 
     * @description Lists aggregated permissions over all assigned permission sets for a user.
     */
    parameters: {
        /** @description The ID of the user */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description The list of user permissions */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              can_add_custom_fields: z.boolean().optional(),
              can_add_products: z.boolean().optional(),
              can_add_prospects_as_leads: z.boolean().optional(),
              can_bulk_edit_items: z.boolean().optional(),
              can_change_visibility_of_items: z.boolean().optional(),
              can_convert_deals_to_leads: z.boolean().optional(),
              can_create_own_workflow: z.boolean().optional(),
              can_delete_activities: z.boolean().optional(),
              can_delete_custom_fields: z.boolean().optional(),
              can_delete_deals: z.boolean().optional(),
              can_edit_custom_fields: z.boolean().optional(),
              can_edit_deals_closed_date: z.boolean().optional(),
              can_edit_products: z.boolean().optional(),
              can_edit_shared_filters: z.boolean().optional(),
              can_export_data_from_lists: z.boolean().optional(),
              can_follow_other_users: z.boolean().optional(),
              can_merge_deals: z.boolean().optional(),
              can_merge_organizations: z.boolean().optional(),
              can_merge_people: z.boolean().optional(),
              can_modify_labels: z.boolean().optional(),
              can_see_company_wide_statistics: z.boolean().optional(),
              can_see_deals_list_summary: z.boolean().optional(),
              can_see_hidden_items_names: z.boolean().optional(),
              can_see_other_users: z.boolean().optional(),
              can_see_other_users_statistics: z.boolean().optional(),
              can_see_security_dashboard: z.boolean().optional(),
              can_share_filters: z.boolean().optional(),
              can_share_insights: z.boolean().optional(),
              can_use_api: z.boolean().optional(),
              can_use_email_tracking: z.boolean().optional(),
              can_use_import: z.boolean().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getUserRoleAssignments: {
    /**
     * List role assignments 
     * @description Lists role assignments for a user.
     */
    parameters: {
        /** @description Pagination start */
        /** @description Items shown per page */
      query: z.object({
        start: z.number().int().optional(),
        limit: z.number().int().optional(),
      }).optional(),
        /** @description The ID of the user */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description List assignments for a role */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.array(z.intersection(z.object({
                parent_role_id: z.number().int().optional(),
                name: z.string().optional(),
              }), z.object({
                user_id: z.number().int().optional(),
                role_id: z.number().int().optional(),
                active_flag: z.boolean().optional(),
                type: z.string().optional(),
              }))).optional(),
            additional_data: z.object({
              pagination: z.object({
                start: z.number().int().optional(),
                limit: z.number().int().optional(),
                more_items_in_collection: z.boolean().optional(),
              }).optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getUserRoleSettings: {
    /**
     * List user role settings 
     * @description Lists the settings of user's assigned role.
     */
    parameters: {
        /** @description The ID of the user */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description List role settings */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              deal_default_visibility: z.number().optional(),
              lead_default_visibility: z.number().optional(),
              org_default_visibility: z.number().optional(),
              person_default_visibility: z.number().optional(),
              product_default_visibility: z.number().optional(),
              deal_access_level: z.number().optional(),
              org_access_level: z.number().optional(),
              person_access_level: z.number().optional(),
              product_access_level: z.number().optional(),
            }).optional(),
          })),
        },
      },
    },
  },
  getUserConnections: {
    /**
     * Get all user connections 
     * @description Returns data about all connections for the authorized user.
     */
    responses: {
      /** @description The data of user connections */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              google: z.string().optional(),
            }).optional(),
          })),
        },
      },
      /** @description Unauthorized response */
      401: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            errorCode: z.number().int().optional(),
          }),
        },
      },
    },
  },
  getUserSettings: {
    /**
     * List settings of an authorized user 
     * @description Lists the settings of an authorized user. Example response contains a shortened list of settings.
     */
    responses: {
      /** @description The list of user settings */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            data: z.object({
              marketplace_allow_custom_install_url: z.boolean().optional(),
              marketplace_app_extensions_vendor: z.boolean().optional(),
              marketplace_team: z.boolean().optional(),
              list_limit: z.number().optional(),
              beta_app: z.boolean().optional(),
              prevent_salesphone_callto_override: z.boolean().optional(),
              file_upload_destination: z.string().optional(),
              callto_link_syntax: z.string().optional(),
              autofill_deal_expected_close_date: z.boolean().optional(),
              person_duplicate_condition: z.string().optional(),
            }).optional(),
          })),
        },
      },
      /** @description Unauthorized response */
      401: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            errorCode: z.number().int().optional(),
          }),
        },
      },
    },
  },
  getWebhooks: {
    /**
     * Get all Webhooks 
     * @description Returns data about all the Webhooks of a company.
     */
    responses: {
      /** @description The list of webhooks objects from the logged in company and user */
      200: {
        content: {
          "application/json": z.intersection(z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            status: z.string().optional(),
          })), z.object({
            data: z.array(z.object({
                id: z.number().int().optional(),
                company_id: z.number().int().optional(),
                owner_id: z.number().int().optional(),
                user_id: z.number().int().optional(),
                event_action: z.string().optional(),
                event_object: z.string().optional(),
                subscription_url: z.string().optional(),
                is_active: z.number().optional(),
                add_time: z.string().optional(),
                remove_time: z.string().nullable().optional(),
                type: z.enum(["general", "app"]).optional(),
                http_auth_user: z.string().nullable().optional(),
                http_auth_password: z.string().nullable().optional(),
                additional_data: z.record(z.any()).optional(),
                remove_reason: z.string().nullable().optional(),
                last_delivery_time: z.string().nullable().optional(),
                last_http_status: z.number().int().nullable().optional(),
                admin_id: z.number().int().optional(),
              })).optional(),
          })),
        },
      },
      /** @description Unauthorized response */
      401: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            errorCode: z.number().int().optional(),
          }),
        },
      },
    },
  },
  addWebhook: {
    /**
     * Create a new Webhook 
     * @description Creates a new Webhook and returns its details. Note that specifying an event which triggers the Webhook combines 2 parameters - `event_action` and `event_object`. E.g., use `*.*` for getting notifications about all events, `added.deal` for any newly added deals, `deleted.persons` for any deleted persons, etc. See <a href="https://pipedrive.readme.io/docs/guide-for-webhooks?ref=api_reference" target="_blank" rel="noopener noreferrer">the guide for Webhooks</a> for more details.
     */
    requestBody: {
      content: {
        "application/json": z.object({
          subscription_url: z.string(),
          event_action: z.enum(["added", "updated", "merged", "deleted", "*"]),
          event_object: z.enum(["activity", "activityType", "deal", "note", "organization", "person", "pipeline", "product", "stage", "user", "*"]),
          user_id: z.number().int().nullish(),
          http_auth_user: z.string().nullish(),
          http_auth_password: z.string().nullish(),
          version: z.enum(["1.0", "2.0"]).nullish(),
        }),
      },
    },
    responses: {
      /** @description The created webhook object */
      201: {
        content: {
          "application/json": z.intersection(z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            status: z.string().optional(),
          })), z.object({
            data: z.object({
              id: z.number().int().optional(),
              company_id: z.number().int().optional(),
              owner_id: z.number().int().optional(),
              user_id: z.number().int().optional(),
              event_action: z.string().optional(),
              event_object: z.string().optional(),
              subscription_url: z.string().optional(),
              is_active: z.number().optional(),
              add_time: z.string().optional(),
              remove_time: z.string().nullable().optional(),
              type: z.enum(["general", "app"]).optional(),
              http_auth_user: z.string().nullable().optional(),
              http_auth_password: z.string().nullable().optional(),
              additional_data: z.record(z.any()).optional(),
              remove_reason: z.string().nullable().optional(),
              last_delivery_time: z.string().nullable().optional(),
              last_http_status: z.number().int().nullable().optional(),
              admin_id: z.number().int().optional(),
            }).optional(),
          })),
        },
      },
      /** @description The bad response on webhook creation */
      400: {
        content: {
          "application/json": z.intersection(z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            status: z.string().optional(),
          })), z.object({
            errors: z.record(z.any()).optional(),
          })),
        },
      },
      /** @description Unauthorized response */
      401: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            errorCode: z.number().int().optional(),
          }),
        },
      },
    },
  },
  deleteWebhook: {
    /**
     * Delete existing Webhook 
     * @description Deletes the specified Webhook.
     */
    parameters: {
        /** @description The ID of the Webhook to delete */
      path: z.object({
        id: z.number().int(),
      }),
    },
    responses: {
      /** @description The webhook deletion success response */
      200: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            status: z.string().optional(),
          })),
        },
      },
      /** @description Unauthorized response */
      401: {
        content: {
          "application/json": z.object({
            success: z.boolean().optional(),
            error: z.string().optional(),
            errorCode: z.number().int().optional(),
          }),
        },
      },
      /** @description The webhook deletion forbidden response */
      403: {
        content: {
          "application/json": z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            message: z.string().optional(),
          })),
        },
      },
      /** @description The webhook deletion not found response */
      404: {
        content: {
          "application/json": z.intersection(z.intersection(z.object({
            success: z.boolean().optional(),
          }), z.object({
            status: z.string().optional(),
          })), z.object({
            errors: z.record(z.any()).optional(),
          })),
        },
      },
    },
  },
}

export const paths = {
  "/activities": {
    /**
     * Get all activities assigned to a particular user 
     * @description Returns all activities assigned to a particular user.
     */
    get: operations["getActivities"],
    /**
     * Add an activity 
     * @description Adds a new activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data). For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-an-activity" target="_blank" rel="noopener noreferrer">adding an activity</a>.
     */
    post: operations["addActivity"],
    /**
     * Delete multiple activities in bulk 
     * @description Marks multiple activities as deleted. After 30 days, the activities will be permanently deleted.
     */
    delete: operations["deleteActivities"],
  },
  "/activities/collection": {
    /**
     * Get all activities (BETA) 
     * @description Returns all activities. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href="https://support.pipedrive.com/en/article/global-user-management" target="_blank" rel="noopener noreferrer">here</a>.
     */
    get: operations["getActivitiesCollection"],
  },
  "/activities/{id}": {
    /**
     * Get details of an activity 
     * @description Returns the details of a specific activity.
     */
    get: operations["getActivity"],
    /**
     * Update an activity 
     * @description Updates an activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data).
     */
    put: operations["updateActivity"],
    /**
     * Delete an activity 
     * @description Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
     */
    delete: operations["deleteActivity"],
  },
  "/activityFields": {
    /**
     * Get all activity fields 
     * @description Returns all activity fields.
     */
    get: operations["getActivityFields"],
  },
  "/activityTypes": {
    /**
     * Get all activity types 
     * @description Returns all activity types.
     */
    get: operations["getActivityTypes"],
    /**
     * Add new activity type 
     * @description Adds a new activity type.
     */
    post: operations["addActivityType"],
    /**
     * Delete multiple activity types in bulk 
     * @description Marks multiple activity types as deleted.
     */
    delete: operations["deleteActivityTypes"],
  },
  "/activityTypes/{id}": {
    /**
     * Update an activity type 
     * @description Updates an activity type.
     */
    put: operations["updateActivityType"],
    /**
     * Delete an activity type 
     * @description Marks an activity type as deleted.
     */
    delete: operations["deleteActivityType"],
  },
  "/billing/subscriptions/addons": {
    /**
     * Get all add-ons for a single company 
     * @description Returns the add-ons for a single company.
     */
    get: operations["getCompanyAddons"],
  },
  "/callLogs": {
    /**
     * Get all call logs assigned to a particular user 
     * @description Returns all call logs assigned to a particular user.
     */
    get: operations["getUserCallLogs"],
    /**
     * Add a call log 
     * @description Adds a new call log.
     */
    post: operations["addCallLog"],
  },
  "/callLogs/{id}": {
    /**
     * Get details of a call log 
     * @description Returns details of a specific call log.
     */
    get: operations["getCallLog"],
    /**
     * Delete a call log 
     * @description Deletes a call log. If there is an audio recording attached to it, it will also be deleted. The related activity will not be removed by this request. If you want to remove the related activities, please use the endpoint which is specific for activities.
     */
    delete: operations["deleteCallLog"],
  },
  "/callLogs/{id}/recordings": {
    /**
     * Attach an audio file to the call log 
     * @description Adds an audio recording to the call log. That audio can be played by those who have access to the call log object.
     */
    post: operations["addCallLogAudioFile"],
  },
  "/channels": {
    /**
     * Add a channel 
     * @description Adds a new messaging channel, only admins are able to register new channels. It will use the getConversations endpoint to fetch conversations, participants and messages afterward. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     */
    post: operations["addChannel"],
  },
  "/channels/{id}": {
    /**
     * Delete a channel 
     * @description Deletes an existing messengers channel and all related entities (conversations and messages). To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     */
    delete: operations["deleteChannel"],
  },
  "/channels/messages/receive": {
    /**
     * Receives an incoming message 
     * @description Adds a message to a conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     */
    post: operations["receiveMessage"],
  },
  "/channels/{channel-id}/conversations/{conversation-id}": {
    /**
     * Delete a conversation 
     * @description Deletes an existing conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     */
    delete: operations["deleteConversation"],
  },
  "/currencies": {
    /**
     * Get all supported currencies 
     * @description Returns all supported currencies in given account which should be used when saving monetary values with other objects. The `code` parameter of the returning objects is the currency code according to ISO 4217 for all non-custom currencies.
     */
    get: operations["getCurrencies"],
  },
  "/deals": {
    /**
     * Get all deals 
     * @description Returns all deals. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/getting-all-deals" target="_blank" rel="noopener noreferrer">getting all deals</a>.
     */
    get: operations["getDeals"],
    /**
     * Add a deal 
     * @description Adds a new deal. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the dealFields and look for `key` values. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/creating-a-deal" target="_blank" rel="noopener noreferrer">adding a deal</a>.
     */
    post: operations["addDeal"],
    /**
     * Delete multiple deals in bulk 
     * @description Marks multiple deals as deleted. After 30 days, the deals will be permanently deleted.
     */
    delete: operations["deleteDeals"],
  },
  "/deals/collection": {
    /**
     * Get all deals (BETA) 
     * @description Returns all deals. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href="https://support.pipedrive.com/en/article/global-user-management" target="_blank" rel="noopener noreferrer">here</a>.
     */
    get: operations["getDealsCollection"],
  },
  "/deals/search": {
    /**
     * Search deals 
     * @description Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href="https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
     */
    get: operations["searchDeals"],
  },
  "/deals/summary": {
    /**
     * Get deals summary 
     * @description Returns a summary of all the deals.
     */
    get: operations["getDealsSummary"],
  },
  "/deals/timeline": {
    /**
     * Get deals timeline 
     * @description Returns open and won deals, grouped by a defined interval of time set in a date-type dealField (`field_key`)  e.g. when month is the chosen interval, and 3 months are asked starting from January 1st, 2012, deals are returned grouped into 3 groups  January, February and March  based on the value of the given `field_key`.
     */
    get: operations["getDealsTimeline"],
  },
  "/deals/{id}": {
    /**
     * Get details of a deal 
     * @description Returns the details of a specific deal. Note that this also returns some additional fields which are not present when asking for all deals  such as deal age and stay in pipeline stages. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of dealFields. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/getting-details-of-a-deal" target="_blank" rel="noopener noreferrer">getting details of a deal</a>.
     */
    get: operations["getDeal"],
    /**
     * Update a deal 
     * @description Updates the properties of a deal. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/updating-a-deal" target="_blank" rel="noopener noreferrer">updating a deal</a>.
     */
    put: operations["updateDeal"],
    /**
     * Delete a deal 
     * @description Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
     */
    delete: operations["deleteDeal"],
  },
  "/deals/{id}/activities": {
    /**
     * List activities associated with a deal 
     * @description Lists activities associated with a deal.
     */
    get: operations["getDealActivities"],
  },
  "/deals/{id}/duplicate": {
    /**
     * Duplicate deal 
     * @description Duplicates a deal.
     */
    post: operations["duplicateDeal"],
  },
  "/deals/{id}/files": {
    /**
     * List files attached to a deal 
     * @description Lists files associated with a deal.
     */
    get: operations["getDealFiles"],
  },
  "/deals/{id}/flow": {
    /**
     * List updates about a deal 
     * @description Lists updates about a deal.
     */
    get: operations["getDealUpdates"],
  },
  "/deals/{id}/followers": {
    /**
     * List followers of a deal 
     * @description Lists the followers of a deal.
     */
    get: operations["getDealFollowers"],
    /**
     * Add a follower to a deal 
     * @description Adds a follower to a deal.
     */
    post: operations["addDealFollower"],
  },
  "/deals/{id}/followers/{follower_id}": {
    /**
     * Delete a follower from a deal 
     * @description Deletes a follower from a deal.
     */
    delete: operations["deleteDealFollower"],
  },
  "/deals/{id}/mailMessages": {
    /**
     * List mail messages associated with a deal 
     * @description Lists mail messages associated with a deal.
     */
    get: operations["getDealMailMessages"],
  },
  "/deals/{id}/merge": {
    /**
     * Merge two deals 
     * @description Merges a deal with another deal. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/merging-two-deals" target="_blank" rel="noopener noreferrer">merging two deals</a>.
     */
    put: operations["mergeDeals"],
  },
  "/deals/{id}/participants": {
    /**
     * List participants of a deal 
     * @description Lists the participants associated with a deal.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     */
    get: operations["getDealParticipants"],
    /**
     * Add a participant to a deal 
     * @description Adds a participant to a deal.
     */
    post: operations["addDealParticipant"],
  },
  "/deals/{id}/participants/{deal_participant_id}": {
    /**
     * Delete a participant from a deal 
     * @description Deletes a participant from a deal.
     */
    delete: operations["deleteDealParticipant"],
  },
  "/deals/{id}/permittedUsers": {
    /**
     * List permitted users 
     * @description Lists the users permitted to access a deal.
     */
    get: operations["getDealUsers"],
  },
  "/deals/{id}/persons": {
    /**
     * List all persons associated with a deal 
     * @description Lists all persons associated with a deal, regardless of whether the person is the primary contact of the deal, or added as a participant.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     */
    get: operations["getDealPersons"],
  },
  "/deals/{id}/products": {
    /**
     * List products attached to a deal 
     * @description Lists products attached to a deal.
     */
    get: operations["getDealProducts"],
    /**
     * Add a product to a deal 
     * @description Adds a product to a deal, creating a new item called a deal-product.
     */
    post: operations["addDealProduct"],
  },
  "/deals/{id}/products/{product_attachment_id}": {
    /**
     * Update the product attached to a deal 
     * @description Updates the details of the product that has been attached to a deal.
     */
    put: operations["updateDealProduct"],
    /**
     * Delete an attached product from a deal 
     * @description Deletes a product attachment from a deal, using the `product_attachment_id`.
     */
    delete: operations["deleteDealProduct"],
  },
  "/dealFields": {
    /**
     * Get all deal fields 
     * @description Returns data about all deal fields.
     */
    get: operations["getDealFields"],
    /**
     * Add a new deal field 
     * @description Adds a new deal field. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-new-custom-field" target="_blank" rel="noopener noreferrer">adding a new custom field</a>.
     */
    post: operations["addDealField"],
    /**
     * Delete multiple deal fields in bulk 
     * @description Marks multiple deal fields as deleted.
     */
    delete: operations["deleteDealFields"],
  },
  "/dealFields/{id}": {
    /**
     * Get one deal field 
     * @description Returns data about a specific deal field.
     */
    get: operations["getDealField"],
    /**
     * Update a deal field 
     * @description Updates a deal field. For more information, see the tutorial for <a href=" https://pipedrive.readme.io/docs/updating-custom-field-value " target="_blank" rel="noopener noreferrer">updating custom fields' values</a>.
     */
    put: operations["updateDealField"],
    /**
     * Delete a deal field 
     * @description Marks a field as deleted. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/deleting-a-custom-field" target="_blank" rel="noopener noreferrer">deleting a custom field</a>.
     */
    delete: operations["deleteDealField"],
  },
  "/files": {
    /**
     * Get all files 
     * @description Returns data about all files.
     */
    get: operations["getFiles"],
    /**
     * Add file 
     * @description Lets you upload a file and associate it with a deal, person, organization, activity, product or lead. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-file" target="_blank" rel="noopener noreferrer">adding a file</a>.
     */
    post: operations["addFile"],
  },
  "/files/remote": {
    /**
     * Create a remote file and link it to an item 
     * @description Creates a new empty file in the remote location (`googledrive`) that will be linked to the item you supply. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-remote-file" target="_blank" rel="noopener noreferrer">adding a remote file</a>.
     */
    post: operations["addFileAndLinkIt"],
  },
  "/files/remoteLink": {
    /**
     * Link a remote file to an item 
     * @description Links an existing remote file (`googledrive`) to the item you supply. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-remote-file" target="_blank" rel="noopener noreferrer">adding a remote file</a>.
     */
    post: operations["linkFileToItem"],
  },
  "/files/{id}": {
    /**
     * Get one file 
     * @description Returns data about a specific file.
     */
    get: operations["getFile"],
    /**
     * Update file details 
     * @description Updates the properties of a file.
     */
    put: operations["updateFile"],
    /**
     * Delete a file 
     * @description Marks a file as deleted. After 30 days, the file will be permanently deleted.
     */
    delete: operations["deleteFile"],
  },
  "/files/{id}/download": {
    /**
     * Download one file 
     * @description Initializes a file download.
     */
    get: operations["downloadFile"],
  },
  "/filters": {
    /**
     * Get all filters 
     * @description Returns data about all filters.
     */
    get: operations["getFilters"],
    /**
     * Add a new filter 
     * @description Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with 'AND', and only two second level condition groups are supported of which one must be glued with 'AND' and the second with 'OR'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-filter" target="_blank" rel="noopener noreferrer">adding a filter</a>.
     */
    post: operations["addFilter"],
    /**
     * Delete multiple filters in bulk 
     * @description Marks multiple filters as deleted.
     */
    delete: operations["deleteFilters"],
  },
  "/filters/helpers": {
    /**
     * Get all filter helpers 
     * @description Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href="/docs/api/v1/Filters#addFilter">add</a> or <a href="/docs/api/v1/Filters#updateFilter">update</a> filters. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-filter" target="_blank" rel="noopener noreferrer">adding a filter</a>.
     */
    get: operations["getFilterHelpers"],
  },
  "/filters/{id}": {
    /**
     * Get one filter 
     * @description Returns data about a specific filter. Note that this also returns the condition lines of the filter.
     */
    get: operations["getFilter"],
    /**
     * Update filter 
     * @description Updates an existing filter.
     */
    put: operations["updateFilter"],
    /**
     * Delete a filter 
     * @description Marks a filter as deleted.
     */
    delete: operations["deleteFilter"],
  },
  "/goals": {
    /**
     * Add a new goal 
     * @description Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
     */
    post: operations["addGoal"],
  },
  "/goals/find": {
    /**
     * Find goals 
     * @description Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
     */
    get: operations["getGoals"],
  },
  "/goals/{id}": {
    /**
     * Update existing goal 
     * @description Updates an existing goal.
     */
    put: operations["updateGoal"],
    /**
     * Delete existing goal 
     * @description Marks a goal as deleted.
     */
    delete: operations["deleteGoal"],
  },
  "/goals/{id}/results": {
    /**
     * Get result of a goal 
     * @description Gets the progress of a goal for the specified period.
     */
    get: operations["getGoalResult"],
  },
  "/itemSearch": {
    /**
     * Perform a search from multiple item types 
     * @description Performs a search from your choice of item types and fields.
     */
    get: operations["searchItem"],
  },
  "/itemSearch/field": {
    /**
     * Perform a search using a specific field from an item type 
     * @description Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
     */
    get: operations["searchItemByField"],
  },
  "/leads": {
    /**
     * Get all leads 
     * @description Returns multiple leads. Leads are sorted by the time they were created, from oldest to newest. Pagination can be controlled using `limit` and `start` query parameters. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals.
     */
    get: operations["getLeads"],
    /**
     * Add a lead 
     * @description Creates a lead. A lead always has to be linked to a person or an organization or both. All leads created through the Pipedrive API will have a lead source `API` assigned. Here's the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-lead" target="_blank" rel="noopener noreferrer">adding a lead</a>. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals. See an example given in the <a href="https://pipedrive.readme.io/docs/updating-custom-field-value" target="_blank" rel="noopener noreferrer">updating custom fields' values tutorial</a>.
     */
    post: operations["addLead"],
  },
  "/leads/{id}": {
    /**
     * Get one lead 
     * @description Returns details of a specific lead. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals.
     */
    get: operations["getLead"],
    /**
     * Delete a lead 
     * @description Deletes a specific lead.
     */
    delete: operations["deleteLead"],
    /**
     * Update a lead 
     * @description Updates one or more properties of a lead. Only properties included in the request will be updated. Send `null` to unset a property (applicable for example for `value`, `person_id` or `organization_id`). If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals. See an example given in the <a href="https://pipedrive.readme.io/docs/updating-custom-field-value" target="_blank" rel="noopener noreferrer">updating custom fields values tutorial</a>.
     */
    patch: operations["updateLead"],
  },
  "/leads/{id}/permittedUsers": {
    /**
     * List permitted users 
     * @description Lists the users permitted to access a lead.
     */
    get: operations["getLeadUsers"],
  },
  "/leads/search": {
    /**
     * Search leads 
     * @description Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href="https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
     */
    get: operations["searchLeads"],
  },
  "/leadLabels": {
    /**
     * Get all lead labels 
     * @description Returns details of all lead labels. This endpoint does not support pagination and all labels are always returned.
     */
    get: operations["getLeadLabels"],
    /**
     * Add a lead label 
     * @description Creates a lead label.
     */
    post: operations["addLeadLabel"],
  },
  "/leadLabels/{id}": {
    /**
     * Delete a lead label 
     * @description Deletes a specific lead label.
     */
    delete: operations["deleteLeadLabel"],
    /**
     * Update a lead label 
     * @description Updates one or more properties of a lead label. Only properties included in the request will be updated.
     */
    patch: operations["updateLeadLabel"],
  },
  "/leadSources": {
    /**
     * Get all lead sources 
     * @description Returns all lead sources. Please note that the list of lead sources is fixed, it cannot be modified. All leads created through the Pipedrive API will have a lead source `API` assigned.
     */
    get: operations["getLeadSources"],
  },
  "/legacyTeams": {
    /**
     * Get all teams 
     * @deprecated 
     * @description Returns data about teams within the company.
     */
    get: operations["getTeams"],
    /**
     * Add a new team 
     * @deprecated 
     * @description Adds a new team to the company and returns the created object.
     */
    post: operations["addTeam"],
  },
  "/legacyTeams/{id}": {
    /**
     * Get a single team 
     * @deprecated 
     * @description Returns data about a specific team.
     */
    get: operations["getTeam"],
    /**
     * Update a team 
     * @deprecated 
     * @description Updates an existing team and returns the updated object.
     */
    put: operations["updateTeam"],
  },
  "/legacyTeams/{id}/users": {
    /**
     * Get all users in a team 
     * @deprecated 
     * @description Returns a list of all user IDs within a team.
     */
    get: operations["getTeamUsers"],
    /**
     * Add users to a team 
     * @deprecated 
     * @description Adds users to an existing team.
     */
    post: operations["addTeamUser"],
    /**
     * Delete users from a team 
     * @deprecated 
     * @description Deletes users from an existing team.
     */
    delete: operations["deleteTeamUser"],
  },
  "/legacyTeams/user/{id}": {
    /**
     * Get all teams of a user 
     * @deprecated 
     * @description Returns data about all teams which have the specified user as a member.
     */
    get: operations["getUserTeams"],
  },
  "/mailbox/mailMessages/{id}": {
    /**
     * Get one mail message 
     * @description Returns data about a specific mail message.
     */
    get: operations["getMailMessage"],
  },
  "/mailbox/mailThreads": {
    /**
     * Get mail threads 
     * @description Returns mail threads in a specified folder ordered by the most recent message within.
     */
    get: operations["getMailThreads"],
  },
  "/mailbox/mailThreads/{id}": {
    /**
     * Get one mail thread 
     * @description Returns a specific mail thread.
     */
    get: operations["getMailThread"],
    /**
     * Update mail thread details 
     * @description Updates the properties of a mail thread.
     */
    put: operations["updateMailThreadDetails"],
    /**
     * Delete mail thread 
     * @description Marks a mail thread as deleted.
     */
    delete: operations["deleteMailThread"],
  },
  "/mailbox/mailThreads/{id}/mailMessages": {
    /**
     * Get all mail messages of mail thread 
     * @description Returns all the mail messages inside a specified mail thread.
     */
    get: operations["getMailThreadMessages"],
  },
  "/meetings/userProviderLinks": {
    /**
     * Link a user with the installed video call integration 
     * @description A video calling provider must call this endpoint after a user has installed the video calling app so that the new user's information is sent.
     */
    post: operations["saveUserProviderLink"],
  },
  "/meetings/userProviderLinks/{id}": {
    /**
     * Delete the link between a user and the installed video call integration 
     * @description A video calling provider must call this endpoint to remove the link between a user and the installed video calling app.
     */
    delete: operations["deleteUserProviderLink"],
  },
  "/notes": {
    /**
     * Get all notes 
     * @description Returns all notes.
     */
    get: operations["getNotes"],
    /**
     * Add a note 
     * @description Adds a new note.
     */
    post: operations["addNote"],
  },
  "/notes/{id}": {
    /**
     * Get one note 
     * @description Returns details about a specific note.
     */
    get: operations["getNote"],
    /**
     * Update a note 
     * @description Updates a note.
     */
    put: operations["updateNote"],
    /**
     * Delete a note 
     * @description Deletes a specific note.
     */
    delete: operations["deleteNote"],
  },
  "/notes/{id}/comments": {
    /**
     * Get all comments for a note 
     * @description Returns all comments associated with a note.
     */
    get: operations["getNoteComments"],
    /**
     * Add a comment to a note 
     * @description Adds a new comment to a note.
     */
    post: operations["addNoteComment"],
  },
  "/notes/{id}/comments/{commentId}": {
    /**
     * Get one comment 
     * @description Returns the details of a comment.
     */
    get: operations["getComment"],
    /**
     * Update a comment related to a note 
     * @description Updates a comment related to a note.
     */
    put: operations["updateCommentForNote"],
    /**
     * Delete a comment related to a note 
     * @description Deletes a comment.
     */
    delete: operations["deleteComment"],
  },
  "/noteFields": {
    /**
     * Get all note fields 
     * @description Returns data about all note fields.
     */
    get: operations["getNoteFields"],
  },
  "/organizations": {
    /**
     * Get all organizations 
     * @description Returns all organizations.
     */
    get: operations["getOrganizations"],
    /**
     * Add an organization 
     * @description Adds a new organization. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the organizationFields and look for `key` values. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-an-organization" target="_blank" rel="noopener noreferrer">adding an organization</a>.
     */
    post: operations["addOrganization"],
    /**
     * Delete multiple organizations in bulk 
     * @description Marks multiple organizations as deleted. After 30 days, the organizations will be permanently deleted.
     */
    delete: operations["deleteOrganizations"],
  },
  "/organizations/collection": {
    /**
     * Get all organizations (BETA) 
     * @description Returns all organizations. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href="https://support.pipedrive.com/en/article/global-user-management" target="_blank" rel="noopener noreferrer">here</a>.
     */
    get: operations["getOrganizationsCollection"],
  },
  "/organizations/search": {
    /**
     * Search organizations 
     * @description Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href="https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem">/v1/itemSearch</a> with a narrower OAuth scope.
     */
    get: operations["searchOrganization"],
  },
  "/organizations/{id}": {
    /**
     * Get details of an organization 
     * @description Returns the details of an organization. Note that this also returns some additional fields which are not present when asking for all organizations. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of organizationFields.
     */
    get: operations["getOrganization"],
    /**
     * Update an organization 
     * @description Updates the properties of an organization.
     */
    put: operations["updateOrganization"],
    /**
     * Delete an organization 
     * @description Marks an organization as deleted. After 30 days, the organization will be permanently deleted.
     */
    delete: operations["deleteOrganization"],
  },
  "/organizations/{id}/activities": {
    /**
     * List activities associated with an organization 
     * @description Lists activities associated with an organization.
     */
    get: operations["getOrganizationActivities"],
  },
  "/organizations/{id}/deals": {
    /**
     * List deals associated with an organization 
     * @description Lists deals associated with an organization.
     */
    get: operations["getOrganizationDeals"],
  },
  "/organizations/{id}/files": {
    /**
     * List files attached to an organization 
     * @description Lists files associated with an organization.
     */
    get: operations["getOrganizationFiles"],
  },
  "/organizations/{id}/flow": {
    /**
     * List updates about an organization 
     * @description Lists updates about an organization.
     */
    get: operations["getOrganizationUpdates"],
  },
  "/organizations/{id}/followers": {
    /**
     * List followers of an organization 
     * @description Lists the followers of an organization.
     */
    get: operations["getOrganizationFollowers"],
    /**
     * Add a follower to an organization 
     * @description Adds a follower to an organization.
     */
    post: operations["addOrganizationFollower"],
  },
  "/organizations/{id}/followers/{follower_id}": {
    /**
     * Delete a follower from an organization 
     * @description Deletes a follower from an organization. You can retrieve the `follower_id` from the <a href="https://developers.pipedrive.com/docs/api/v1/Organizations#getOrganizationFollowers">List followers of an organization</a> endpoint.
     */
    delete: operations["deleteOrganizationFollower"],
  },
  "/organizations/{id}/mailMessages": {
    /**
     * List mail messages associated with an organization 
     * @description Lists mail messages associated with an organization.
     */
    get: operations["getOrganizationMailMessages"],
  },
  "/organizations/{id}/merge": {
    /**
     * Merge two organizations 
     * @description Merges an organization with another organization. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/merging-two-organizations" target="_blank" rel="noopener noreferrer">merging two organizations</a>.
     */
    put: operations["mergeOrganizations"],
  },
  "/organizations/{id}/permittedUsers": {
    /**
     * List permitted users 
     * @description List users permitted to access an organization.
     */
    get: operations["getOrganizationUsers"],
  },
  "/organizations/{id}/persons": {
    /**
     * List persons of an organization 
     * @description Lists persons associated with an organization.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     */
    get: operations["getOrganizationPersons"],
  },
  "/organizationFields": {
    /**
     * Get all organization fields 
     * @description Returns data about all organization fields.
     */
    get: operations["getOrganizationFields"],
    /**
     * Add a new organization field 
     * @description Adds a new organization field. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-new-custom-field" target="_blank" rel="noopener noreferrer">adding a new custom field</a>.
     */
    post: operations["addOrganizationField"],
    /**
     * Delete multiple organization fields in bulk 
     * @description Marks multiple fields as deleted.
     */
    delete: operations["deleteOrganizationFields"],
  },
  "/organizationFields/{id}": {
    /**
     * Get one organization field 
     * @description Returns data about a specific organization field.
     */
    get: operations["getOrganizationField"],
    /**
     * Update an organization field 
     * @description Updates an organization field. For more information, see the tutorial for <a href=" https://pipedrive.readme.io/docs/updating-custom-field-value " target="_blank" rel="noopener noreferrer">updating custom fields' values</a>.
     */
    put: operations["updateOrganizationField"],
    /**
     * Delete an organization field 
     * @description Marks a field as deleted. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/deleting-a-custom-field" target="_blank" rel="noopener noreferrer">deleting a custom field</a>.
     */
    delete: operations["deleteOrganizationField"],
  },
  "/organizationRelationships": {
    /**
     * Get all relationships for organization 
     * @description Gets all of the relationships for a supplied organization ID.
     */
    get: operations["getOrganizationRelationships"],
    /**
     * Create an organization relationship 
     * @description Creates and returns an organization relationship.
     */
    post: operations["addOrganizationRelationship"],
  },
  "/organizationRelationships/{id}": {
    /**
     * Get one organization relationship 
     * @description Finds and returns an organization relationship from its ID.
     */
    get: operations["getOrganizationRelationship"],
    /**
     * Update an organization relationship 
     * @description Updates and returns an organization relationship.
     */
    put: operations["updateOrganizationRelationship"],
    /**
     * Delete an organization relationship 
     * @description Deletes an organization relationship and returns the deleted ID.
     */
    delete: operations["deleteOrganizationRelationship"],
  },
  "/permissionSets": {
    /**
     * Get all permission sets 
     * @description Returns data about all permission sets.
     */
    get: operations["getPermissionSets"],
  },
  "/permissionSets/{id}": {
    /**
     * Get one permission set 
     * @description Returns data about a specific permission set.
     */
    get: operations["getPermissionSet"],
  },
  "/permissionSets/{id}/assignments": {
    /**
     * List permission set assignments 
     * @description Returns the list of assignments for a permission set.
     */
    get: operations["getPermissionSetAssignments"],
  },
  "/persons": {
    /**
     * Get all persons 
     * @description Returns all persons.
     */
    get: operations["getPersons"],
    /**
     * Add a person 
     * @description Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
     */
    post: operations["addPerson"],
    /**
     * Delete multiple persons in bulk 
     * @description Marks multiple persons as deleted. After 30 days, the persons will be permanently deleted.
     */
    delete: operations["deletePersons"],
  },
  "/persons/collection": {
    /**
     * Get all persons (BETA) 
     * @description Returns all persons. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href="https://support.pipedrive.com/en/article/global-user-management" target="_blank" rel="noopener noreferrer">here</a>.
     */
    get: operations["getPersonsCollection"],
  },
  "/persons/search": {
    /**
     * Search persons 
     * @description Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href="https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
     */
    get: operations["searchPersons"],
  },
  "/persons/{id}": {
    /**
     * Get details of a person 
     * @description Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     */
    get: operations["getPerson"],
    /**
     * Update a person 
     * @description Updates the properties of a person. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/updating-a-person" target="_blank" rel="noopener noreferrer">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
     */
    put: operations["updatePerson"],
    /**
     * Delete a person 
     * @description Marks a person as deleted. After 30 days, the person will be permanently deleted.
     */
    delete: operations["deletePerson"],
  },
  "/persons/{id}/activities": {
    /**
     * List activities associated with a person 
     * @description Lists activities associated with a person.
     */
    get: operations["getPersonActivities"],
  },
  "/persons/{id}/deals": {
    /**
     * List deals associated with a person 
     * @description Lists deals associated with a person.
     */
    get: operations["getPersonDeals"],
  },
  "/persons/{id}/files": {
    /**
     * List files attached to a person 
     * @description Lists files associated with a person.
     */
    get: operations["getPersonFiles"],
  },
  "/persons/{id}/flow": {
    /**
     * List updates about a person 
     * @description Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint's response will also include updates for the `marketing_status` field.
     */
    get: operations["getPersonUpdates"],
  },
  "/persons/{id}/followers": {
    /**
     * List followers of a person 
     * @description Lists the followers of a person.
     */
    get: operations["getPersonFollowers"],
    /**
     * Add a follower to a person 
     * @description Adds a follower to a person.
     */
    post: operations["addPersonFollower"],
  },
  "/persons/{id}/followers/{follower_id}": {
    /**
     * Delete a follower from a person 
     * @description Deletes a follower from a person.
     */
    delete: operations["deletePersonFollower"],
  },
  "/persons/{id}/mailMessages": {
    /**
     * List mail messages associated with a person 
     * @description Lists mail messages associated with a person.
     */
    get: operations["getPersonMailMessages"],
  },
  "/persons/{id}/merge": {
    /**
     * Merge two persons 
     * @description Merges a person with another person. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/merging-two-persons" target="_blank" rel="noopener noreferrer">merging two persons</a>.
     */
    put: operations["mergePersons"],
  },
  "/persons/{id}/permittedUsers": {
    /**
     * List permitted users 
     * @description List users permitted to access a person.
     */
    get: operations["getPersonUsers"],
  },
  "/persons/{id}/picture": {
    /**
     * Add person picture 
     * @description Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
     */
    post: operations["addPersonPicture"],
    /**
     * Delete person picture 
     * @description Deletes a persons picture.
     */
    delete: operations["deletePersonPicture"],
  },
  "/persons/{id}/products": {
    /**
     * List products associated with a person 
     * @description Lists products associated with a person.
     */
    get: operations["getPersonProducts"],
  },
  "/personFields": {
    /**
     * Get all person fields 
     * @description Returns data about all person fields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     */
    get: operations["getPersonFields"],
    /**
     * Add a new person field 
     * @description Adds a new person field. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-new-custom-field" target="_blank" rel="noopener noreferrer">adding a new custom field</a>.
     */
    post: operations["addPersonField"],
    /**
     * Delete multiple person fields in bulk 
     * @description Marks multiple fields as deleted.
     */
    delete: operations["deletePersonFields"],
  },
  "/personFields/{id}": {
    /**
     * Get one person field 
     * @description Returns data about a specific person field.
     */
    get: operations["getPersonField"],
    /**
     * Update a person field 
     * @description Updates a person field. For more information, see the tutorial for <a href=" https://pipedrive.readme.io/docs/updating-custom-field-value " target="_blank" rel="noopener noreferrer">updating custom fields' values</a>.
     */
    put: operations["updatePersonField"],
    /**
     * Delete a person field 
     * @description Marks a field as deleted. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/deleting-a-custom-field" target="_blank" rel="noopener noreferrer">deleting a custom field</a>.
     */
    delete: operations["deletePersonField"],
  },
  "/pipelines": {
    /**
     * Get all pipelines 
     * @description Returns data about all pipelines.
     */
    get: operations["getPipelines"],
    /**
     * Add a new pipeline 
     * @description Adds a new pipeline.
     */
    post: operations["addPipeline"],
  },
  "/pipelines/{id}": {
    /**
     * Get one pipeline 
     * @description Returns data about a specific pipeline. Also returns the summary of the deals in this pipeline across its stages.
     */
    get: operations["getPipeline"],
    /**
     * Update a pipeline 
     * @description Updates the properties of a pipeline.
     */
    put: operations["updatePipeline"],
    /**
     * Delete a pipeline 
     * @description Marks a pipeline as deleted.
     */
    delete: operations["deletePipeline"],
  },
  "/pipelines/{id}/conversion_statistics": {
    /**
     * Get deals conversion rates in pipeline 
     * @description Returns all stage-to-stage conversion and pipeline-to-close rates for the given time period.
     */
    get: operations["getPipelineConversionStatistics"],
  },
  "/pipelines/{id}/deals": {
    /**
     * Get deals in a pipeline 
     * @description Lists deals in a specific pipeline across all its stages.
     */
    get: operations["getPipelineDeals"],
  },
  "/pipelines/{id}/movement_statistics": {
    /**
     * Get deals movements in pipeline 
     * @description Returns statistics for deals movements for the given time period.
     */
    get: operations["getPipelineMovementStatistics"],
  },
  "/products": {
    /**
     * Get all products 
     * @description Returns data about all products.
     */
    get: operations["getProducts"],
    /**
     * Add a product 
     * @description Adds a new product to the Products inventory. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-product" target="_blank" rel="noopener noreferrer">adding a product</a>.
     */
    post: operations["addProduct"],
  },
  "/products/search": {
    /**
     * Search products 
     * @description Searches all products by name, code and/or custom fields. This endpoint is a wrapper of <a href="https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem">/v1/itemSearch</a> with a narrower OAuth scope.
     */
    get: operations["searchProducts"],
  },
  "/products/{id}": {
    /**
     * Get one product 
     * @description Returns data about a specific product.
     */
    get: operations["getProduct"],
    /**
     * Update a product 
     * @description Updates product data.
     */
    put: operations["updateProduct"],
    /**
     * Delete a product 
     * @description Marks a product as deleted. After 30 days, the product will be permanently deleted.
     */
    delete: operations["deleteProduct"],
  },
  "/products/{id}/deals": {
    /**
     * Get deals where a product is attached to 
     * @description Returns data about deals that have a product attached to it.
     */
    get: operations["getProductDeals"],
  },
  "/products/{id}/files": {
    /**
     * List files attached to a product 
     * @description Lists files associated with a product.
     */
    get: operations["getProductFiles"],
  },
  "/products/{id}/followers": {
    /**
     * List followers of a product 
     * @description Lists the followers of a product.
     */
    get: operations["getProductFollowers"],
    /**
     * Add a follower to a product 
     * @description Adds a follower to a product.
     */
    post: operations["addProductFollower"],
  },
  "/products/{id}/followers/{follower_id}": {
    /**
     * Delete a follower from a product 
     * @description Deletes a follower from a product.
     */
    delete: operations["deleteProductFollower"],
  },
  "/products/{id}/permittedUsers": {
    /**
     * List permitted users 
     * @description Lists users permitted to access a product.
     */
    get: operations["getProductUsers"],
  },
  "/productFields": {
    /**
     * Get all product fields 
     * @description Returns data about all product fields.
     */
    get: operations["getProductFields"],
    /**
     * Add a new product field 
     * @description Adds a new product field. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/adding-a-new-custom-field" target="_blank" rel="noopener noreferrer">adding a new custom field</a>.
     */
    post: operations["addProductField"],
    /**
     * Delete multiple product fields in bulk 
     * @description Marks multiple fields as deleted.
     */
    delete: operations["deleteProductFields"],
  },
  "/productFields/{id}": {
    /**
     * Get one product field 
     * @description Returns data about a specific product field.
     */
    get: operations["getProductField"],
    /**
     * Update a product field 
     * @description Updates a product field. For more information, see the tutorial for <a href=" https://pipedrive.readme.io/docs/updating-custom-field-value " target="_blank" rel="noopener noreferrer">updating custom fields' values</a>.
     */
    put: operations["updateProductField"],
    /**
     * Delete a product field 
     * @description Marks a product field as deleted. For more information, see the tutorial for <a href="https://pipedrive.readme.io/docs/deleting-a-custom-field" target="_blank" rel="noopener noreferrer">deleting a custom field</a>.
     */
    delete: operations["deleteProductField"],
  },
  "/projects": {
    /**
     * Get all projects 
     * @description Returns all projects. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>.
     */
    get: operations["getProjects"],
    /**
     * Add a project 
     * @description Adds a new project. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys.
     */
    post: operations["addProject"],
  },
  "/projects/{id}": {
    /**
     * Get details of a project 
     * @description Returns the details of a specific project. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of project fields.
     */
    get: operations["getProject"],
    /**
     * Update a project 
     * @description Updates a project.
     */
    put: operations["updateProject"],
    /**
     * Delete a project 
     * @description Marks a project as deleted.
     */
    delete: operations["deleteProject"],
  },
  "/projects/{id}/archive": {
    /**
     * Archive a project 
     * @description Archives a project.
     */
    post: operations["archiveProject"],
  },
  "/projects/{id}/plan": {
    /**
     * Returns project plan 
     * @description Returns information about items in a project plan. Items consists of tasks and activities and are linked to specific project phase and group.
     */
    get: operations["getProjectPlan"],
  },
  "/projects/{id}/plan/activities/{activityId}": {
    /**
     * Update activity in project plan 
     * @description Updates an activity phase or group in a project.
     */
    put: operations["putProjectPlanActivity"],
  },
  "/projects/{id}/plan/tasks/{taskId}": {
    /**
     * Update task in project plan 
     * @description Updates a task phase or group in a project.
     */
    put: operations["putProjectPlanTask"],
  },
  "/projects/{id}/groups": {
    /**
     * Returns project groups 
     * @description Returns all active groups under a specific project.
     */
    get: operations["getProjectGroups"],
  },
  "/projects/{id}/tasks": {
    /**
     * Returns project tasks 
     * @description Returns tasks linked to a specific project.
     */
    get: operations["getProjectTasks"],
  },
  "/projects/{id}/activities": {
    /**
     * Returns project activities 
     * @description Returns activities linked to a specific project.
     */
    get: operations["getProjectActivities"],
  },
  "/projects/boards": {
    /**
     * Get all project boards 
     * @description Returns all projects boards that are not deleted.
     */
    get: operations["getProjectsBoards"],
  },
  "/projects/boards/{id}": {
    /**
     * Get details of a board 
     * @description Returns the details of a specific project board.
     */
    get: operations["getProjectsBoard"],
  },
  "/projects/phases": {
    /**
     * Get project phases 
     * @description Returns all active project phases under a specific board.
     */
    get: operations["getProjectsPhases"],
  },
  "/projects/phases/{id}": {
    /**
     * Get details of a phase 
     * @description Returns the details of a specific project phase.
     */
    get: operations["getProjectsPhase"],
  },
  "/projectTemplates": {
    /**
     * Get all project templates 
     * @description Returns all not deleted project templates. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>.
     */
    get: operations["getProjectTemplates"],
  },
  "/projectTemplates/{id}": {
    /**
     * Get details of a template 
     * @description Returns the details of a specific project template.
     */
    get: operations["getProjectTemplate"],
  },
  "/recents": {
    /**
     * Get recents 
     * @description Returns data about all recent changes occurred after the given timestamp.
     */
    get: operations["getRecents"],
  },
  "/roles": {
    /**
     * Get all roles 
     * @description Returns all the roles within the company.
     */
    get: operations["getRoles"],
    /**
     * Add a role 
     * @description Adds a new role.
     */
    post: operations["addRole"],
  },
  "/roles/{id}": {
    /**
     * Get one role 
     * @description Returns the details of a specific role.
     */
    get: operations["getRole"],
    /**
     * Update role details 
     * @description Updates the parent role and/or the name of a specific role.
     */
    put: operations["updateRole"],
    /**
     * Delete a role 
     * @description Marks a role as deleted.
     */
    delete: operations["deleteRole"],
  },
  "/roles/{id}/assignments": {
    /**
     * List role assignments 
     * @description Returns all users assigned to a role.
     */
    get: operations["getRoleAssignments"],
    /**
     * Add role assignment 
     * @description Assigns a user to a role.
     */
    post: operations["addRoleAssignment"],
    /**
     * Delete a role assignment 
     * @description Removes the assigned user from a role and adds to the default role.
     */
    delete: operations["deleteRoleAssignment"],
  },
  "/roles/{id}/settings": {
    /**
     * List role settings 
     * @description Returns the visibility settings of a specific role.
     */
    get: operations["getRoleSettings"],
    /**
     * Add or update role setting 
     * @description Adds or updates the visibility setting for a role.
     */
    post: operations["addOrUpdateRoleSetting"],
  },
  "/roles/{id}/pipelines": {
    /**
     * List pipeline visibility for a role 
     * @description Returns the list of either visible or hidden pipeline IDs for a specific role. For more information on pipeline visibility, please refer to the <a href="https://support.pipedrive.com/en/article/visibility-groups" target="_blank" rel="noopener noreferrer">Visibility groups article</a>.
     */
    get: operations["getRolePipelines"],
    /**
     * Update pipeline visibility for a role 
     * @description Updates the specified pipelines to be visible and/or hidden for a specific role. For more information on pipeline visibility, please refer to the <a href="https://support.pipedrive.com/en/article/visibility-groups" target="_blank" rel="noopener noreferrer">Visibility groups article</a>.
     */
    put: operations["updateRolePipelines"],
  },
  "/stages": {
    /**
     * Get all stages 
     * @description Returns data about all stages.
     */
    get: operations["getStages"],
    /**
     * Add a new stage 
     * @description Adds a new stage, returns the ID upon success.
     */
    post: operations["addStage"],
    /**
     * Delete multiple stages in bulk 
     * @description Marks multiple stages as deleted.
     */
    delete: operations["deleteStages"],
  },
  "/stages/{id}": {
    /**
     * Get one stage 
     * @description Returns data about a specific stage.
     */
    get: operations["getStage"],
    /**
     * Update stage details 
     * @description Updates the properties of a stage.
     */
    put: operations["updateStage"],
    /**
     * Delete a stage 
     * @description Marks a stage as deleted.
     */
    delete: operations["deleteStage"],
  },
  "/stages/{id}/deals": {
    /**
     * Get deals in a stage 
     * @description Lists deals in a specific stage.
     */
    get: operations["getStageDeals"],
  },
  "/subscriptions/{id}": {
    /**
     * Get details of a subscription 
     * @description Returns details of an installment or a recurring subscription.
     */
    get: operations["getSubscription"],
    /**
     * Delete a subscription 
     * @description Marks an installment or a recurring subscription as deleted.
     */
    delete: operations["deleteSubscription"],
  },
  "/subscriptions/find/{dealId}": {
    /**
     * Find subscription by deal 
     * @description Returns details of an installment or a recurring subscription by the deal ID.
     */
    get: operations["findSubscriptionByDeal"],
  },
  "/subscriptions/{id}/payments": {
    /**
     * Get all payments of a subscription 
     * @description Returns all payments of an installment or recurring subscription.
     */
    get: operations["getSubscriptionPayments"],
  },
  "/subscriptions/recurring": {
    /**
     * Add a recurring subscription 
     * @description Adds a new recurring subscription.
     */
    post: operations["addRecurringSubscription"],
  },
  "/subscriptions/installment": {
    /**
     * Add an installment subscription 
     * @description Adds a new installment subscription.
     */
    post: operations["addSubscriptionInstallment"],
  },
  "/subscriptions/recurring/{id}": {
    /**
     * Update a recurring subscription 
     * @description Updates a recurring subscription.
     */
    put: operations["updateRecurringSubscription"],
  },
  "/subscriptions/installment/{id}": {
    /**
     * Update an installment subscription 
     * @description Updates an installment subscription.
     */
    put: operations["updateSubscriptionInstallment"],
  },
  "/subscriptions/recurring/{id}/cancel": {
    /**
     * Cancel a recurring subscription 
     * @description Cancels a recurring subscription.
     */
    put: operations["cancelRecurringSubscription"],
  },
  "/tasks": {
    /**
     * Get all tasks 
     * @description Returns all tasks. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href="https://pipedrive.readme.io/docs/core-api-concepts-pagination" target="_blank" rel="noopener noreferrer">pagination</a>.
     */
    get: operations["getTasks"],
    /**
     * Add a task 
     * @description Adds a new task.
     */
    post: operations["addTask"],
  },
  "/tasks/{id}": {
    /**
     * Get details of a task 
     * @description Returns the details of a specific task.
     */
    get: operations["getTask"],
    /**
     * Update a task 
     * @description Updates a task.
     */
    put: operations["updateTask"],
    /**
     * Delete a task 
     * @description Marks a task as deleted. If the task has subtasks then those will also be deleted.
     */
    delete: operations["deleteTask"],
  },
  "/users": {
    /**
     * Get all users 
     * @description Returns data about all users within the company.
     */
    get: operations["getUsers"],
    /**
     * Add a new user 
     * @description Adds a new user to the company, returns the ID upon success.
     */
    post: operations["addUser"],
  },
  "/users/find": {
    /**
     * Find users by name 
     * @description Finds users by their name.
     */
    get: operations["findUsersByName"],
  },
  "/users/me": {
    /**
     * Get current user data 
     * @description Returns data about an authorized user within the company with bound company data: company ID, company name, and domain. Note that the `locale` property means 'Date/number format' in the Pipedrive account settings, not the chosen language.
     */
    get: operations["getCurrentUser"],
  },
  "/users/{id}": {
    /**
     * Get one user 
     * @description Returns data about a specific user within the company.
     */
    get: operations["getUser"],
    /**
     * Update user details 
     * @description Updates the properties of a user. Currently, only `active_flag` can be updated.
     */
    put: operations["updateUser"],
  },
  "/users/{id}/followers": {
    /**
     * List followers of a user 
     * @description Lists the followers of a specific user.
     */
    get: operations["getUserFollowers"],
  },
  "/users/{id}/permissions": {
    /**
     * List user permissions 
     * @description Lists aggregated permissions over all assigned permission sets for a user.
     */
    get: operations["getUserPermissions"],
  },
  "/users/{id}/roleAssignments": {
    /**
     * List role assignments 
     * @description Lists role assignments for a user.
     */
    get: operations["getUserRoleAssignments"],
  },
  "/users/{id}/roleSettings": {
    /**
     * List user role settings 
     * @description Lists the settings of user's assigned role.
     */
    get: operations["getUserRoleSettings"],
  },
  "/userConnections": {
    /**
     * Get all user connections 
     * @description Returns data about all connections for the authorized user.
     */
    get: operations["getUserConnections"],
  },
  "/userSettings": {
    /**
     * List settings of an authorized user 
     * @description Lists the settings of an authorized user. Example response contains a shortened list of settings.
     */
    get: operations["getUserSettings"],
  },
  "/webhooks": {
    /**
     * Get all Webhooks 
     * @description Returns data about all the Webhooks of a company.
     */
    get: operations["getWebhooks"],
    /**
     * Create a new Webhook 
     * @description Creates a new Webhook and returns its details. Note that specifying an event which triggers the Webhook combines 2 parameters - `event_action` and `event_object`. E.g., use `*.*` for getting notifications about all events, `added.deal` for any newly added deals, `deleted.persons` for any deleted persons, etc. See <a href="https://pipedrive.readme.io/docs/guide-for-webhooks?ref=api_reference" target="_blank" rel="noopener noreferrer">the guide for Webhooks</a> for more details.
     */
    post: operations["addWebhook"],
  },
  "/webhooks/{id}": {
    /**
     * Delete existing Webhook 
     * @description Deletes the specified Webhook.
     */
    delete: operations["deleteWebhook"],
  },
}
